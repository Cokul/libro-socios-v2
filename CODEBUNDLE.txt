

# ===== app/__init__.py =====



# ===== app/core/__init__.py =====



# ===== app/core/enums.py =====

# app/core/enums.py

# Lista “canónica” de cargos que aparecerán en el desplegable
GOVERNANCE_ROLES: list[str] = [
    "Administrador Único",
    "Presidente",
    "Vicepresidente",
    "Secretario",
    "Vicesecretario",
    "Secretario - Consejero",
    "Consejero Delegado",
    "Consejero",
    "Apoderado",
]

# Aliases heredados (v1) -> nombre canónico
GOVERNANCE_ROLE_ALIASES: dict[str, str] = {
    "admin_unico": "Administrador Único",
    "administrador_unico": "Administrador Único",
    "consejero_delegado": "Consejero Delegado",
    "vicepresidente": "Vicepresidente",
    "presidente": "Presidente",
    "secretario": "Secretario",
    "vicesecretario": "Vicesecretario",
    "secretario_consejero": "Secretario - Consejero",
    "sec_consejero": "Secretario - Consejero",
    "consejero": "Consejero",
    "apoderado": "Apoderado",
}

# Tipos canónicos (v1 + v2)
EVENT_TYPES: list[str] = [
    "ALTA",
    "AMPL_EMISION",
    "AMPL_VALOR",
    "TRANSMISION",
    "BAJA",
    "RED_AMORT",
    "RED_VALOR",
    "PIGNORACION",
    "EMBARGO",
    "CANCELA_PIGNORACION",  # ← nuevo
    "CANCELA_EMBARGO",      # ← nuevo
    "LEV_GRAVAMEN",         # opcional genérico
    "ALZAMIENTO",           # opcional genérico
    "USUFRUCTO",
    "REDENOMINACION",
    "SUCESION",
]

# Aliases (normalizamos varios literales a los canónicos)
EVENT_TYPE_ALIASES: dict[str, str] = {
    "TRASMISION": "TRANSMISION",
    "REDENOMINACIÓN": "REDENOMINACION",
    "REDENOM": "REDENOMINACION",
    "REDEN": "REDENOMINACION",
    # Sinónimos de cancelaciones:
    "LEVANTAMIENTO": "LEV_GRAVAMEN",
    "LEVANTAMIENTO_DE_GRAVAMEN": "LEV_GRAVAMEN",
    "ALZAR_EMBARGO": "ALZAMIENTO",
    "ALZAMIENTO_DE_EMBARGO": "ALZAMIENTO",
}

# Etiquetas legibles (por si quieres usarlas en UI/reportes)
EVENT_LABELS: dict[str, str] = {
    "ALTA": "Alta",
    "AMPL_EMISION": "Ampliación (emisión)",
    "AMPL_VALOR": "Aumento de VN",
    "TRANSMISION": "Transmisión",
    "BAJA": "Baja",
    "RED_AMORT": "Reducción (amortización)",
    "RED_VALOR": "Reducción de VN",
    "PIGNORACION": "Pignoración",
    "EMBARGO": "Embargo",
    "CANCELA_PIGNORACION": "Cancelación de pignoración",
    "CANCELA_EMBARGO": "Cancelación de embargo",
    "LEV_GRAVAMEN": "Levantamiento de gravamen",
    "ALZAMIENTO": "Alzamiento",
    "USUFRUCTO": "Usufructo",
    "REDENOMINACION": "Redenominación",
    "SUCESION": "Sucesión",
}

def normalize_event_type(t: str | None) -> str | None:
    if not t:
        return t
    t_up = t.strip().upper()
    if t_up in EVENT_TYPE_ALIASES:
        return EVENT_TYPE_ALIASES[t_up]
    return t_up

# ===== app/core/models.py =====

#app/core/models.py

from dataclasses import dataclass
from typing import Optional

@dataclass
class Partner:
    id: int
    company_id: int
    nombre: str
    nif: str
    domicilio: Optional[str] = None
    nacionalidad: Optional[str] = None
    fecha_nacimiento_constitucion: Optional[str] = None

@dataclass
class BoardMember:
    id: int
    company_id: int
    nombre: str
    cargo: str
    nif: str
    direccion: Optional[str] = None
    telefono: Optional[str] = None
    email: Optional[str] = None

# ===== app/core/repositories/__init__.py =====



# ===== app/core/repositories/base.py =====

from typing import Iterable
def rows_to_dicts(rows: Iterable) -> list[dict]:
    return [dict(r) for r in rows]

# ===== app/core/repositories/companies_repo.py =====

# app/core/repositories/companies_repo.py
from __future__ import annotations
from typing import Optional
from ...infra.db import get_connection

def _dict_row_factory(cursor, row):
    return {cursor.description[i][0]: row[i] for i in range(len(row))}

def list_companies() -> list[dict]:
    with get_connection() as conn:
        conn.row_factory = _dict_row_factory
        cur = conn.execute("""
            SELECT id, name, cif, domicilio, fecha_constitucion
            FROM companies
            ORDER BY id
        """)
        return cur.fetchall()

def get_company(company_id: int) -> Optional[dict]:
    with get_connection() as conn:
        conn.row_factory = _dict_row_factory
        cur = conn.execute("""
            SELECT id, name, cif, domicilio, fecha_constitucion
            FROM companies
            WHERE id = ?
        """, (company_id,))
        row = cur.fetchone()
        return row if row else None

def insert_company(*, name: str, cif: str,
                   domicilio: Optional[str], fecha_constitucion: Optional[str]) -> int:
    with get_connection() as conn:
        cur = conn.execute("""
            INSERT INTO companies(name, cif, domicilio, fecha_constitucion)
            VALUES (?, ?, ?, ?)
        """, (name.strip(), cif.strip(), domicilio, fecha_constitucion))
        return cur.lastrowid

def update_company(*, id: int, name: str, cif: str,
                   domicilio: Optional[str], fecha_constitucion: Optional[str]) -> None:
    with get_connection() as conn:
        conn.execute("""
            UPDATE companies
               SET name = ?, cif = ?, domicilio = ?, fecha_constitucion = ?
             WHERE id = ?
        """, (name.strip(), cif.strip(), domicilio, fecha_constitucion, id))

def delete_company(company_id: int) -> None:
    with get_connection() as conn:
        conn.execute("DELETE FROM companies WHERE id = ?", (company_id,))

# ===== app/core/repositories/events_repo.py =====

# app/core/repositories/events_repo.py

import sqlite3
from typing import Optional
from ...infra.db import get_connection

import logging
log = logging.getLogger(__name__)

BASE_EVENT_COLS = [
    "id","company_id","correlativo","fecha","tipo",
    "socio_transmite","socio_adquiere",
    "rango_desde","rango_hasta",
    "nuevo_valor_nominal",
    "documento","observaciones",
    "hora","orden_del_dia","created_at","updated_at",
]

def _cols(conn, table: str) -> set[str]:
    cur = conn.execute(f"PRAGMA table_info({table})")
    rows = cur.fetchall()
    if not rows:
        return set()
    first = rows[0]
    if isinstance(first, dict):
        return {r.get("name") for r in rows if "name" in r}
    try:
        return {r[1] for r in rows}
    except Exception:
        try:
            return {r["name"] for r in rows}
        except Exception:
            return set()

def list_events_upto(company_id: int, fecha_max: Optional[str]) -> list[dict]:
    with get_connection() as conn:
        have = _cols(conn, "events")
        cols = [c for c in BASE_EVENT_COLS if c in have]
        where = "AND fecha<=?" if fecha_max else ""
        sql = f"SELECT {', '.join(cols)} FROM events WHERE company_id=? {where} ORDER BY fecha, id"
        conn.row_factory = sqlite3.Row
        cur = conn.execute(sql, (company_id, fecha_max) if fecha_max else (company_id,))
        rows = [dict(r) for r in cur.fetchall()]
        # normaliza claves faltantes
        out = []
        for r in rows:
            d = {k: r.get(k) for k in cols}
            for k in BASE_EVENT_COLS:
                d.setdefault(k, None)
            out.append(d)
        return out

# Compat:
def list_events(company_id: int) -> list[dict]:
    return list_events_upto(company_id, None)

def _supports_row_number(conn: sqlite3.Connection) -> bool:
    """Devuelve True si la BD soporta ROW_NUMBER() OVER ..."""
    try:
        conn.execute("DROP TABLE IF EXISTS _tmp_probe;")
        conn.execute("""
            CREATE TEMP TABLE _tmp_probe AS
            SELECT id, ROW_NUMBER() OVER (PARTITION BY company_id ORDER BY fecha, id) AS rn
            FROM events
            LIMIT 1;
        """)
        conn.execute("DROP TABLE IF EXISTS _tmp_probe;")
        return True
    except Exception:
        return False

def recompute_correlativo(company_id: Optional[int] = None) -> int:
    """
    Recalcula y persiste el correlativo por compañía en la tabla events.
    Orden fuerte: fecha ASC, (si existe) orden_del_dia ASC, (si existe) hora ASC, id ASC.
    Si 'company_id' es None, lo hace para todas.
    Devuelve el número de filas actualizadas.
    """
    updated = 0
    with get_connection() as conn:
        have = _cols(conn, "events")
        if "correlativo" not in have:
            return 0

        conn.row_factory = sqlite3.Row

        if company_id is None:
            companies = [r["id"] for r in conn.execute("SELECT id FROM companies").fetchall()]
        else:
            companies = [company_id]

        def _supports_row_number(c: sqlite3.Connection) -> bool:
            try:
                c.execute("SELECT ROW_NUMBER() OVER (ORDER BY 1) AS rn;")
                return True
            except Exception:
                return False

        # Determinar columnas opcionales para el ORDER BY
        has_od = "orden_del_dia" in have
        has_hora = "hora" in have

        if _supports_row_number(conn):
            for cid in companies:
                order = "date(fecha), "
                if has_od:
                    order += "COALESCE(orden_del_dia, 0), "
                if has_hora:
                    order += "COALESCE(hora, '00:00'), "
                order += "id"

                conn.execute(f"""
                    WITH ordered AS (
                        SELECT id,
                               ROW_NUMBER() OVER (PARTITION BY company_id ORDER BY {order}) AS rn
                        FROM events
                        WHERE company_id=?
                    )
                    UPDATE events
                       SET correlativo = (SELECT rn FROM ordered WHERE ordered.id = events.id)
                     WHERE company_id=?;
                """, (cid, cid))
                updated += conn.total_changes or 0
        else:
            for cid in companies:
                # Construir ORDER BY equivalente sin ventanas
                order_cols = ["fecha"]
                if has_od:
                    order_cols.append("orden_del_dia")
                if has_hora:
                    order_cols.append("hora")
                order_cols.append("id")
                order_sql = ", ".join(order_cols)

                ids = [r["id"] for r in conn.execute(
                    f"SELECT id FROM events WHERE company_id=? ORDER BY {order_sql}", (cid,)
                ).fetchall()]
                for i, eid in enumerate(ids, start=1):
                    conn.execute("UPDATE events SET correlativo=? WHERE id=?", (i, eid))
                    updated += 1

        # Índice útil
        conn.execute("CREATE INDEX IF NOT EXISTS idx_events_company_correlativo ON events(company_id, correlativo);")
        conn.commit()
        return updated

def ensure_redenominacion_triggers() -> None:
    """
    Replica las validaciones SQL de V1 para REDENOMINACION, nominal y partes requeridas.
    Idempotente.
    """
    sql = r"""
    -- 1) Reglas de presencia mínima (similar a V1)
    CREATE TRIGGER IF NOT EXISTS trg_events_required_parties_ins
    BEFORE INSERT ON events
    BEGIN
        -- tipos que requieren adquirente/acreedor
        SELECT CASE
          WHEN NEW.tipo IN ('ALTA','AMPL_EMISION','TRANSMISION','PIGNORACION','EMBARGO','USUFRUCTO')
           AND NEW.socio_adquiere IS NULL
          THEN RAISE(ABORT, 'Falta socio adquirente/acreedor') END;

        -- tipos que requieren transmitente/titular
        SELECT CASE
          WHEN NEW.tipo IN ('TRANSMISION','BAJA','RED_AMORT','USUFRUCTO')
           AND NEW.socio_transmite IS NULL
          THEN RAISE(ABORT, 'Falta socio transmitente/titular') END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_required_parties_upd
    BEFORE UPDATE ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('ALTA','AMPL_EMISION','TRANSMISION','PIGNORACION','EMBARGO','USUFRUCTO')
           AND NEW.socio_adquiere IS NULL
          THEN RAISE(ABORT, 'Falta socio adquirente/acreedor') END;

        SELECT CASE
          WHEN NEW.tipo IN ('TRANSMISION','BAJA','RED_AMORT','USUFRUCTO')
           AND NEW.socio_transmite IS NULL
          THEN RAISE(ABORT, 'Falta socio transmitente/titular') END;
    END;

    -- 2) Modo REDENOMINACION: o GLOBAL (sin rangos y sin socios) o POR BLOQUE (con rangos y con socio).
    CREATE TRIGGER IF NOT EXISTS trg_events_reden_mode_ins
    BEFORE INSERT ON events
    WHEN NEW.tipo='REDENOMINACION'
    BEGIN
        SELECT CASE
          WHEN
            ((NEW.rango_desde IS NULL AND NEW.rango_hasta IS NULL AND NEW.socio_transmite IS NULL AND NEW.socio_adquiere IS NULL) OR
             (NEW.rango_desde IS NOT NULL AND NEW.rango_hasta IS NOT NULL AND (NEW.socio_transmite IS NOT NULL OR NEW.socio_adquiere IS NOT NULL)))
          THEN NULL
          ELSE RAISE(ABORT, 'REDENOMINACION: usa modo global (sin rangos y sin socios) o modo por bloque (con rangos y socio).')
        END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_reden_mode_upd
    BEFORE UPDATE ON events
    WHEN NEW.tipo='REDENOMINACION'
    BEGIN
        SELECT CASE
          WHEN
            ((NEW.rango_desde IS NULL AND NEW.rango_hasta IS NULL AND NEW.socio_transmite IS NULL AND NEW.socio_adquiere IS NULL) OR
             (NEW.rango_desde IS NOT NULL AND NEW.rango_hasta IS NOT NULL AND (NEW.socio_transmite IS NOT NULL OR NEW.socio_adquiere IS NOT NULL)))
          THEN NULL
          ELSE RAISE(ABORT, 'REDENOMINACION: usa modo global (sin rangos y sin socios) o modo por bloque (con rangos y socio).')
        END;
    END;

    -- 3) Nominal obligatorio para AMPL_VALOR/RED_VALOR; en REDENOMINACION es opcional pero si se informa debe ser > 0
    CREATE TRIGGER IF NOT EXISTS trg_events_check_nominal_ins
    BEFORE INSERT ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('AMPL_VALOR','RED_VALOR')
           AND (NEW.nuevo_valor_nominal IS NULL OR NEW.nuevo_valor_nominal <= 0)
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;

        SELECT CASE
          WHEN NEW.tipo='REDENOMINACION'
           AND NEW.nuevo_valor_nominal IS NOT NULL
           AND NEW.nuevo_valor_nominal <= 0
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_check_nominal_upd
    BEFORE UPDATE ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('AMPL_VALOR','RED_VALOR')
           AND (NEW.nuevo_valor_nominal IS NULL OR NEW.nuevo_valor_nominal <= 0)
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;

        SELECT CASE
          WHEN NEW.tipo='REDENOMINACION'
           AND NEW.nuevo_valor_nominal IS NOT NULL
           AND NEW.nuevo_valor_nominal <= 0
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;
    END;
    """
    with get_connection() as conn:
        conn.executescript(sql)

# ===== app/core/repositories/governance_repo.py =====

# app/core/repositories/governance_repo.py
from __future__ import annotations
import sqlite3
from typing import Optional, List, Dict

from ...infra.db import get_connection


# ----------------------------
# Helpers internos
# ----------------------------
def _cols(conn: sqlite3.Connection, table: str) -> set[str]:
    conn.row_factory = sqlite3.Row
    rows = conn.execute(f"PRAGMA table_info({table})").fetchall()
    out = set()
    for r in rows:
        try:
            out.add(r["name"])
        except Exception:
            out.add(r[1])
    return out


def _ensure_board_no_schema(conn: sqlite3.Connection) -> None:
    """Asegura columna board_no e índices en board_members. Idempotente."""
    have = _cols(conn, "board_members")
    if "board_no" not in have:
        conn.execute("ALTER TABLE board_members ADD COLUMN board_no INTEGER;")
    conn.execute("CREATE INDEX IF NOT EXISTS ix_board_members_company ON board_members(company_id);")
    conn.execute("CREATE INDEX IF NOT EXISTS ix_board_members_company_no ON board_members(company_id, board_no);")
    # Unicidad opcional:
    # conn.execute("CREATE UNIQUE INDEX IF NOT EXISTS ux_board_members_company_no ON board_members(company_id, board_no);")


def _supports_row_number(conn: sqlite3.Connection) -> bool:
    try:
        conn.execute("SELECT ROW_NUMBER() OVER (ORDER BY 1) AS rn;")
        return True
    except Exception:
        return False


# ----------------------------
# Lectura de metadatos compañía
# ----------------------------
def get_company_governance(company_id: int) -> Dict | None:
    """
    Devuelve {'organo': str|None, 'firmantes_json': str|None} desde companies.
    Las columnas existen tras tus migraciones V0x.
    """
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT organo, firmantes_json FROM companies WHERE id=?",
            (company_id,)
        ).fetchone()
        return dict(row) if row else None


# ----------------------------
# CRUD básico de board_members
# ----------------------------
def upsert_board_member(
    *,
    id: Optional[int],
    company_id: int,
    nombre: str,
    cargo: str,
    nif: str,
    direccion: Optional[str],
    telefono: Optional[str],
    email: Optional[str],
) -> int:
    """
    Inserta/actualiza un consejero en board_members.
    Si 'id' es None o 0, inserta; si no, actualiza esa fila (scoped por company_id).
    """
    with get_connection() as conn:
        if id:
            conn.execute(
                """UPDATE board_members
                   SET nombre=?, cargo=?, nif=?, direccion=?, telefono=?, email=?
                 WHERE id=? AND company_id=?""",
                (nombre, cargo, nif, direccion, telefono, email, id, company_id)
            )
            return int(id)
        else:
            cur = conn.execute(
                """INSERT INTO board_members
                   (company_id, nombre, cargo, nif, direccion, telefono, email)
                   VALUES(?,?,?,?,?,?,?)""",
                (company_id, nombre, cargo, nif, direccion, telefono, email)
            )
            return int(cur.lastrowid)


# ----------------------------
# Listados / lectura
# ----------------------------
def list_board(company_id: int) -> List[Dict]:
    """Devuelve miembros del consejo; si existe board_no, ordena por board_no."""
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        have = _cols(conn, "board_members")
        if "board_no" in have:
            sql = """
                SELECT id, company_id, board_no, nombre, cargo, nif, direccion, telefono, email
                FROM board_members
                WHERE company_id=?
                ORDER BY CASE WHEN board_no IS NULL THEN 1 ELSE 0 END, board_no, nombre
            """
        else:
            sql = """
                SELECT id, company_id, nombre, cargo, nif, direccion, telefono, email
                FROM board_members
                WHERE company_id=?
                ORDER BY nombre
            """
        rows = conn.execute(sql, (company_id,)).fetchall()
        return [dict(r) for r in rows]


def get_member(company_id: int, member_id: int) -> Dict | None:
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        have = _cols(conn, "board_members")
        if "board_no" in have:
            sql = """
                SELECT id, company_id, board_no, nombre, cargo, nif, direccion, telefono, email
                FROM board_members WHERE company_id=? AND id=?
            """
        else:
            sql = """
                SELECT id, company_id, nombre, cargo, nif, direccion, telefono, email
                FROM board_members WHERE company_id=? AND id=?
            """
        row = conn.execute(sql, (company_id, member_id)).fetchone()
        return dict(row) if row else None


# ----------------------------
# Recompute correlativo consejo
# ----------------------------
def recompute_board_no(company_id: Optional[int] = None) -> int:
    """
    Recalcula board_no por sociedad con orden estable por id ASC.
    Si company_id es None, lo hace para todas.
    Devuelve nº de filas actualizadas aproximado.
    """
    updated = 0
    with get_connection() as conn:
        _ensure_board_no_schema(conn)
        conn.row_factory = sqlite3.Row

        if company_id is None:
            companies = [r["id"] for r in conn.execute("SELECT id FROM companies").fetchall()]
        else:
            companies = [company_id]

        if _supports_row_number(conn):
            for cid in companies:
                conn.execute("""
                    WITH ranked AS (
                        SELECT id,
                               ROW_NUMBER() OVER (PARTITION BY company_id ORDER BY id) AS rn
                        FROM board_members
                        WHERE company_id=?
                    )
                    UPDATE board_members
                       SET board_no = (SELECT rn FROM ranked WHERE ranked.id = board_members.id)
                     WHERE company_id=?;
                """, (cid, cid))
                updated += conn.total_changes or 0
        else:
            for cid in companies:
                ids = [r["id"] for r in conn.execute(
                    "SELECT id FROM board_members WHERE company_id=? ORDER BY id", (cid,)
                ).fetchall()]
                for i, mid in enumerate(ids, start=1):
                    conn.execute("UPDATE board_members SET board_no=? WHERE id=?", (i, mid))
                    updated += 1

        conn.execute("CREATE INDEX IF NOT EXISTS ix_board_members_company_no ON board_members(company_id, board_no);")
        conn.commit()
        return updated

# ===== app/core/repositories/partners_repo.py =====

# app/core/repositories/partners_repo.py

from __future__ import annotations
from typing import Optional, Iterable, Tuple
import sqlite3

from ...infra.db import get_connection
from .base import rows_to_dicts


# ----------------------------
# Helpers internos (no export)
# ----------------------------
def _cols(conn: sqlite3.Connection, table: str) -> set[str]:
    conn.row_factory = sqlite3.Row
    rows = conn.execute(f"PRAGMA table_info({table})").fetchall()
    out = set()
    for r in rows:
        try:
            out.add(r["name"])
        except Exception:
            out.add(r[1])
    return out


def _ensure_partner_no_schema(conn: sqlite3.Connection) -> None:
    """Añade columna partner_no e índices si faltan. Idempotente."""
    have = _cols(conn, "partners")
    if "partner_no" not in have:
        conn.execute("ALTER TABLE partners ADD COLUMN partner_no INTEGER;")
    # Índices (idempotentes)
    conn.execute("CREATE INDEX IF NOT EXISTS ix_partners_company ON partners(company_id);")
    conn.execute("CREATE INDEX IF NOT EXISTS ix_partners_company_partnerno ON partners(company_id, partner_no);")
    # Único opcional (comenta si prefieres evitar uniqueness estricta):
    # conn.execute("CREATE UNIQUE INDEX IF NOT EXISTS ux_partners_company_partnerno ON partners(company_id, partner_no);")


def _sqlite_supports_row_number(conn: sqlite3.Connection) -> bool:
    try:
        conn.execute("SELECT ROW_NUMBER() OVER (ORDER BY 1) AS rn;")
        return True
    except Exception:
        return False


# ---------------------------------
# API pública (usada por servicios)
# ---------------------------------
def list_by_company(company_id: int) -> list[dict]:
    """
    Devuelve los socios de la compañía.
    Si existe partner_no, ordena por partner_no NULLS LAST y devuelve la columna.
    Si no existe, ordena por nombre (comportamiento anterior).
    """
    with get_connection() as conn:
        have = _cols(conn, "partners")
        conn.row_factory = sqlite3.Row

        if "partner_no" in have:
            sql = """
                SELECT id, company_id, COALESCE(partner_no, NULL) AS partner_no,
                       nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion
                FROM partners
                WHERE company_id=?
                ORDER BY CASE WHEN partner_no IS NULL THEN 1 ELSE 0 END, partner_no, nombre
            """
        else:
            sql = """
                SELECT id, company_id,
                       nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion
                FROM partners
                WHERE company_id=? ORDER BY nombre
            """

        cur = conn.execute(sql, (company_id,))
        return [dict(r) for r in cur.fetchall()]


def upsert_partner(*, id: Optional[int], company_id: int, nombre: str, nif: str,
                   domicilio: Optional[str], nacionalidad: Optional[str],
                   fecha_nacimiento_constitucion: Optional[str]) -> int:
    with get_connection() as conn:
        if id:
            conn.execute(
                """UPDATE partners
                   SET nombre=?, nif=?, domicilio=?, nacionalidad=?, fecha_nacimiento_constitucion=?
                 WHERE id=? AND company_id=?""",
                (nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion, id, company_id)
            )
            return id
        else:
            cur = conn.execute(
                """INSERT INTO partners(company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion)
                   VALUES(?,?,?,?,?,?)""",
                (company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion)
            )
            return cur.lastrowid


def get_partner(company_id: int, partner_id: int) -> dict | None:
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        have = _cols(conn, "partners")
        if "partner_no" in have:
            sql = """
                SELECT id, company_id, partner_no, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion
                FROM partners WHERE id=? AND company_id=?
            """
        else:
            sql = """
                SELECT id, company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion
                FROM partners WHERE id=? AND company_id=?
            """
        row = conn.execute(sql, (partner_id, company_id)).fetchone()
        return dict(row) if row else None


# -------------------------------------------
# NUEVO: Recompute correlativos (partner_no)
# -------------------------------------------
def recompute_partner_no(company_id: Optional[int] = None) -> int:
    """
    Recalcula partner_no por sociedad con orden estable por id ASC.
    Si 'company_id' es None, lo hace para todas las compañías.
    Devuelve nº de filas actualizadas (estimado).
    """
    updated = 0
    with get_connection() as conn:
        _ensure_partner_no_schema(conn)
        conn.row_factory = sqlite3.Row

        if company_id is None:
            companies = [r["id"] for r in conn.execute("SELECT id FROM companies").fetchall()]
        else:
            companies = [company_id]

        if _sqlite_supports_row_number(conn):
            for cid in companies:
                # Ventanas (rápido y atómico por compañía)
                conn.execute("""
                    WITH ranked AS (
                        SELECT id,
                               ROW_NUMBER() OVER (PARTITION BY company_id ORDER BY id) AS rn
                        FROM partners
                        WHERE company_id=?
                    )
                    UPDATE partners
                       SET partner_no = (SELECT rn FROM ranked WHERE ranked.id = partners.id)
                     WHERE company_id=?;
                """, (cid, cid))
                updated += conn.total_changes or 0
        else:
            # Fallback sin ROW_NUMBER()
            for cid in companies:
                ids = [r["id"] for r in conn.execute(
                    "SELECT id FROM partners WHERE company_id=? ORDER BY id", (cid,)
                ).fetchall()]
                for i, pid in enumerate(ids, start=1):
                    conn.execute("UPDATE partners SET partner_no=? WHERE id=?", (i, pid))
                    updated += 1

        conn.commit()
        return updated

# ===== app/core/services/__init__.py =====



# ===== app/core/services/backup_service.py =====

from __future__ import annotations
from pathlib import Path
from datetime import datetime
import shutil
import logging

log = logging.getLogger(__name__)

DATA_DIR = Path(__file__).resolve().parents[3] / "data"
DB_FILE  = DATA_DIR / "libro_socios.db"
BK_DIR   = DATA_DIR / "backups"
BK_DIR.mkdir(parents=True, exist_ok=True)

def _sidecar_files(base: Path) -> list[Path]:
    # Soporta journal WAL de SQLite
    return [base.with_suffix(base.suffix + sfx) for sfx in ("-wal", "-shm")]

def create_backup() -> list[Path]:
    """
    Crea un backup consistente del fichero principal y sus sidecars si existen.
    Devuelve la lista de rutas creadas.
    """
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    created: list[Path] = []
    if not DB_FILE.exists():
        raise FileNotFoundError(f"No existe la BD: {DB_FILE}")

    dst_main = BK_DIR / f"libro_socios_{ts}.db"
    shutil.copy2(DB_FILE, dst_main)
    created.append(dst_main)

    for s in _sidecar_files(DB_FILE):
        if s.exists():
            dst = BK_DIR / f"{s.stem}_{ts}{s.suffix}".replace("-wal_", "_").replace("-shm_", "_")
            shutil.copy2(s, dst)
            created.append(dst)

    log.info("Backup creado: %s", ", ".join(str(p.name) for p in created))
    return created

def list_backups() -> list[Path]:
    # Muestra .db y posibles wal/shm asociados
    files = sorted(BK_DIR.glob("libro_socios_*.db"))
    return files

def restore_backup(backup_db_path: Path) -> list[Path]:
    """
    Restaura desde un .db de backups. Hace copia de seguridad del actual como _pre_restore_*.db
    Retorna lista de archivos restaurados.
    """
    if not backup_db_path.exists():
        raise FileNotFoundError(str(backup_db_path))

    restored: list[Path] = []

    # Copia de seguridad del actual
    safe = BK_DIR / f"_pre_restore_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
    shutil.copy2(DB_FILE, safe)
    log.warning("Backup previo (pre-restore) guardado como: %s", safe.name)

    # Restaurar principal
    shutil.copy2(backup_db_path, DB_FILE)
    restored.append(DB_FILE)

    # Limpiar/renombrar sidecars actuales si existen
    for s in _sidecar_files(DB_FILE):
        if s.exists():
            s.unlink(missing_ok=True)

    # Si existieran wal/shm con mismo timestamp, restáuralos
    stem = backup_db_path.stem.replace("libro_socios_", "")
    wal_src = BK_DIR / f"libro_socios_{stem}.db-wal"
    shm_src = BK_DIR / f"libro_socios_{stem}.db-shm"
    for src, dst in [(wal_src, DB_FILE.with_suffix(DB_FILE.suffix + "-wal")),
                     (shm_src, DB_FILE.with_suffix(DB_FILE.suffix + "-shm"))]:
        if src.exists():
            shutil.copy2(src, dst)
            restored.append(dst)

    log.warning("Restauración completada desde: %s", backup_db_path.name)
    return restored

# ===== app/core/services/companies_service.py =====

# app/core/services/companies_service.py
from __future__ import annotations
from typing import Optional
import logging
from ..repositories import companies_repo
from ..validators import normalize_nif_cif

log = logging.getLogger(__name__)

def list_companies() -> list[dict]:
    rows = companies_repo.list_companies()
    # Normaliza CIF/NIF por consistencia visual
    for r in rows:
        r["cif"] = normalize_nif_cif(r.get("cif"))
    return rows

def get_company(company_id: int) -> dict | None:
    row = companies_repo.get_company(company_id)
    if row:
        row["cif"] = normalize_nif_cif(row.get("cif"))
    return row

def save_company(*, id: Optional[int], name: str, cif: str,
                 domicilio: Optional[str], fecha_constitucion: Optional[str]) -> int:
    """
    Crea o actualiza una sociedad. Devuelve el ID.
    - fecha_constitucion en ISO 'YYYY-MM-DD' o None.
    """
    cif_norm = normalize_nif_cif(cif)
    if id:
        companies_repo.update_company(
            id=id, name=name, cif=cif_norm,
            domicilio=domicilio or None,
            fecha_constitucion=fecha_constitucion or None
        )
        log.info("Company updated id=%s name='%s' cif='%s'", id, name, cif_norm)
        return id
    else:
        new_id = companies_repo.insert_company(
            name=name, cif=cif_norm,
            domicilio=domicilio or None,
            fecha_constitucion=fecha_constitucion or None
        )
        log.info("Company created id=%s name='%s' cif='%s'", new_id, name, cif_norm)
        return new_id

def delete_company(company_id: int) -> None:
    companies_repo.delete_company(company_id)
    log.warning("Company deleted id=%s", company_id)

# ===== app/core/services/compute_service.py =====

#app/core/services/compute_service.py

from __future__ import annotations
from typing import Dict, List, Optional, Tuple
from decimal import Decimal, ROUND_FLOOR
from ..repositories import events_repo, partners_repo, companies_repo
from ..enums import normalize_event_type

# ---------- utilidades de bloques ----------
def _split_block(block: dict, d:int, h:int) -> list[dict]:
    res = []
    a, b = block['rango_desde'], block['rango_hasta']
    if d is None or h is None:
        return [block]
    if h < a or d > b:
        return [block]
    if d > a:
        res.append({**block, 'rango_desde': a, 'rango_hasta': d-1})
    if h < b:
        res.append({**block, 'rango_desde': h+1, 'rango_hasta': b})
    return res

def _len_block(b: dict) -> int:
    return (b['rango_hasta'] - b['rango_desde'] + 1)

def _consolidate(blocks: list[dict]) -> list[dict]:
    clean = [b for b in blocks if b.get('rango_desde') is not None and b.get('rango_hasta') is not None]
    if not clean:
        return []
    clean = sorted(clean, key=lambda x: (x['socio_id'], x['right_type'], x['rango_desde'], x['rango_hasta']))
    merged = [clean[0].copy()]
    merged[0]["participaciones"] = _len_block(merged[0])
    for b in clean[1:]:
        last = merged[-1]
        if (
            b['socio_id']==last['socio_id']
            and b['right_type']==last['right_type']
            and b['rango_desde']==last['rango_hasta']+1
        ):
            last['rango_hasta'] = b['rango_hasta']
            last['participaciones'] = _len_block(last)
        else:
            nb = b.copy()
            nb["participaciones"] = _len_block(nb)
            merged.append(nb)
    return merged

# ---------- motor de aplicación (port v1, con tipos normalizados) ----------
def _apply_events(events: list[dict], valor_nominal_inicial: float = 5.0, part_tot_inicial: int = 0):
    from collections import defaultdict
    from datetime import date

    blocks: list[dict] = []
    valor_nominal = valor_nominal_inicial
    total_part = part_tot_inicial
    last_fecha = str(date.today())

    # agrupar por fecha
    by_date = defaultdict(list)
    for ev in events:
        ev = ev.copy()
        ev["tipo"] = normalize_event_type(ev.get("tipo"))
        by_date[str(ev["fecha"])] .append(ev)

    for f in sorted(by_date.keys()):
        day = by_date[f]
        last_fecha = f

        def _get_range(e):
            return (e.get('rango_desde') or 0, e.get('rango_hasta') or 0)

        # 1) BAJA / RED_AMORT (quitan)
        for ev in sorted([e for e in day if e.get('tipo') in ('BAJA','RED_AMORT')], key=_get_range):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            new_blocks = []
            for b in blocks:
                if b['right_type']=='plena' and b['socio_id']==ev.get('socio_transmite'):
                    new_blocks.extend(_split_block(b, d, h))
                else:
                    new_blocks.append(b)
            blocks = _consolidate(new_blocks)

        # 2) TRANSMISION / SUCESION (mueven)
        for ev in sorted([e for e in day if e.get('tipo') in ('TRANSMISION','SUCESION')], key=_get_range):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            new_blocks = []
            for b in blocks:
                if b['right_type']=='plena' and b['socio_id']==ev.get('socio_transmite'):
                    new_blocks.extend(_split_block(b, d, h))
                else:
                    new_blocks.append(b)
            blocks = _consolidate(new_blocks)
            blocks.append(dict(socio_id=ev.get('socio_adquiere'), right_type='plena', rango_desde=d, rango_hasta=h))
            blocks = _consolidate(blocks)

        # 3) ALTA / AMPL_EMISION (añaden)
        for ev in sorted([e for e in day if e.get('tipo') in ('ALTA','AMPL_EMISION')], key=_get_range):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            blocks.append(dict(socio_id=ev.get('socio_adquiere'), right_type='plena', rango_desde=d, rango_hasta=h))
            if h:
                total_part = max(total_part, h)
            blocks = _consolidate(blocks)

        # 4) USUFRUCTO / PIGNORACION / EMBARGO y AMPL_VALOR / RED_VALOR
        for ev in [e for e in day if e.get('tipo') in ('USUFRUCTO','PIGNORACION','EMBARGO')]:
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            if ev.get('tipo') == 'USUFRUCTO':
                new_blocks = []
                for b in blocks:
                    if b['right_type']=='plena' and b['socio_id']==ev.get('socio_transmite'):
                        new_blocks.extend(_split_block(b, d, h))
                    else:
                        new_blocks.append(b)
                new_blocks.append(dict(socio_id=ev.get('socio_transmite'), right_type='nuda', rango_desde=d, rango_hasta=h))
                new_blocks.append(dict(socio_id=ev.get('socio_adquiere'),  right_type='usufructo', rango_desde=d, rango_hasta=h))
                blocks = _consolidate(new_blocks)
            else:
                holder = ev.get('socio_adquiere') or ev.get('socio_transmite')
                blocks.append(dict(socio_id=holder, right_type=('prenda' if ev.get('tipo')=='PIGNORACION' else 'embargo'),
                                   rango_desde=d, rango_hasta=h))
                blocks = _consolidate(blocks)

        for ev in [e for e in day if e.get('tipo') in ('AMPL_VALOR','RED_VALOR')]:
            nv = ev.get('nuevo_valor_nominal')
            if nv is not None:
                valor_nominal = float(nv)

        # 5) REDENOMINACION (al cierre del día)
        if any(e.get('tipo') == 'REDENOMINACION' for e in day):
            # suma por socio ('plena' vigente)
            current: Dict[int, int] = {}
            for b in blocks:
                if b['right_type'] != 'plena':
                    continue
                n = _len_block(b)
                current[b['socio_id']] = current.get(b['socio_id'], 0) + n

            old_total = sum(current.values())
            old_vn = Decimal(str(valor_nominal))
            old_capital = old_vn * Decimal(old_total)

            # VN nuevo (opcional, pero si viene debe ser único y > 0)
            vn_candidates = [e.get('nuevo_valor_nominal') for e in day if e.get('tipo') == 'REDENOMINACION' and e.get('nuevo_valor_nominal') not in (None, "")]
            new_vn = None
            if vn_candidates:
                vals = [float(v) for v in vn_candidates]
                if len({round(v, 6) for v in vals}) > 1:
                    raise ValueError(f"Valores nominales distintos en REDENOMINACION del día {f}: {vals}")
                new_vn = Decimal(str(vals[-1]))
                if new_vn <= 0:
                    raise ValueError(f"Nuevo valor nominal inválido en REDENOMINACION del día {f}: {new_vn}")

            if new_vn is None:
                new_total = old_total
            else:
                ratio = (old_capital / new_vn)
                if ratio != ratio.to_integral_value():
                    raise ValueError(f"El capital {old_capital} no es múltiplo del nuevo VN {new_vn} en REDENOMINACION del día {f}.")
                new_total = int(ratio)
                valor_nominal = float(new_vn)

            # Reasignación proporcional por restos (enteros, suma exacta)
            if old_total == 0:
                blocks = _consolidate(blocks)
                total_part = 0
            else:
                socios = sorted(current.keys())
                exact = {sid: (Decimal(current[sid]) * Decimal(str(new_total)) / Decimal(old_total)) for sid in socios}
                base  = {sid: int(exact[sid].to_integral_value(rounding=ROUND_FLOOR)) for sid in socios}
                asignadas = sum(base.values())
                resto = new_total - asignadas
                fracs = sorted([(sid, (exact[sid] - Decimal(base[sid]))) for sid in socios], key=lambda x: (x[1], -x[0]), reverse=True)
                for i in range(resto):
                    base[fracs[i][0]] += 1

                cursor = 1
                new_blocks = []
                for sid in socios:
                    n = base[sid]
                    if n <= 0:
                        continue
                    new_blocks.append(dict(socio_id=sid, right_type='plena', rango_desde=cursor, rango_hasta=cursor+n-1))
                    cursor += n
                blocks = _consolidate(new_blocks)
                total_part = new_total

        # ajuste fin día: recalcula total por bloques 'plena'
        total_part = sum(_len_block(b) for b in blocks if b['right_type'] == 'plena')

    return blocks, valor_nominal, total_part, last_fecha

# ---------- interfaz alto nivel ----------
def compute_snapshot(company_id: int, hasta_fecha: Optional[str] = None) -> dict:
    partners = {p["id"]: p for p in partners_repo.list_by_company(company_id)}
    events = events_repo.list_events_upto(company_id, hasta_fecha)
    company = companies_repo.get_company(company_id) or {}

    vn_ini = company.get("valor_nominal") or 5.0
    part_tot_ini = company.get("participaciones_totales") or 0

    blocks, valor_nominal, total_part, _ = _apply_events(events, float(vn_ini), int(part_tot_ini))

    # holdings (vigentes)
    holdings_rows = []
    for b in blocks:
        if b["right_type"] != "plena":
            continue
        pid = b["socio_id"]
        p = partners.get(pid) or {}
        holdings_rows.append({
            "partner_id": pid,
            "nombre": p.get("nombre") or f"Socio {pid}",
            "right_type": "plena",
            "rango_desde": b["rango_desde"],
            "rango_hasta": b["rango_hasta"],
            "participaciones": _len_block(b),
        })

    # agregados por socio vigente
    agreg: Dict[int, int] = {}
    for r in holdings_rows:
        agreg[r["partner_id"]] = agreg.get(r["partner_id"], 0) + int(r["participaciones"])

    socios_vigentes = []
    for pid, qty in sorted(agreg.items(), key=lambda t: (-t[1], partners.get(t[0], {}).get("nombre",""))):
        if qty <= 0: 
            continue
        p = partners.get(pid) or {}
        pct = (qty / total_part * 100.0) if total_part else 0.0
        capital_socio = float(valor_nominal) * float(qty) if valor_nominal is not None else None
        socios_vigentes.append({
            "partner_id": pid,
            "nombre": p.get("nombre"),
            "nif": p.get("nif"),
            "participaciones": qty,
            "porcentaje": round(pct, 6),
            "capital_socio": capital_socio,
        })

    # todos los socios (presentes y pasados, sin histórico de movimientos)
    todos_socios = []
    for p in partners.values():
        todos_socios.append({
            "partner_id": p["id"],
            "nombre": p.get("nombre"),
            "nif": p.get("nif"),
            "domicilio": p.get("domicilio"),
            "nacionalidad": p.get("nacionalidad"),
        })

    return {
        "socios_vigentes": socios_vigentes,
        "holdings_vigentes": holdings_rows,
        "todos_socios": sorted(todos_socios, key=lambda x: x["nombre"] or ""),
        "meta": {
            "a_fecha": hasta_fecha,
            "total_participaciones": total_part,
            "valor_nominal": valor_nominal,
            "capital_social": (float(valor_nominal) * float(total_part)) if valor_nominal is not None else None,
        },
    }

# ===== app/core/services/events_service.py =====

# app/core/services/events_service.py

from __future__ import annotations
from typing import Optional, Any
from datetime import datetime
import sqlite3

from ..repositories import events_repo, partners_repo
from ...infra.db import get_connection
from app.core.enums import normalize_event_type, EVENT_TYPES

# === Asegura triggers tipo V1 al cargar el servicio (idempotente) ===
try:
    from ..repositories.events_repo import ensure_redenominacion_triggers
    ensure_redenominacion_triggers()
except Exception:
    # No bloquear la app si falla en caliente; puedes exponer un botón de "Autochequeo" para relanzarlo.
    pass


# ---------- LISTADOS ----------

def list_events(company_id: int) -> list[dict]:
    """Listado raw (con IDs) para edición."""
    return events_repo.list_events_upto(company_id, None)


def list_events_for_ui(company_id: int) -> list[dict]:
    """Listado preparado para UI (mapea IDs de socios a nombres)."""
    rows = events_repo.list_events_upto(company_id, None)
    partners = {p["id"]: p.get("nombre") for p in partners_repo.list_by_company(company_id)}
    out = []
    for r in rows:
        out.append({
            "id": r.get("id"),
            "correlativo": r.get("correlativo"),
            "fecha": r.get("fecha"),
            "tipo": r.get("tipo"),
            "socio_transmite": partners.get(r.get("socio_transmite")) if r.get("socio_transmite") else None,
            "socio_adquiere": partners.get(r.get("socio_adquiere")) if r.get("socio_adquiere") else None,
            "rango_desde": r.get("rango_desde"),
            "rango_hasta": r.get("rango_hasta"),
            "nuevo_valor_nominal": r.get("nuevo_valor_nominal"),
            "documento": r.get("documento"),
            "observaciones": r.get("observaciones"),
        })
    return out


# ---------- CRUD ----------

_ALLOWED_FIELDS = {
    "company_id", "fecha", "tipo",
    "socio_transmite", "socio_adquiere",
    "rango_desde", "rango_hasta",
    "nuevo_valor_nominal",
    "documento", "observaciones",
    "hora", "orden_del_dia",
    # Columna física para la cantidad:
    "n_participaciones",
    # Si tu tabla tiene timestamps, puedes añadir:
    # "created_at", "updated_at",
}


def _now_iso() -> str:
    return datetime.now().isoformat(timespec="seconds")

def _require(cond: bool, msg: str, errors: list[str]):
    if not cond:
        errors.append(msg)

def _validate_range(rango_desde: Optional[int], rango_hasta: Optional[int], errors: list[str], *, required: bool = True):
    if not required and (rango_desde is None and rango_hasta is None):
        return
    _require(rango_desde is not None and rango_hasta is not None, "Debes indicar rango desde y hasta.", errors)
    if rango_desde is not None and rango_hasta is not None:
        _require(int(rango_desde) > 0 and int(rango_hasta) > 0, "El rango debe ser > 0.", errors)
        _require(int(rango_hasta) >= int(rango_desde), "El rango hasta debe ser ≥ rango desde.", errors)

def _validate_partners(st: Optional[int], sa: Optional[int], errors: list[str], *, need_st: bool, need_sa: bool, can_equal: bool = False):
    if need_st:
        _require(st is not None, "Debes indicar el socio transmite.", errors)
    if need_sa:
        _require(sa is not None, "Debes indicar el socio adquiere.", errors)
    if (st is not None) and (sa is not None) and not can_equal:
        _require(int(st) != int(sa), "Transmite y adquiere no pueden ser el mismo socio.", errors)

def _validate_nvn(nvn: Optional[float], errors: list[str], *, required: bool = False, positive: bool = True):
    if required:
        _require(nvn is not None, "Debes indicar el nuevo valor nominal.", errors)
    if nvn is not None and positive:
        _require(float(nvn) > 0.0, "El nuevo valor nominal debe ser > 0.", errors)

def _validate_event_semantics(*, tipo: str, st, sa, rd, rh, nvn, errors: list[str]) -> None:
    """Valida combinaciones básicas por tipo. Acumula mensajes en errors."""
    t = (tipo or "").upper().strip()

    # Rango consistente
    if (rd is None) ^ (rh is None):
        errors.append("Indica el rango completo RD–RH o deja ambos vacíos.")
    if rd is not None and rh is not None and int(rh) < int(rd):
        errors.append("El rango_hasta no puede ser menor que rango_desde.")

    # Reglas por tipo (simples, en línea con los formularios)
    need_rd_rh = {"TRANSMISION", "SUCESION", "USUFRUCTO", "ALTA", "AMPL_EMISION", "BAJA", "RED_AMORT",
                  "PIGNORACION", "EMBARGO", "CANCELA_PIGNORACION", "CANCELA_EMBARGO", "LEV_GRAVAMEN", "ALZAMIENTO"}
    if t in need_rd_rh and (rd is None or rh is None):
        errors.append(f"{t}: debes indicar RD–RH.")

    if t in {"TRANSMISION", "SUCESION", "USUFRUCTO"}:
        if not st: errors.append(f"{t}: falta 'socio_transmite'.")
        if not sa: errors.append(f"{t}: falta 'socio_adquiere'.")

    if t in {"ALTA", "AMPL_EMISION"}:
        if not sa: errors.append(f"{t}: falta 'socio_adquiere'.")

    if t in {"BAJA", "RED_AMORT"}:
        if not st: errors.append(f"{t}: falta 'socio_transmite'.")

    if t in {"PIGNORACION", "EMBARGO", "CANCELA_PIGNORACION", "CANCELA_EMBARGO", "LEV_GRAVAMEN", "ALZAMIENTO"}:
        if not st: errors.append(f"{t}: falta 'socio_transmite' (titular).")
        if not sa: errors.append(f"{t}: falta 'socio_adquiere' (acreedor/beneficiario).")

    if t in {"AMPL_VALOR", "RED_VALOR"}:
        if not (nvn is not None and float(nvn) > 0):
            errors.append(f"{t}: debes indicar un 'nuevo_valor_nominal' > 0.")
        if rd is not None or rh is not None:
            errors.append(f"{t}: no uses RD–RH (no aplica).")


def update_event(
    *,
    event_id: int,
    company_id: int,
    tipo: Optional[str] = None,
    fecha: Optional[str] = None,
    socio_transmite: Optional[int] = None,
    socio_adquiere: Optional[int] = None,
    rango_desde: Optional[int] = None,
    rango_hasta: Optional[int] = None,
    n_participaciones: Optional[int] = None,
    nuevo_valor_nominal: Optional[float] = None,
    documento: Optional[str] = None,
    observaciones: Optional[str] = None,
    hora: Optional[str] = None,
    orden_del_dia: Optional[int] = None,
) -> int:
    # Normalizaciones/validaciones simples
    if n_participaciones is not None:
        try:
            n_participaciones = int(n_participaciones)
        except Exception:
            raise ValueError("n_participaciones debe ser un entero.")
        if n_participaciones < 0:
            raise ValueError("n_participaciones debe ser un entero ≥ 0.")

    tipo_norm = normalize_event_type(tipo) if (tipo is not None) else None
    if tipo_norm is not None and (tipo_norm not in EVENT_TYPES and tipo_norm != "OTRO"):
        raise ValueError(f"Tipo de evento no reconocido: {tipo_norm}")

    # Validaciones semánticas (solo si nos pasan campos de negocio)
    errors: list[str] = []
    _validate_event_semantics(
        tipo=tipo_norm or (tipo if tipo is not None else ""),
        st=socio_transmite,
        sa=socio_adquiere,
        rd=rango_desde,
        rh=rango_hasta,
        nvn=nuevo_valor_nominal,
        errors=errors,
    )
    if errors:
        raise ValueError(" ".join(errors))

    # Construcción del UPDATE
    fields = {
        "tipo": tipo_norm if tipo is not None else None,
        "fecha": fecha,
        "socio_transmite": socio_transmite,
        "socio_adquiere": socio_adquiere,
        "rango_desde": rango_desde,
        "rango_hasta": rango_hasta,
        "n_participaciones": n_participaciones,
        "nuevo_valor_nominal": nuevo_valor_nominal,
        "documento": documento,
        "observaciones": observaciones,
        "hora": hora,
        "orden_del_dia": orden_del_dia,
        # "updated_at": _now_iso(),
    }
    sets, vals = [], []
    for k, v in fields.items():
        if v is not None:
            sets.append(f"{k}=?")
            vals.append(v)
    if not sets:
        return 0

    vals.extend([event_id, company_id])
    with get_connection() as conn:
        cur = conn.execute(f"UPDATE events SET {', '.join(sets)} WHERE id=? AND company_id=?", vals)
        conn.commit()
        return cur.rowcount

def create_event_generic(
    *,
    company_id: int,
    tipo: str,
    fecha: str,
    socio_transmite: Optional[int] = None,
    socio_adquiere: Optional[int] = None,
    rango_desde: Optional[int] = None,
    rango_hasta: Optional[int] = None,
    # Alias admitidos (cualquiera puede venir o ninguno):
    n_participaciones: Optional[int] = None,
    num_participaciones: Optional[int] = None,
    participaciones: Optional[int] = None,
    cantidad: Optional[int] = None,
    nuevo_valor_nominal: Optional[float] = None,
    documento: Optional[str] = None,
    observaciones: Optional[str] = None,
    **kwargs: Any,
) -> int:
    """
    Inserta un evento en la tabla 'events' aceptando alias de cantidad y normalizando a 'n_participaciones'.
    Evita depender de events_repo.create_event (no existe en V2).
    """
    # 1) Normalización de tipo/fecha
    tipo = (tipo or "").upper().strip()
    fecha = str(fecha)

    # 2) Resolver número de participaciones a partir de los alias recibidos
    canon_num = None
    for candidate in (n_participaciones, num_participaciones, participaciones, cantidad):
        if candidate is not None:
            canon_num = int(candidate)
            break

    # (Opcional) endurecer validación por tipo:
    # requires_qty = tipo in {"ALTA", "BAJA", "AMPL_EMISION", "RED_AMORT", "TRANSMISION"}
    # if requires_qty and canon_num is None:
    #     raise ValueError(f"El tipo {tipo} requiere indicar el número de participaciones.")
    # if canon_num is not None and canon_num <= 0:
    #     raise ValueError("El número de participaciones debe ser un entero positivo.")
    
    # Normalizar tipo con enums
    tipo = normalize_event_type(tipo) or tipo
    if tipo not in EVENT_TYPES and tipo != "OTRO":
        raise ValueError(f"Tipo de evento no reconocido: {tipo}")

    # Validaciones mínimas por tipo (semántica V1)
    errors: list[str] = []
    _validate_event_semantics(
        tipo=tipo,
        st=socio_transmite,
        sa=socio_adquiere,
        rd=rango_desde,
        rh=rango_hasta,
        nvn=nuevo_valor_nominal,
        errors=errors
    )
    if errors:
        # devolvemos todos los errores juntos
        raise ValueError(" · ".join(errors))

    # 3) Construir el diccionario de campos a insertar (sólo los permitidos)
    fields: dict[str, Any] = {
        "company_id": company_id,
        "tipo": tipo,
        "fecha": fecha,
        "socio_transmite": socio_transmite,
        "socio_adquiere": socio_adquiere,
        "rango_desde": rango_desde,
        "rango_hasta": rango_hasta,
        "nuevo_valor_nominal": float(nuevo_valor_nominal) if nuevo_valor_nominal is not None else None,
        "documento": documento,
        "observaciones": observaciones,
        # Si usas timestamps:
        # "created_at": _now_iso(),
        # "updated_at": _now_iso(),
    }

    # Si hay número (canon_num), lo volcamos a la columna física n_participaciones
    if canon_num is not None:
        fields["n_participaciones"] = int(canon_num)

    # 4) Filtrar sólo columnas permitidas y no-None para la INSERT
    cols = []
    vals = []
    for k, v in fields.items():
        if k in _ALLOWED_FIELDS and v is not None:
            cols.append(k)
            vals.append(v)

    if not cols:
        raise ValueError("No hay campos válidos para insertar el evento.")

    placeholders = ", ".join(["?"] * len(cols))
    colnames = ", ".join(cols)

    # 5) Ejecutar la INSERT y devolver el id
    with get_connection() as conn:
        cur = conn.execute(f"INSERT INTO events ({colnames}) VALUES ({placeholders})", vals)
        conn.commit()
        return cur.lastrowid


def get_event(company_id: int, event_id_or_corr: int) -> Optional[dict]:
    """
    Busca primero por ID; si no existe, intenta por correlativo.
    Devuelve el evento como dict o None si no lo encuentra.
    """
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row

        # 1) Buscar por ID
        row = conn.execute(
            "SELECT * FROM events WHERE company_id=? AND id=? LIMIT 1",
            (company_id, int(event_id_or_corr)),
        ).fetchone()

        # 2) Si no hay, buscar por correlativo
        if not row:
            row = conn.execute(
                "SELECT * FROM events WHERE company_id=? AND correlativo=? LIMIT 1",
                (company_id, int(event_id_or_corr)),
            ).fetchone()

    return dict(row) if row else None


def update_event(
    *,
    event_id: int,
    company_id: int,
    tipo: Optional[str] = None,
    fecha: Optional[str] = None,
    socio_transmite: Optional[int] = None,
    socio_adquiere: Optional[int] = None,
    rango_desde: Optional[int] = None,
    rango_hasta: Optional[int] = None,
    n_participaciones: Optional[int] = None,
    nuevo_valor_nominal: Optional[float] = None,
    documento: Optional[str] = None,
    observaciones: Optional[str] = None,
    hora: Optional[str] = None,
    orden_del_dia: Optional[int] = None,
) -> int:
    # (Opcional) Validación suave del número de participaciones
    if n_participaciones is not None:
        try:
            n_participaciones = int(n_participaciones)
        except Exception as _e:
            raise ValueError("n_participaciones debe ser un entero.")
        if n_participaciones < 0:
            raise ValueError("n_participaciones debe ser un entero ≥ 0.")

    fields = {
        "tipo": (tipo or "").upper().strip() if tipo is not None else None,
        "fecha": fecha,
        "socio_transmite": socio_transmite,
        "socio_adquiere": socio_adquiere,
        "rango_desde": rango_desde,
        "rango_hasta": rango_hasta,
        "n_participaciones": n_participaciones,
        "nuevo_valor_nominal": nuevo_valor_nominal,
        "documento": documento,
        "observaciones": observaciones,
        "hora": hora,
        "orden_del_dia": orden_del_dia,
        # "updated_at": _now_iso(),
    }
    sets = []
    vals = []
    for k, v in fields.items():
        if v is not None:
            sets.append(f"{k}=?")
            vals.append(v)
    if not sets:
        return 0
    vals.extend([event_id, company_id])

    with get_connection() as conn:
        cur = conn.execute(f"UPDATE events SET {', '.join(sets)} WHERE id=? AND company_id=?", vals)
        conn.commit()
        return cur.rowcount


def delete_event(*, event_id: int, company_id: int) -> int:
    with get_connection() as conn:
        cur = conn.execute("DELETE FROM events WHERE id=? AND company_id=?", (event_id, company_id))
        conn.commit()
        return cur.rowcount


# ---------- Atajos específicos de negocio (si los usas) ----------

def apply_sucesion(
    *,
    company_id: int,
    fecha: str,
    socio_causante_id: int,
    socio_heredero_id: int,
    n_participaciones: int,
    referencia: Optional[str] = None
) -> int:
    """
    Sucesión: transmisión. Si trabajas por rangos, la UI debería aportar RD–RH concretos;
    aquí dejamos None (depende de tu editor por rangos).
    """
    return create_event_generic(
        company_id=company_id,
        tipo="SUCESION",
        fecha=fecha,
        socio_transmite=socio_causante_id,
        socio_adquiere=socio_heredero_id,
        rango_desde=None,
        rango_hasta=None,
        n_participaciones=n_participaciones,
        observaciones=referencia,
    )


def apply_reduccion_amortizacion(
    *,
    company_id: int,
    fecha: str,
    modalidad: str,
    n_participaciones: int,
    referencia: Optional[str] = None,
    socio_afectado_id: Optional[int] = None
) -> int:
    """
    Reducción por amortización. Si operas por rangos, aporta RD–RH desde la UI.
    """
    return create_event_generic(
        company_id=company_id,
        tipo="RED_AMORT",
        fecha=fecha,
        socio_transmite=socio_afectado_id,
        socio_adquiere=None,
        rango_desde=None,
        rango_hasta=None,
        n_participaciones=n_participaciones,
        observaciones=referencia,
    )


# ---------- CREACIÓN ESPECÍFICA: REDENOMINACION ----------

def create_redenominacion(
    *,
    company_id: int,
    fecha: str,
    por_bloque: bool,
    socio_id: Optional[int] = None,
    rango_desde: Optional[int] = None,
    rango_hasta: Optional[int] = None,
    recalcular_numero: bool = False,
    nuevo_valor_nominal: Optional[float] = None,
    documento: Optional[str] = None,
    observaciones: Optional[str] = None,
) -> int:
    """
    Replica reglas de V1:
      - GLOBAL: sin socio/rangos. Si 'recalcular_numero' => VN obligatorio > 0 (capital debe ser múltiplo de VN).
      - POR BLOQUE: requiere socio y RD–RH; NO recalcula nº total; VN opcional (sólo constancia).
      - Validaciones legales previas (mensajes claros).
    """
    fecha = str(fecha)

    if recalcular_numero and (nuevo_valor_nominal is None or float(nuevo_valor_nominal) <= 0.0):
        raise ValueError("Para recalcular el número de participaciones debes indicar un VN > 0.")

    if por_bloque:
        if not socio_id:
            raise ValueError("En redenominación por bloque debes indicar el socio titular del bloque.")
        if not (rango_desde and rango_hasta and int(rango_hasta) >= int(rango_desde)):
            raise ValueError("En redenominación por bloque debes indicar un rango RD–RH válido.")
        if recalcular_numero:
            raise ValueError("El recálculo del número de participaciones sólo aplica en modo global.")

        socio_transmite = int(socio_id)
        socio_adquiere = None
        rd, rh = int(rango_desde), int(rango_hasta)
        nv = float(nuevo_valor_nominal) if nuevo_valor_nominal else None
    else:
        # GLOBAL: sin socios ni rangos
        socio_transmite = None
        socio_adquiere = None
        rd = rh = None
        # Sólo guardamos VN si estamos en recálculo; en constancia global VN es opcional y puede omitirse
        nv = float(nuevo_valor_nominal) if (recalcular_numero and nuevo_valor_nominal) else None

    # Inserta el evento; el compute_service aplicará la lógica y validará múltiplos/rounding como en V1.
    new_id = create_event_generic(
        company_id=company_id,
        tipo="REDENOMINACION",
        fecha=fecha,
        socio_transmite=socio_transmite,
        socio_adquiere=socio_adquiere,
        rango_desde=rd,
        rango_hasta=rh,
        # No indicamos n_participaciones en redenominación
        nuevo_valor_nominal=nv,
        documento=documento or None,
        observaciones=observaciones or None,
    )
    return new_id

# ===== app/core/services/export_service.py =====

# app/core/services/export_service.py
from __future__ import annotations

import logging
import sqlite3
from typing import Optional, List, Iterable
from io import BytesIO
from datetime import datetime
from reportlab.pdfbase import pdfmetrics

import pandas as pd
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4, landscape
from reportlab.lib.units import mm
from reportlab.lib import colors

from app.infra.pdf_fonts import register_fonts as ensure_pdf_base_fonts
from app.infra.db import get_connection
from app.core.services.reporting_service import (
    cap_table, movements, partner_position, last_entries_for_partner,
    partner_holdings_ranges, active_encumbrances, active_encumbrances_affecting_partner,
)

log = logging.getLogger(__name__)

# ============================================================
#  Constantes visuales comunes (PDF)
# ============================================================
MARGIN_X = 18 * mm
LINE_GAP = 5 * mm
SECTION_GAP = 7 * mm
CONTENT_GAP = 6 * mm


# ============================================================
#  Utilidades PDF comunes
# ============================================================
def _hr(c: canvas.Canvas, y: float, x0: float = MARGIN_X, x1: float = A4[0] - MARGIN_X):
    c.setStrokeColor(colors.lightgrey)
    c.setLineWidth(0.7)
    c.line(x0, y, x1, y)


def _kv(c: canvas.Canvas, y: float, key: str, value: str) -> float:
    c.setFont("DejaVuSans", 9.5)
    c.drawString(MARGIN_X, y, f"{key}: ")
    c.setFont("DejaVuSans-Oblique", 9.5)
    c.drawString(MARGIN_X + 70 * mm, y, value or "—")
    return y - LINE_GAP


def _col(c: canvas.Canvas, x: float, y: float, text: str, size: float = 9.0, maxw: float | None = None):
    c.setFont("DejaVuSans", size)
    t = ("" if text is None else str(text))
    if maxw is None:
        c.drawString(x, y, t)
    else:
        while c.stringWidth(t, "DejaVuSans", size) > maxw and len(t) > 3:
            t = t[:-4] + "…"
        c.drawString(x, y, t)


def _section_title(c: canvas.Canvas, title: str, y: float) -> float:
    c.setFillColorRGB(0.95, 0.95, 0.95)
    c.rect(MARGIN_X, y - 6 * mm, (A4[0] - 2 * MARGIN_X), 8 * mm, stroke=0, fill=1)
    c.setFillColor(colors.black)
    c.setFont("DejaVuSans", 10)
    c.drawString(MARGIN_X + 2 * mm, y - 4 * mm, title.upper())
    return y - SECTION_GAP - 6 * mm


def _draw_paragraph(c, text: str, x: float, y: float, max_width: float, leading: float = 12.0, font="DejaVuSans", font_size=9):
    """Dibuja un párrafo con ajuste de línea y devuelve la nueva Y."""
    if not text:
        return y
    c.setFont(font, font_size)
    space_w = pdfmetrics.stringWidth(" ", font, font_size)
    line = ""
    line_w = 0.0

    def flush(curr_line, yy):
        if curr_line:
            c.drawString(x, yy, curr_line)
            yy -= leading
        return yy

    yy = y
    for word in text.split():
        w = pdfmetrics.stringWidth(word, font, font_size)
        if line and (line_w + space_w + w) > max_width:
            yy = flush(line, yy)
            line = word
            line_w = w
        else:
            if line:
                line += " " + word
                line_w += space_w + w
            else:
                line = word
                line_w = w
    yy = flush(line, yy)
    return yy


def _ledger_use_correlativo(df: pd.DataFrame) -> pd.DataFrame:
    """Si existe 'correlativo', lo coloca como primera columna visible y oculta 'id'."""
    d = df.copy()
    if "correlativo" in d.columns:
        d.rename(columns={"correlativo": "Nº asiento"}, inplace=True)
        first = ["Nº asiento"]
        rest = [c for c in d.columns if c not in ("id", "Nº asiento", "correlativo")]
        d = d[first + rest]
    if "id" in d.columns:
        d.drop(columns=["id"], inplace=True)
    return d


# ============================================================
#  Lookups / cabeceras reales
# ============================================================
def _partners_lookup(company_id: int) -> dict[int, dict]:
    """id -> {'nombre','nif','nacionalidad','domicilio','partner_no'(opcional)}"""
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        cols = {row[1] for row in conn.execute("PRAGMA table_info(partners)").fetchall()}
        if "partner_no" in cols:
            rows = conn.execute(
                "SELECT id, nombre, nif, nacionalidad, domicilio, partner_no "
                "FROM partners WHERE company_id=? ORDER BY id",
                (company_id,)
            ).fetchall()
        else:
            rows = conn.execute(
                "SELECT id, nombre, nif, nacionalidad, domicilio "
                "FROM partners WHERE company_id=? ORDER BY id",
                (company_id,)
            ).fetchall()

    out: dict[int, dict] = {}
    for r in rows:
        out[int(r["id"])] = {
            "nombre": r["nombre"] or "",
            "nif": r["nif"] or "",
            "nacionalidad": r["nacionalidad"] or "",
            "domicilio": r["domicilio"] or "",
            "partner_no": (r["partner_no"] if ("partner_no" in r.keys()) else None),
        }
    return out


def _partner_no_map(company_id: int) -> dict[int, int | None]:
    """Devuelve {partner_id -> partner_no} si la columna existe; si no, dict vacío."""
    with get_connection() as conn:
        have = {row[1] for row in conn.execute("PRAGMA table_info(partners)").fetchall()}
        if "partner_no" not in have:
            return {}
        rows = conn.execute(
            "SELECT id, partner_no FROM partners WHERE company_id=?",
            (company_id,)
        ).fetchall()
        return {int(r[0]): (None if r[1] is None else int(r[1])) for r in rows}


def _company_header(company_id: int) -> dict:
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT name, cif, domicilio, fecha_constitucion FROM companies WHERE id=?",
            (company_id,)
        ).fetchone()
    if not row:
        return {"name": "", "cif": "", "domicilio": "", "fecha_constitucion": ""}
    return {
        "name": row["name"] or "",
        "cif": row["cif"] or "",
        "domicilio": row["domicilio"] or "",
        "fecha_constitucion": str(row["fecha_constitucion"] or "") or "",
    }


def _partner_id_by_nif_or_name(company_id: int, nombre: str | None, nif: str | None) -> int | None:
    if not nombre and not nif:
        return None
    with get_connection() as conn:
        if nif:
            r = conn.execute(
                "SELECT id FROM partners WHERE company_id=? AND nif=? LIMIT 1",
                (company_id, nif)
            ).fetchone()
            if r:
                return int(r[0])
        if nombre:
            r = conn.execute(
                "SELECT id FROM partners WHERE company_id=? AND nombre=? LIMIT 1",
                (company_id, nombre)
            ).fetchone()
            if r:
                return int(r[0])
    return None


# ============================================================
#  Construcción de filas del LIBRO (usando columnas reales)
# ============================================================
def _ledger_rows(company_id: int,
                 date_from: str | None,
                 date_to: str | None,
                 event_types: list[str] | None) -> pd.DataFrame:
    """
    DataFrame con: fecha, correlativo, tipo, documento, socio_transmite/adquiere,
    rango_desde/hasta, participaciones (derivadas), nuevo_valor_nominal, observaciones.
    """
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        sql = """
        SELECT id, correlativo, fecha, tipo,
               socio_transmite, socio_adquiere,
               rango_desde, rango_hasta,
               nuevo_valor_nominal,
               documento, observaciones
        FROM events
        WHERE company_id=?
        """
        params: list = [company_id]
        if date_from:
            sql += " AND fecha>=?"
            params.append(date_from)
        if date_to:
            sql += " AND fecha<=?"
            params.append(date_to)
        if event_types:
            sql += f" AND tipo IN ({','.join(['?']*len(event_types))})"
            params.extend(event_types)
        sql += " ORDER BY fecha, id"

        rows = conn.execute(sql, params).fetchall()

    pmap = _partners_lookup(company_id)
    out = []
    for r in rows:
        st_id = r["socio_transmite"]
        sa_id = r["socio_adquiere"]
        rd = r["rango_desde"]
        rh = r["rango_hasta"]

        # nº participaciones como (hasta - desde + 1) cuando haya rangos
        n_parts = None
        if rd is not None and rh is not None:
            try:
                n_parts = int(rh) - int(rd) + 1
            except Exception:
                n_parts = None

        out.append({
            "correlativo": r["correlativo"],
            "fecha": r["fecha"],
            "tipo": r["tipo"],
            "documento": r["documento"] or "",
            "socio_transmite_id": st_id,
            "socio_transmite_nombre": pmap.get(int(st_id), {}).get("nombre", "") if st_id else "",
            "socio_transmite_nif":    pmap.get(int(st_id), {}).get("nif", "")    if st_id else "",
            "socio_adquiere_id": sa_id,
            "socio_adquiere_nombre": pmap.get(int(sa_id), {}).get("nombre", "") if sa_id else "",
            "socio_adquiere_nif":    pmap.get(int(sa_id), {}).get("nif", "")    if sa_id else "",
            "rango_desde": rd,
            "rango_hasta": rh,
            "participaciones": n_parts,
            "nuevo_valor_nominal": r["nuevo_valor_nominal"],
            "observaciones": r["observaciones"] or "",
        })
    return pd.DataFrame(out)


# ============================================================
#  EXCEL: Cap table & Movimientos
# ============================================================
def export_cap_table_excel(company_id: int, as_of: str | None = None) -> BytesIO:
    """
    Genera un Excel con la cap table a fecha, añadiendo 'Nº socio' si partners.partner_no existe.
    """
    try:
        df = cap_table(company_id, as_of).copy()
        # Añadir "Nº socio" si podemos
        pno = _partner_no_map(company_id)
        if pno and ("partner_id" in df.columns):
            df.insert(0, "Nº socio", df["partner_id"].map(pno))
        elif "partner_no" in df.columns:
            df.insert(0, "Nº socio", df["partner_no"])
        # Escribir Excel
        output = BytesIO()
        with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
            df.to_excel(writer, index=False, sheet_name="CapTable")
            wb = writer.book
            ws = writer.sheets["CapTable"]
            fmt_int = wb.add_format({"num_format": "#,##0"})
            fmt_pct = wb.add_format({"num_format": "0.0000"})
            # Ajuste columnas
            for i, col in enumerate(df.columns):
                try:
                    width = max(12, min(40, int(df[col].astype(str).str.len().quantile(0.9)) + 2))
                except Exception:
                    width = 16
                ws.set_column(i, i, width)
            # Formatos
            if "shares" in df.columns:
                col_idx = df.columns.get_loc("shares")
                ws.set_column(col_idx, col_idx, 14, fmt_int)
            if "pct" in df.columns:
                col_idx = df.columns.get_loc("pct")
                ws.set_column(col_idx, col_idx, 10, fmt_pct)
        output.seek(0)
        log.info("Export CapTable.xlsx company_id=%s as_of=%s rows=%s",
                 company_id, as_of, len(df))
        return output
    except Exception as e:
        log.error("Error exportando CapTable.xlsx company_id=%s as_of=%s: %s",
                  company_id, as_of, e, exc_info=True)
        raise


def export_movements_excel(company_id: int,
                           date_from: Optional[str],
                           date_to: Optional[str],
                           event_types: Optional[List[str]]) -> BytesIO:
    """
    Genera un Excel con los movimientos filtrados.
    Si viene 'correlativo', lo muestra como 'Nº asiento' y oculta 'id'.
    """
    try:
        df = movements(company_id, date_from, date_to, event_types).copy()
        # Normalizar correlativo
        if "correlativo" in df.columns:
            df.rename(columns={"correlativo": "Nº asiento"}, inplace=True)
            first = ["Nº asiento"]
            rest = [c for c in df.columns if c not in ("id", "Nº asiento", "correlativo")]
            df = df[first + rest]
        if "id" in df.columns:
            df.drop(columns=["id"], inplace=True)

        output = BytesIO()
        with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
            df.to_excel(writer, index=False, sheet_name="Movimientos")
            wb = writer.book
            ws = writer.sheets["Movimientos"]
            fmt_int = wb.add_format({"num_format": "#,##0"})
            # Auto ancho básico
            for i, col in enumerate(df.columns):
                try:
                    width = max(12, min(40, int(df[col].astype(str).str.len().quantile(0.9)) + 2))
                except Exception:
                    width = 16
                ws.set_column(i, i, width)
            # Campo de cantidad si existe
            for qty_col in ("shares_delta", "participaciones", "n_participaciones"):
                if qty_col in df.columns:
                    idx = df.columns.get_loc(qty_col)
                    ws.set_column(idx, idx, 14, fmt_int)
                    break
        output.seek(0)
        log.info("Export Movimientos.xlsx company_id=%s from=%s to=%s types=%s rows=%s",
                 company_id, date_from, date_to,
                 ",".join(event_types) if event_types else "", len(df))
        return output
    except Exception as e:
        log.error("Error exportando Movimientos.xlsx company_id=%s: %s",
                  company_id, e, exc_info=True)
        raise


# ============================================================
#  EXCEL: Libro legalizable
# ============================================================
def export_ledger_excel_legalizable(
    company_id: int,
    date_from: Optional[str],
    date_to: Optional[str],
    event_types: Optional[List[str]],
    diligencia_apertura: Optional[str] = None,
    diligencia_cierre: Optional[str] = None,
    as_of: Optional[str] = None,
) -> BytesIO:
    """
    Libro Registro – Excel legalizable.
    Pestañas:
      - Resumen
      - Socios a fecha (con Nº socio)
      - Cap table a fecha (con Nº socio)
      - Rangos a fecha (con Nº socio)
      - Gravámenes a fecha
      - Movimientos del período (con Nº asiento si existe)
    """
    try:
        as_of_final = as_of or date_to or datetime.now().strftime("%Y-%m-%d")
        pmap   = _partners_lookup(company_id)
        pno    = _partner_no_map(company_id)

        # --- Cap table / socios vigentes a fecha ---
        df_cap = _vigentes_cap_table(company_id, as_of_final)
        vigentes_ids = _vigentes_ids_from_cap(df_cap, company_id)

        # -- Socios a fecha (usar partner_no si existe; fallback al id)
        socios_rows = []
        for pid in vigentes_ids:
            info = pmap.get(int(pid), {})
            numero = pmap.get(int(pid), {}).get("partner_no")
            socios_rows.append({
                "Nº socio": int(numero) if numero is not None else int(pid),
                "Nombre / Razón social": info.get("nombre", ""),
                "NIF/CIF": info.get("nif", ""),
                "Nacionalidad": info.get("nacionalidad", ""),
                "Domicilio": info.get("domicilio", ""),
            })
        df_socios = pd.DataFrame(socios_rows)

        # -- Cap table a fecha (añadir Nº socio)
        df_cap_x = df_cap.copy()
        # asegurar partner_id para mapear
        if "partner_id" not in df_cap_x.columns:
            df_cap_x["partner_id"] = None
        for i, r in df_cap_x.iterrows():
            pid = r.get("partner_id")
            if pd.isna(pid) or pid is None:
                pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
            df_cap_x.at[i, "partner_id"] = None if pid is None else int(pid)

        df_cap_x.insert(0, "Nº socio",
                        df_cap_x["partner_id"].map(pno) if pno else df_cap_x["partner_id"])
        df_cap_x.rename(columns={
            "partner_name": "Socio",
            "nif": "NIF/CIF",
            "shares": "Participaciones",
            "pct": "% (0–100)",
            "capital_socio": "Capital del socio (€)",
        }, inplace=True)
        cols_cap = ["Nº socio", "Socio", "NIF/CIF", "Participaciones", "% (0–100)", "Capital del socio (€)"]
        df_cap_x = df_cap_x[[c for c in cols_cap if c in df_cap_x.columns]]

        # -- Rangos vigentes por socio a fecha (con Nº socio)
        rows_ranges = []
        for _, r in df_cap.iterrows():
            pid = r.get("partner_id")
            if pd.isna(pid) or pid is None:
                pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
            if pid is None:
                continue
            rng = partner_holdings_ranges(company_id, int(pid), as_of_final)
            if rng is None or rng.empty:
                continue
            numero = pmap.get(int(pid), {}).get("partner_no")
            for _, rr in rng.iterrows():
                rows_ranges.append({
                    "Nº socio": int(numero) if numero is not None else int(pid),
                    "Socio": r.get("partner_name",""),
                    "NIF/CIF": r.get("nif",""),
                    "Desde": rr.get("rango_desde"),
                    "Hasta": rr.get("rango_hasta"),
                    "Participaciones": rr.get("participaciones"),
                })
        df_rng = pd.DataFrame(rows_ranges)

        # -- Gravámenes a fecha (igual que PDF)
        df_grav = _encumbrances_all(company_id, as_of_final, vigentes_ids, pmap).copy()

        def _pick(row: dict, *keys: str) -> str:
            for k in keys:
                val = row.get(k)
                if val is not None and str(val).strip() != "":
                    return str(val).strip()
            return ""

        def _tipo_txt(row: dict) -> str:
            raw = _pick(row, "tipo_evento", "tipo_origen", "tipo_base", "tipo", "subtipo", "evento_tipo").upper()
            if "PIGNOR" in raw: return "Pignoración"
            if "EMBARGO" in raw: return "Embargo"
            return (raw.title() if raw else "—")

        def _afavor_txt(row: dict) -> str:
            nom = _pick(row, "a_favor_de", "acreedor_nombre", "beneficiario_nombre", "tercero_nombre", "acreedor", "beneficiario")
            nif = _pick(row, "acreedor_nif", "beneficiario_nif", "tercero_nif")
            if nom and nif: return f"{nom} ({nif})"
            return nom or nif or ""

        if df_grav is None or df_grav.empty:
            df_grav_x = pd.DataFrame(columns=["Fecha","Socio titular","Tipo","A favor de","Desde","Hasta"])
        else:
            df_grav_x = df_grav.copy()
            df_grav_x["Tipo (normalizado)"] = df_grav_x.apply(lambda r: _tipo_txt(r.to_dict()), axis=1)
            df_grav_x["A favor de"]         = df_grav_x.apply(lambda r: _afavor_txt(r.to_dict()), axis=1)
            cols_g = ["fecha","socio_titular","Tipo (normalizado)","A favor de","rango_desde","rango_hasta","tipo"]
            df_grav_x = df_grav_x[[c for c in cols_g if c in df_grav_x.columns]].rename(columns={
                "fecha":"Fecha","socio_titular":"Socio titular","rango_desde":"Desde","rango_hasta":"Hasta","tipo":"Tipo (original)"
            })

        # -- Movimientos del período (con correlativo si existe)
        df_mov = _ledger_rows(company_id, date_from, date_to, event_types)
        vn_steps = _nominal_timeline(company_id)

        def _vn_row(r):
            try:
                nv = r.get("nuevo_valor_nominal")
                if pd.notna(nv) and float(nv or 0) > 0:
                    return float(nv)
            except Exception:
                pass
            return _vn_on_date(vn_steps, str(r.get("fecha") or ""))

        TYPE_SHORT = {
            "ALTA": "ALTA",
            "TRANSMISION": "TRANS",
            "AMPL_EMISION": "AMPL_EMI",
            "AMPL_VALOR": "AMPL_VAL",
            "REDENOMINACION": "REDENOM",
            "PIGNORACION": "PIGNOR",
            "CANCELA_PIGNORACION": "CANC_PIG",
        }
        def _short(t):
            t0 = (str(t) or "").upper().strip()
            return TYPE_SHORT.get(t0, (t0[:10] if t0 else ""))

        if df_mov is None or df_mov.empty:
            df_mov_x = pd.DataFrame(columns=[
                "correlativo","fecha","tipo","tipo_corto",
                "socio_transmite_nombre","socio_transmite_nif",
                "socio_adquiere_nombre","socio_adquiere_nif",
                "rango_desde","rango_hasta","participaciones","nuevo_valor_nominal","vn_vigente"
            ])
        else:
            df_mov_x = df_mov.copy()
            df_mov_x["tipo_corto"] = df_mov_x["tipo"].map(_short)
            df_mov_x["vn_vigente"] = df_mov_x.apply(_vn_row, axis=1)
            # Normalizar correlativo como "Nº asiento"
            df_mov_x = _ledger_use_correlativo(df_mov_x)

        # --------- Escribir Excel ----------
        output = BytesIO()
        with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
            # Resumen
            meta = {
                "Sociedad": _company_header(company_id).get("name",""),
                "A fecha": as_of_final,
                "Periodo (desde)": date_from or "inicio",
                "Periodo (hasta)": date_to or "hoy",
                "Tipos de evento (filtro)": ", ".join(event_types or []) or "—",
                "Diligencia apertura": diligencia_apertura or "—",
                "Diligencia cierre": diligencia_cierre or "—",
            }
            df_meta = pd.DataFrame(list(meta.items()), columns=["Campo","Valor"])
            df_meta.to_excel(writer, index=False, sheet_name="Resumen")

            # Socios
            df_socios.to_excel(writer, index=False, sheet_name="Socios a fecha")
            # Cap table
            df_cap_x.to_excel(writer, index=False, sheet_name="Cap table a fecha")
            # Rangos
            df_rng.to_excel(writer, index=False, sheet_name="Rangos a fecha")
            # Gravámenes
            df_grav_x.to_excel(writer, index=False, sheet_name="Gravámenes a fecha")
            # Movimientos
            df_mov_x.to_excel(writer, index=False, sheet_name="Movimientos")

            # Formatos y auto-ancho
            wb = writer.book
            fmt_int = wb.add_format({"num_format": "#,##0"})
            fmt_pct = wb.add_format({"num_format": "0.0000"})
            fmt_money = wb.add_format({"num_format": "#,##0.00"})

            def _autowidth(ws_name: str, df_: pd.DataFrame):
                ws = writer.sheets[ws_name]
                for i, col in enumerate(df_.columns):
                    try:
                        max_len = int(df_[col].astype(str).str.len().quantile(0.9))
                    except Exception:
                        max_len = 16
                    width = max(12, min(50, max_len + 2))
                    ws.set_column(i, i, width)
                return ws

            _autowidth("Resumen", df_meta)
            _autowidth("Socios a fecha", df_socios)
            ws_cap = _autowidth("Cap table a fecha", df_cap_x)
            if "Participaciones" in df_cap_x.columns:
                idx = df_cap_x.columns.get_loc("Participaciones")
                ws_cap.set_column(idx, idx, 14, fmt_int)
            if "% (0–100)" in df_cap_x.columns:
                idx = df_cap_x.columns.get_loc("% (0–100)")
                ws_cap.set_column(idx, idx, 12, fmt_pct)
            if "Capital del socio (€)" in df_cap_x.columns:
                idx = df_cap_x.columns.get_loc("Capital del socio (€)")
                ws_cap.set_column(idx, idx, 16, fmt_money)

            _autowidth("Rangos a fecha", df_rng)
            _autowidth("Gravámenes a fecha", df_grav_x)
            ws_mov = _autowidth("Movimientos", df_mov_x)
            for qty_col in ("participaciones", "shares_delta", "n_participaciones"):
                if qty_col in df_mov_x.columns:
                    idx = df_mov_x.columns.get_loc(qty_col)
                    ws_mov.set_column(idx, idx, 14, fmt_int)
                    break
            if "vn_vigente" in df_mov_x.columns:
                idx = df_mov_x.columns.get_loc("vn_vigente")
                ws_mov.set_column(idx, idx, 12, fmt_money)

        output.seek(0)
        log.info(
            "Export LibroRegistro.xlsx company_id=%s as_of=%s from=%s to=%s types=%s",
            company_id, as_of_final, date_from, date_to, ",".join(event_types or [])
        )
        return output

    except Exception as e:
        log.error("Error exportando LibroRegistro.xlsx company_id=%s: %s", company_id, e, exc_info=True)
        raise


# ============================================================
#  PDF: Certificado de titularidad (socio)
# ============================================================
def export_partner_certificate_pdf(company_id: int, partner_id: int, as_of: Optional[str] = None) -> BytesIO:
    try:
        ensure_pdf_base_fonts()
        ref_date = as_of or datetime.now().strftime("%Y-%m-%d")

        data    = partner_position(company_id, partner_id, ref_date)
        rangos  = partner_holdings_ranges(company_id, partner_id, ref_date)
        enc     = active_encumbrances_affecting_partner(company_id, partner_id, ref_date)
        _ = last_entries_for_partner(company_id, partner_id, limit=10, as_of=ref_date)  # no usado, pero conservamos la llamada

        # Orden estable para la tabla
        if enc is not None and not enc.empty:
            enc = enc.sort_values(by=["fecha", "rango_desde", "rango_hasta"], na_position="last").reset_index(drop=True)

        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        W, H = A4
        y = H - 20 * mm
        content_width = W - 2 * MARGIN_X  # ancho útil entre márgenes

        # ---------------- Cabecera ----------------
        comp_corte = datetime.strptime(ref_date, "%Y-%m-%d").strftime("%d/%m/%Y")

        c.setTitle("Certificado de titularidad")
        c.setFont("DejaVuSans", 14)
        c.drawString(MARGIN_X, y, "Certificado de titularidad"); y -= 6 * mm

        c.setFont("DejaVuSans", 9)
        c.drawString(MARGIN_X, y, f"A fecha de certificación: {comp_corte}")
        y -= 8 * mm

        _hr(c, y); y -= SECTION_GAP

        # ---------------- Resumen del socio ----------------
        y = _section_title(c, "Resumen del socio", y)
        y = _kv(c, y, "Socio", data.get("partner_name", ""))
        y = _kv(c, y, "NIF", data.get("nif", "") or "—")
        y = _kv(c, y, "Participaciones", f"{int(data.get('shares', 0)):,}".replace(",", "."))
        y = _kv(c, y, "Porcentaje", f"{float(data.get('pct', 0.0)):.4f} %")
        y = _kv(c, y, "Clases/Series", data.get("classes") or "—")
        y -= 2 * mm

        # ---------------- Detalle de participaciones ----------------
        y = _section_title(c, "Detalle de participaciones a la fecha", y)
        c.setFont("DejaVuSans", 9.5)
        _col(c, MARGIN_X, y, "Desde")
        _col(c, MARGIN_X + 35 * mm, y, "Hasta")
        _col(c, MARGIN_X + 70 * mm, y, "Participaciones")
        y -= 4 * mm
        _hr(c, y); y -= 3 * mm
        c.setFont("DejaVuSans", 9)

        total_bloques = 0
        if rangos is None or rangos.empty:
            _col(c, MARGIN_X, y, "(Sin bloques vigentes)"); y -= CONTENT_GAP
        else:
            for _, r in rangos.iterrows():
                rd = r.get("rango_desde"); rh = r.get("rango_hasta"); part = int(r.get("participaciones") or 0)
                total_bloques += part
                _col(c, MARGIN_X, y, "" if pd.isna(rd) else str(int(rd)))
                _col(c, MARGIN_X + 35 * mm, y, "" if pd.isna(rh) else str(int(rh)))
                _col(c, MARGIN_X + 70 * mm, y, f"{part:,}".replace(",", "."))
                y -= CONTENT_GAP
                if y < 30 * mm:
                    c.showPage(); y = H - 20 * mm

        c.setFont("DejaVuSans-Oblique", 9)
        check = f"Suma de bloques: {total_bloques:,}".replace(",", ".") + \
                f"   •   Total socio: {int(data.get('shares', 0)):,}".replace(",", ".")
        _col(c, MARGIN_X, y, check); y -= CONTENT_GAP

        # ---------------- Gravámenes a la fecha ----------------
        y = _section_title(c, "Gravámenes a la fecha (pignoraciones/embargos)", y)

        c.setFont("DejaVuSans", 9)
        if enc is None or enc.empty:
            para = (
                "A la fecha de esta certificación no constan gravámenes vigentes "
                "(pignoraciones ni embargos) sobre las participaciones titularidad del socio, "
                "según el Libro Registro."
            )
            y = _draw_paragraph(c, para, MARGIN_X, y, content_width, leading=12.0)
            y -= 2 * mm
        else:
            para = (
                "A la fecha de esta certificación, constan sobre las participaciones titularidad "
                "del socio uno o varios gravámenes (pignoraciones y/o embargos) vigentes conforme a los "
                "asientos del Libro Registro, según se detalla en la tabla a continuación:"
            )
            y = _draw_paragraph(c, para, MARGIN_X, y, content_width, leading=12.0)
            y -= 2 * mm

            # Posiciones de columnas
            x_fecha = MARGIN_X
            x_tipo  = MARGIN_X + 28 * mm
            x_afav  = MARGIN_X + 60 * mm
            x_desde = MARGIN_X + 135 * mm
            x_hasta = MARGIN_X + 155 * mm

            def draw_enc_header(y0: float) -> float:
                c.setFont("DejaVuSans", 9.5)
                _col(c, x_fecha, y0, "Fecha")
                _col(c, x_tipo,  y0, "Tipo")
                _col(c, x_afav,  y0, "A favor de")
                _col(c, x_desde, y0, "Desde")
                _col(c, x_hasta, y0, "Hasta")
                y1 = y0 - 4 * mm
                _hr(c, y1)
                c.setFont("DejaVuSans", 9)
                return y1 - 3 * mm

            y = draw_enc_header(y)

            # Filas de la tabla de gravámenes
            for _, r in enc.iterrows():
                fecha = str(r.get("fecha") or "")
                tipo  = str(r.get("tipo") or "")
                nom   = (r.get("acreedor_nombre") or "").strip()
                nif   = (r.get("acreedor_nif") or "").strip()
                acre  = f"{nom} ({nif})" if nif else nom

                rd    = r.get("rango_desde"); rh = r.get("rango_hasta")
                d_txt = "" if pd.isna(rd) else str(int(rd))
                h_txt = "" if pd.isna(rh) else str(int(rh))

                _col(c, x_fecha, y, fecha)
                _col(c, x_tipo,  y, tipo)
                _col(c, x_afav,  y, acre, maxw=(x_desde - x_afav - 3 * mm))
                _col(c, x_desde, y, d_txt)
                _col(c, x_hasta, y, h_txt)
                y -= CONTENT_GAP

                if y < 30 * mm:
                    c.showPage(); y = H - 20 * mm
                    y = _section_title(c, "Gravámenes a la fecha (pignoraciones/embargos)", y)
                    y = _draw_paragraph(c, para, MARGIN_X, y, content_width, leading=12.0)
                    y -= 2 * mm
                    y = draw_enc_header(y)

        # Cierre
        c.showPage()
        c.save()
        buffer.seek(0)

        log.info("Export Certificado.pdf company_id=%s partner_id=%s as_of=%s partner='%s' shares=%s",
                 company_id, partner_id, as_of, data.get("partner_name", ""),
                 int(data.get("shares", 0)))

        return buffer

    except Exception as e:
        log.error("Error exportando Certificado.pdf company_id=%s partner_id=%s as_of=%s: %s",
                  company_id, partner_id, as_of, e, exc_info=True)
        raise


# ============================================================
#  LIBRO REGISTRO – LEGALIZABLE (PDF & Excel)
# ============================================================
def _nominal_timeline(company_id: int) -> list[tuple[str, float]]:
    """
    [(fecha ISO, nuevo_valor_nominal>0)] de events.nuevo_valor_nominal para saber VN vigente.
    """
    with get_connection() as conn:
        df = pd.read_sql_query(
            """
            SELECT fecha, nuevo_valor_nominal
            FROM events
            WHERE company_id=?
              AND nuevo_valor_nominal IS NOT NULL
              AND nuevo_valor_nominal > 0
            ORDER BY fecha, id
            """,
            conn, params=(company_id,)
        )
    if df.empty:
        return []
    out: list[tuple[str, float]] = []
    for _, r in df.iterrows():
        out.append((str(r["fecha"]), float(r["nuevo_valor_nominal"])))
    return out


def _vn_on_date(vn_steps: list[tuple[str, float]], fecha_iso: str) -> float | None:
    """Devuelve VN vigente a una fecha (lista ordenada ascendente)."""
    if not vn_steps:
        return None
    last = None
    for f, vn in vn_steps:
        if f <= fecha_iso:
            last = vn
        else:
            break
    return last


def _normalize_pct(p):
    try:
        v = float(p)
    except Exception:
        return None
    # En tu cap_table ya viene 0..100; si viniera 0..1, normalizamos.
    return v * 100.0 if v <= 1.000001 else v


def _vigentes_cap_table(company_id: int, as_of: str) -> pd.DataFrame:
    df = cap_table(company_id, as_of).copy()
    if df is None or df.empty:
        return pd.DataFrame(columns=["partner_id", "partner_name", "nif", "shares", "pct", "capital_socio"])
    if "pct" in df.columns:
        df["pct"] = df["pct"].map(_normalize_pct)
    # Filtra solo socios con saldo
    if "shares" in df.columns:
        df = df[df["shares"].fillna(0) > 0]
    # Asegura columnas esperadas
    for col in ("partner_id", "partner_name", "nif", "shares", "pct"):
        if col not in df.columns:
            df[col] = None
    if "capital_socio" not in df.columns:
        # si no viene, intenta derivarlo con VN vigente (opcional)
        vn = _vn_on_date(_nominal_timeline(company_id), as_of) or 0.0
        try:
            df["capital_socio"] = (df["shares"].fillna(0).astype(float) * float(vn)).round(2)
        except Exception:
            df["capital_socio"] = None
    return df


def _vigentes_ids_from_cap(df_cap: pd.DataFrame, company_id: int) -> list[int]:
    ids: list[int] = []
    for _, r in df_cap.iterrows():
        pid = r.get("partner_id")
        if pd.isna(pid) or pid is None:
            pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
        if pid is not None:
            ids.append(int(pid))
    # únicos y ordenados
    return sorted(list(dict.fromkeys(ids)))


def _encumbrances_all(company_id: int, as_of: str, ids: Iterable[int], pmap: dict[int, dict]) -> pd.DataFrame:
    """
    Devuelve un DF unificado con columnas al menos:
    ['fecha','socio_titular','tipo','a_favor_de','rango_desde','rango_hasta', (extras de tipo...)]
    Usamos active_encumbrances_affecting_partner para traer también beneficiario/subtipo.
    """
    def _pick(row: pd.Series, *keys: str) -> str:
        for k in keys:
            if k in row and pd.notna(row[k]):
                v = str(row[k]).strip()
                if v:
                    return v
        return ""

    def _compose_benef_row(r: pd.Series) -> str:
        # 1) claves “canónicas”
        nom = _pick(r, "a_favor_de", "acreedor_nombre", "beneficiario_nombre", "tercero_nombre", "acreedor", "beneficiario")
        nif = _pick(r, "acreedor_nif", "beneficiario_nif", "tercero_nif")
        if nom or nif:
            return f"{nom} ({nif})" if (nom and nif) else (nom or nif or "")

        # 2) sniff: busca columnas que contengan palabras clave
        cols = {c.lower(): c for c in r.index}
        # nombre
        name_col = next((cols[c] for c in cols if any(k in c for k in ("acreedor", "benef", "tercero")) and "nif" not in c), None)
        # nif
        nif_col  = next((cols[c] for c in cols if "nif" in c and any(k in c for k in ("acreedor", "benef", "tercero"))), None)
        nom2 = str(r[name_col]).strip() if name_col and pd.notna(r.get(name_col)) else ""
        nif2 = str(r[nif_col]).strip()  if nif_col and pd.notna(r.get(nif_col))  else ""
        if nom2 or nif2:
            return f"{nom2} ({nif2})" if (nom2 and nif2) else (nom2 or nif2)
        return ""

    frames: list[pd.DataFrame] = []

    for pid in ids:
        # IMPORTANTE: esta trae más detalle que active_encumbrances
        df = active_encumbrances_affecting_partner(company_id, pid, as_of)
        if df is None or df.empty:
            continue

        info = pmap.get(int(pid), {})
        socio_tit = f"{info.get('nombre','')} ({info.get('nif','')})".strip()

        dfx = df.copy()
        dfx["socio_titular"] = socio_tit
        dfx["a_favor_de"]    = dfx.apply(_compose_benef_row, axis=1)

        # columnas extra de tipología para normalizar “Tipo”
        extra_tipo_cols = [c for c in ["tipo_evento","subtipo","evento_tipo","tipo_base","tipo_origen"] if c in dfx.columns]

        base_cols = ["fecha", "socio_titular", "tipo", "a_favor_de", "rango_desde", "rango_hasta"]
        keep_cols = base_cols + extra_tipo_cols
        keep_cols = [c for c in keep_cols if c in dfx.columns]
        frames.append(dfx[keep_cols])

    if not frames:
        return pd.DataFrame(columns=["fecha","socio_titular","tipo","a_favor_de","rango_desde","rango_hasta"])

    out = pd.concat(frames, ignore_index=True)
    out.sort_values(by=["fecha", "socio_titular", "a_favor_de"], inplace=True, na_position="last")
    return out.reset_index(drop=True)


def export_ledger_pdf_legalizable(
    company_id: int,
    date_from: str | None,
    date_to: str | None,
    event_types: list[str] | None,
    as_of: str | None = None,
    diligencia_apertura: str | None = None,
    diligencia_cierre: str | None = None,
) -> BytesIO:
    """
    PDF legalizable (apaisado) con:
      1) Relación de socios con participaciones a la fecha
      2) Relación de participaciones a la fecha
      3) Rangos vigentes por socio a la fecha
      4) Gravámenes a la fecha
      5) Movimientos del período
    """
    ensure_pdf_base_fonts()

    comp = _company_header(company_id)
    as_of_final = as_of or date_to or datetime.now().strftime("%Y-%m-%d")

    df_cap = _vigentes_cap_table(company_id, as_of_final)
    vigentes_ids = _vigentes_ids_from_cap(df_cap, company_id)
    pmap = _partners_lookup(company_id)

    # ========= Canvas
    buf = BytesIO()
    c = canvas.Canvas(buf, pagesize=landscape(A4))
    W, H = landscape(A4)
    left = 15 * mm
    right = W - 15 * mm

    def _header_block(title: str, meta_lines: list[str] | None = None) -> float:
        y = H - 12 * mm
        c.setFont("DejaVuSans-Bold", 12)
        c.drawString(left, y, title); y -= 5.5 * mm

        c.setFont("DejaVuSans", 9.5)
        c.drawString(left, y, f"Sociedad: {comp['name']}    •    CIF: {comp['cif']}"); y -= 4.2 * mm
        c.drawString(left, y, f"Domicilio: {comp['domicilio']}"); y -= 4.2 * mm
        if comp.get("fecha_constitucion"):
            c.drawString(left, y, f"Fecha constitución: {comp['fecha_constitucion']}"); y -= 4.2 * mm

        if meta_lines:
            for line in meta_lines:
                if line:
                    c.drawString(left, y, line); y -= 4.2 * mm

        c.setFont("DejaVuSans", 8.5); c.setFillColor(colors.grey)
        c.drawString(left, y, f"Emitido: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        c.setFillColor(colors.black); y -= 4.2 * mm
        c.setStrokeColor(colors.lightgrey); c.setLineWidth(0.6); c.line(left, y, right, y)
        return y - 6 * mm

    # ========= 1) Relación de socios =========
    y = _header_block(
        "Libro registro de socios – Relación de socios",
        [f"A fecha: {as_of_final}", f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
    )
    c.setFont("DejaVuSans-Bold", 9)
    cols_soc = [("#", 12*mm), ("Nombre / Razón social", 85*mm), ("NIF/CIF", 35*mm),
                ("Nacionalidad", 35*mm), ("Domicilio", right - left - (12+85+35+35)*mm)]
    x = left
    for t, w in cols_soc: c.drawString(x, y, t); x += w
    y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm

    c.setFont("DejaVuSans", 8.6)
    for pid in vigentes_ids:
        info = pmap.get(int(pid), {})
        if y < 18 * mm:
            c.showPage()
            y = _header_block(
                "Libro registro de socios – Relación de socios",
                [f"A fecha: {as_of_final}", f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
            )
            c.setFont("DejaVuSans-Bold", 9); x = left
            for t, w in cols_soc: c.drawString(x, y, t); x += w
            y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
            c.setFont("DejaVuSans", 8.6)

        x = left
        _col(c, x, y, str(pid), maxw=12*mm); x += 12*mm
        _col(c, x, y, info.get("nombre",""), maxw=85*mm); x += 85*mm
        _col(c, x, y, info.get("nif",""), maxw=35*mm); x += 35*mm
        _col(c, x, y, info.get("nacionalidad",""), maxw=35*mm); x += 35*mm
        _col(c, x, y, info.get("domicilio",""), maxw=(right-left - (12+85+35+35)*mm))
        y -= 5.2 * mm

    c.showPage()

    # ========= 2) Relación de participaciones a fecha =========
    y = _header_block(
        "Libro registro de socios – Relación de participaciones a fecha",
        [f"A fecha: {as_of_final}", f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
    )
    c.setFont("DejaVuSans-Bold", 9)
    cols_cap = [
        ("#", 12*mm), ("Socio", 88*mm), ("NIF/CIF", 35*mm),
        ("Participaciones", 35*mm), ("% (0–100)", 25*mm), ("Capital del socio (€)", 40*mm),
    ]
    x = left
    for title, width in cols_cap: c.drawString(x, y, title); x += width
    y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm

    c.setFont("DejaVuSans", 8.7)
    for _, r in df_cap.iterrows():
        if y < 18 * mm:
            c.showPage()
            y = _header_block(
                "Libro registro de socios – Relación de participaciones a fecha",
                [f"A fecha: {as_of_final}", f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
            )
            c.setFont("DejaVuSans-Bold", 9); x = left
            for title, width in cols_cap: c.drawString(x, y, title); x += width
            y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
            c.setFont("DejaVuSans", 8.7)

        pid = r.get("partner_id")
        if pd.isna(pid) or pid is None:
            pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
        x = left
        _col(c, x, y, "" if pid is None else str(int(pid)), maxw=12*mm); x += 12*mm
        _col(c, x, y, r.get("partner_name",""), maxw=88*mm); x += 88*mm
        _col(c, x, y, r.get("nif",""), maxw=35*mm); x += 35*mm
        c.drawRightString(x + 35*mm - 1.5*mm, y, f"{int(r.get('shares',0)):,}".replace(",", ".")); x += 35*mm
        pct = r.get("pct"); pct = ("" if pd.isna(pct) else f"{float(pct):.4f}")
        c.drawRightString(x + 25*mm - 1.5*mm, y, pct); x += 25*mm
        cap = r.get("capital_socio")
        cap_txt = "" if pd.isna(cap) or cap is None else f"{float(cap):,.2f}".replace(",", ".")
        c.drawRightString(x + 40*mm - 1.5*mm, y, cap_txt)
        y -= 5.3 * mm

    c.showPage()

    # ========= 3) Rangos vigentes por socio =========
    y = _header_block(
        "Libro registro de socios – Rangos vigentes por socio a la fecha",
        [f"A fecha: {as_of_final}"]
    )
    rows_ranges = []
    for _, r in df_cap.iterrows():
        pid = r.get("partner_id")
        if pd.isna(pid) or pid is None:
            pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
        if pid is None:
            continue
        rng = partner_holdings_ranges(company_id, int(pid), as_of_final)
        if rng is None or rng.empty:
            continue
        for _, rr in rng.iterrows():
            rows_ranges.append({
                "pid": int(pid),
                "socio": r.get("partner_name",""),
                "nif": r.get("nif",""),
                "desde": rr.get("rango_desde"),
                "hasta": rr.get("rango_hasta"),
                "participaciones": rr.get("participaciones"),
            })
    df_rng = pd.DataFrame(rows_ranges)

    c.setFont("DejaVuSans-Bold", 9)
    cols_rng = [("#", 12*mm), ("Socio", 88*mm), ("NIF/CIF", 35*mm),
                ("Desde", 25*mm), ("Hasta", 25*mm), ("Participaciones", 35*mm)]
    x = left
    for t, w in cols_rng: c.drawString(x, y, t); x += w
    y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
    c.setFont("DejaVuSans", 8.6)

    if df_rng.empty:
        _col(c, left, y, "(Sin rangos vigentes a la fecha)")
        y -= 6 * mm
    else:
        for _, r in df_rng.iterrows():
            if y < 18 * mm:
                c.showPage()
                y = _header_block(
                    "Libro registro de socios – Rangos vigentes por socio a la fecha",
                    [f"A fecha: {as_of_final}"]
                )
                c.setFont("DejaVuSans-Bold", 9); x = left
                for t, w in cols_rng: c.drawString(x, y, t); x += w
                y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
                c.setFont("DejaVuSans", 8.6)

            x = left
            _col(c, x, y, "" if pd.isna(r.get("pid")) else str(int(r.get("pid"))), maxw=12*mm); x += 12*mm
            _col(c, x, y, r.get("socio",""), maxw=88*mm); x += 88*mm
            _col(c, x, y, r.get("nif",""), maxw=35*mm); x += 35*mm
            c.drawRightString(x + 25*mm - 1.5*mm, y, "" if pd.isna(r.get("desde")) else str(int(r.get("desde")))); x += 25*mm
            c.drawRightString(x + 25*mm - 1.5*mm, y, "" if pd.isna(r.get("hasta")) else str(int(r.get("hasta")))); x += 25*mm
            c.drawRightString(x + 35*mm - 1.5*mm, y,
                "" if pd.isna(r.get("participaciones")) else f"{int(r.get('participaciones')):,}".replace(",", "."))
            y -= 5.2 * mm

    c.showPage()

    # ========= 4) Gravámenes a la fecha =========
    y = _header_block(
        "Libro registro de socios – Gravámenes sobre participaciones sociales",
        [f"A fecha: {as_of_final}"]
    )

    df_grav = _encumbrances_all(company_id, as_of_final, vigentes_ids, pmap)

    c.setFont("DejaVuSans-Bold", 9)
    cols_g = [
        ("Fecha", 24*mm),
        ("Socio titular", 70*mm),
        ("Tipo", 24*mm),
        ("A favor de", 80*mm),
        ("Desde", 18*mm),
        ("Hasta", 18*mm),
    ]
    x = left
    for title, width in cols_g: c.drawString(x, y, title); x += width
    y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
    c.setFont("DejaVuSans", 8.6)

    def _ensure_page_grav(y0: float) -> float:
        if y0 < 18 * mm:
            c.showPage()
            return _header_block(
                "Libro registro de socios – Gravámenes sobre participaciones sociales",
                [f"A fecha: {as_of_final}"]
            )
        return y0

    def _pick(row: dict, *keys: str) -> str:
        for k in keys:
            val = row.get(k)
            if val is not None and str(val).strip() != "":
                return str(val).strip()
        return ""

    def _tipo_txt(row: dict) -> str:
        raw = _pick(row, "tipo_evento", "tipo_origen", "tipo_base", "tipo", "subtipo", "evento_tipo").upper()
        if "PIGNOR" in raw: return "Pignoración"
        if "EMBARGO" in raw: return "Embargo"
        return (raw.title() if raw else "—")

    def _afavor_txt(row: dict) -> str:
        nom = _pick(row, "a_favor_de", "acreedor_nombre", "beneficiario_nombre", "tercero_nombre", "acreedor", "beneficiario")
        nif = _pick(row, "acreedor_nif", "beneficiario_nif", "tercero_nif")
        if nom and nif: return f"{nom} ({nif})"
        return nom or nif or ""

    def _draw_row_grav(y0: float, fila: dict) -> float:
        x = left
        _col(c, x, y0, str(fila.get("fecha","")), maxw=24*mm); x += 24*mm
        _col(c, x, y0, fila.get("socio_titular",""), maxw=70*mm); x += 70*mm
        _col(c, x, y0, _tipo_txt(fila), maxw=24*mm); x += 24*mm
        _col(c, x, y0, _afavor_txt(fila), maxw=80*mm); x += 80*mm
        dsd = "" if pd.isna(fila.get("rango_desde")) else str(int(fila.get("rango_desde")))
        hst = "" if pd.isna(fila.get("rango_hasta")) else str(int(fila.get("rango_hasta")))
        c.drawRightString(x + 18*mm - 1.5*mm, y0, dsd); x += 18*mm
        c.drawRightString(x + 18*mm - 1.5*mm, y0, hst)
        return y0 - 5.2 * mm

    if df_grav is None or df_grav.empty:
        _col(c, left, y, "(Sin gravámenes vigentes a la fecha)")
        y -= 6 * mm
    else:
        for _, row in df_grav.iterrows():
            if y < 18 * mm:
                y = _ensure_page_grav(y)
                c.setFont("DejaVuSans-Bold", 9); x = left
                for title, width in cols_g: c.drawString(x, y, title); x += width
                y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
                c.setFont("DejaVuSans", 8.6)
            y = _draw_row_grav(y, row.to_dict())

    c.showPage()

    # ========= 5) Movimientos del período =========
    y = _header_block(
        "Libro registro de socios – Movimientos del período",
        [f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
    )

    df_mov = _ledger_rows(company_id, date_from, date_to, event_types)

    # VN vigente por fila (si no viene explícito)
    vn_steps = _nominal_timeline(company_id)
    def _vn_row(r):
        if pd.notna(r.get("nuevo_valor_nominal")) and float(r["nuevo_valor_nominal"] or 0) > 0:
            return float(r["nuevo_valor_nominal"])
        return _vn_on_date(vn_steps, str(r.get("fecha") or ""))

    if df_mov is None or df_mov.empty:
        df_mov = pd.DataFrame(columns=[
            "correlativo","fecha","tipo",
            "socio_transmite_nombre","socio_transmite_nif",
            "socio_adquiere_nombre","socio_adquiere_nif",
            "rango_desde","rango_hasta","participaciones","nuevo_valor_nominal"
        ])
    df_mov = df_mov.copy()
    df_mov["vn_vigente"] = df_mov.apply(_vn_row, axis=1)

    TYPE_SHORT = {
        "ALTA": "ALTA",
        "TRANSMISION": "TRANS",
        "AMPL_EMISION": "AMPL_EMI",
        "AMPL_VALOR": "AMPL_VAL",
        "REDENOMINACION": "REDENOM",
        "PIGNORACION": "PIGNOR",
        "CANCELA_PIGNORACION": "CANC_PIG",
    }
    TYPE_DESC = {
        "ALTA": "Alta de socio / primera anotación",
        "TRANSMISION": "Transmisión de participaciones entre socios/terceros",
        "AMPL_EMISION": "Ampliación de capital por emisión de nuevas participaciones",
        "AMPL_VALOR": "Ampliación mediante aumento del valor nominal",
        "REDENOMINACION": "Cambio del valor nominal",
        "PIGNORACION": "Constitución de gravamen (pignoración/embargo)",
        "CANCELA_PIGNORACION": "Cancelación total o parcial de pignoración/embargo",
    }
    def _short(t):
        t0 = (str(t) or "").upper().strip()
        return TYPE_SHORT.get(t0, (t0[:10] if t0 else ""))

    df_mov["tipo_corto"] = df_mov["tipo"].map(_short)

    # ---- Config tabla
    FONT        = "DejaVuSans"
    FONT_BOLD   = "DejaVuSans-Bold"
    SIZE_HDR    = 8.9
    SIZE_TXT    = 8.4
    LINE_H      = 4.8 * mm
    PAD_Y       = 1.2 * mm
    GUT         = 2.2 * mm

    COLS = [
        ("Orden",   12),
        ("Fecha",   20),
        ("Tipo",    30),
        ("Transmite (Nombre / NIF)", 60),
        ("Adquiere (Nombre / NIF)",  60),
        ("Desde",   16),
        ("Hasta",   16),
        ("# Parts.",18),
        ("VN (€)",  18),
    ]

    x = left
    COL_X, COL_W = [], []
    for _, w in COLS:
        COL_X.append(x)
        COL_W.append(w * mm)
        x += w * mm + GUT

    def draw_mov_header(y0: float) -> float:
        c.setFont(FONT_BOLD, SIZE_HDR)
        for (title, _), x0 in zip(COLS, COL_X):
            c.drawString(x0, y0, title)
        y1 = y0 - 3.6 * mm
        _hr(c, y1, left, right)
        return y1 - 2.8 * mm

    def wrap(txt: str, max_w_px: float, max_lines: int = 3) -> list[str]:
        c.setFont(FONT, SIZE_TXT)
        t = ("" if txt is None else str(txt)).strip()
        if not t: return [""]
        words, lines, cur = t.split(), [], ""
        for w in words:
            trial = (cur + " " + w).strip()
            if c.stringWidth(trial, FONT, SIZE_TXT) <= max_w_px:
                cur = trial
            else:
                if cur: lines.append(cur)
                cur = w
            if len(lines) >= max_lines: break
        if len(lines) >= max_lines:
            last = (cur if cur else "").strip()
            while c.stringWidth(last + " …", FONT, SIZE_TXT) > max_w_px and len(last) > 3:
                last = last[:-1]
            if lines: lines[-1] = lines[-1] + " …"
            else: lines = [last + " …"]
            return lines
        if cur: lines.append(cur)
        return lines or [""]

    def ensure_page(y0: float) -> float:
        if y0 < (18 * mm + LINE_H + 2 * PAD_Y):
            c.showPage()
            y1 = _header_block(
                "Libro registro de socios – Movimientos del período",
                [f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
            )
            return draw_mov_header(y1)
        return y0

    y = draw_mov_header(y)
    c.setFont(FONT, SIZE_TXT)

    for _, r in df_mov.iterrows():
        orden = "" if pd.isna(r.get("correlativo")) else str(int(r.get("correlativo")))
        fecha = str(r.get("fecha") or "")
        tipo  = str(r.get("tipo_corto") or "")

        st_txt = " / ".join([s for s in [r.get("socio_transmite_nombre",""), r.get("socio_transmite_nif","")] if s])
        sa_txt = " / ".join([s for s in [r.get("socio_adquiere_nombre",""), r.get("socio_adquiere_nif","")] if s])

        dsd = "" if pd.isna(r.get("rango_desde")) else str(int(r.get("rango_desde")))
        hst = "" if pd.isna(r.get("rango_hasta")) else str(int(r.get("rango_hasta")))
        npp = "" if pd.isna(r.get("participaciones")) else f"{int(r.get('participaciones')):,}".replace(",", ".")
        vn  = r.get("vn_vigente")
        vn_txt = None if (vn in (None, float("nan"))) else f"{float(vn):,.2f}".replace(",", ".")

        w_tipo = wrap(tipo, COL_W[2] - 2.5 * mm)
        w_st   = wrap(st_txt, COL_W[3] - 2.5 * mm)
        w_sa   = wrap(sa_txt, COL_W[4] - 2.5 * mm)
        lines  = max(len(w_tipo), len(w_st), len(w_sa), 1)
        row_h  = lines * LINE_H + 2 * PAD_Y

        if y - row_h < 18 * mm:
            y = ensure_page(y)

        y_top = y
        c.drawRightString(COL_X[0] + COL_W[0] - 1.5 * mm, y_top, orden)
        c.drawString(COL_X[1], y_top, fecha)

        for i in range(lines):
            yy = y_top - PAD_Y - i * LINE_H
            _col(c, COL_X[2], yy, w_tipo[i] if i < len(w_tipo) else "", SIZE_TXT, maxw=COL_W[2] - 2.5 * mm)
            _col(c, COL_X[3], yy, w_st[i]   if i < len(w_st)   else "", SIZE_TXT, maxw=COL_W[3] - 2.5 * mm)
            _col(c, COL_X[4], yy, w_sa[i]   if i < len(w_sa)   else "", SIZE_TXT, maxw=COL_W[4] - 2.5 * mm)

        yy0 = y_top - PAD_Y
        c.drawRightString(COL_X[5] + COL_W[5] - 1.5*mm, yy0, dsd)
        c.drawRightString(COL_X[6] + COL_W[6] - 1.5*mm, yy0, hst)
        c.drawRightString(COL_X[7] + COL_W[7] - 1.5*mm, yy0, npp)
        if vn_txt is None or vn_txt.strip() == "":
            c.drawCentredString(COL_X[8] + COL_W[8] / 2.0, yy0, "–")
        else:
            c.drawRightString(COL_X[8] + COL_W[8] - 1.5*mm, yy0, vn_txt)

        y = y - row_h
        c.setStrokeColor(colors.whitesmoke); c.setLineWidth(0.4)
        c.line(left, y + 0.9 * mm, right, y + 0.9 * mm)
        c.setStrokeColor(colors.black)

    # ======= Leyenda =======
    try:
        tipos_presentes = sorted([str(x) for x in df_mov["tipo"].dropna().unique().tolist()])
    except Exception:
        tipos_presentes = []

    def _legend_header(y0: float) -> float:
        c.setFont("DejaVuSans-Bold", 9)
        c.drawString(left, y0, "Leyenda")
        y0 -= 3.0 * mm
        _hr(c, y0, left, right)
        return y0 - 2.4 * mm

    need = 30 * mm
    if y < (18 * mm + need):
        c.showPage()
        y = _header_block(
            "Libro registro de socios – Movimientos del período",
            [f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
        )

    y = _legend_header(y)
    c.setFont("DejaVuSans", 8)
    c.drawString(left, y, "VN (€): 'nan' indica que en ese asiento no hubo cambio de valor nominal (se mantiene el vigente).")
    y -= 4.2 * mm

    if tipos_presentes:
        pairs = []
        for t in tipos_presentes:
            t_up = (t or "").upper()
            short = TYPE_SHORT.get(t_up, t_up)
            desc  = TYPE_DESC.get(t_up, "Asiento según estatutos u operación registrada.")
            pairs.append(f"{short} = {desc}")
        texto = "Tipos de evento en el periodo: " + "; ".join(pairs) + "."
        y = _draw_paragraph(c, texto, left, y, max_width=(right - left), leading=11.0, font="DejaVuSans", font_size=8)

    c.showPage()
    c.save()
    buf.seek(0)

    log.info("Export Libro legalizable PDF company_id=%s from=%s to=%s as_of=%s types=%s",
             company_id, date_from, date_to, as_of_final, ",".join(event_types or []))
    return buf

# === PDF: Certificado histórico (trayectoria del socio) ===
def export_partner_history_pdf(
    company_id: int,
    partner_id: int,
    date_from: str | None = None,
    date_to: str | None = None,
    max_rows: int = 500,
) -> BytesIO:
    """
    Certificado histórico del socio: cabecera + tabla con los asientos que le afectaron
    en el periodo (o desde el inicio si no se indica 'date_from'), e incluye cambios de VN.

    - Muestra filas donde el socio aparece como transmite o adquiere.
    - Campos: Nº asiento (si existe), fecha, tipo, contrapartes, RD–RH, #parts (si se puede deducir),
      VN vigente en la fecha (o 'nuevo_valor_nominal' si cambió en ese asiento), doc/obs abreviado.
    """
    ensure_pdf_base_fonts()
    from_date = date_from or "0001-01-01"
    to_date = date_to or datetime.now().strftime("%Y-%m-%d")

    # Datos base
    comp = _company_header(company_id)
    pos  = partner_position(company_id, partner_id, to_date) or {}
    hist = last_entries_for_partner(company_id, partner_id, limit=max_rows, as_of=to_date)

    # Normaliza y filtra por rango de fechas si llegan ambas
    if hist is None or hist.empty:
        hist = pd.DataFrame(columns=[
            "id","correlativo","fecha","tipo","socio_transmite","socio_adquiere",
            "rango_desde","rango_hasta","n_participaciones","nuevo_valor_nominal",
            "documento","observaciones"
        ])
    else:
        hist = hist.copy()
        if "fecha" in hist.columns:
            hist = hist[(hist["fecha"] >= from_date) & (hist["fecha"] <= to_date)]

    # Prepara texto de contraparte y #parts
    def _counterparty(r: pd.Series) -> str:
        st = str(r.get("socio_transmite_nombre") or "")
        sa = str(r.get("socio_adquiere_nombre") or "")
        # el socio actual es partner_id; la “otra parte” es la que no es él
        st_id = r.get("socio_transmite_id")
        sa_id = r.get("socio_adquiere_id")
        if st_id == partner_id and sa:
            return sa
        if sa_id == partner_id and st:
            return st
        # gravámenes u otros (usar ambas si aplica)
        return " / ".join([x for x in (st, sa) if x]).strip()

    def _parts(r: pd.Series) -> str:
        # n_participaciones directo si existe; si no, intenta deducir RD–RH
        n = r.get("n_participaciones")
        if pd.notna(n) and n:
            try:
                return f"{int(n):,}".replace(",", ".")
            except Exception:
                pass
        rd, rh = r.get("rango_desde"), r.get("rango_hasta")
        try:
            if pd.notna(rd) and pd.notna(rh):
                val = int(rh) - int(rd) + 1
                if val > 0:
                    return f"{val:,}".replace(",", ".")
        except Exception:
            pass
        return ""

    # VN vigente por fila (como en el libro legalizable)
    vn_steps = _nominal_timeline(company_id)
    def _vn_row(r):
        nv = r.get("nuevo_valor_nominal")
        try:
            if pd.notna(nv) and float(nv or 0) > 0:
                return float(nv)
        except Exception:
            pass
        return _vn_on_date(vn_steps, str(r.get("fecha") or ""))

    if not hist.empty:
        # Estándar mínimo de columnas
        for c in ("socio_transmite_nombre","socio_adquiere_nombre","socio_transmite_id","socio_adquiere_id"):
            if c not in hist.columns:
                hist[c] = None
        hist["vn_vigente"] = hist.apply(_vn_row, axis=1)
        # Ordena cronológicamente
        hist = hist.sort_values(by=["fecha","id"], na_position="last").reset_index(drop=True)

    # Render PDF
    buf = BytesIO()
    c = canvas.Canvas(buf, pagesize=A4)
    W, H = A4
    y = H - 20 * mm
    content_width = W - 2 * MARGIN_X

    # Título
    c.setTitle("Certificado histórico del socio")
    c.setFont("DejaVuSans-Bold", 13)
    c.drawString(MARGIN_X, y, "Certificado histórico del socio"); y -= 6 * mm
    c.setFont("DejaVuSans", 9.5)
    c.drawString(MARGIN_X, y, f"Sociedad: {comp.get('name','')}  •  CIF: {comp.get('cif','')}")
    y -= 4.2 * mm
    c.drawString(MARGIN_X, y, f"Periodo: {from_date} → {to_date}"); y -= 8 * mm
    _hr(c, y); y -= SECTION_GAP

    # Resumen del socio a fecha final
    y = _section_title(c, "Resumen a la fecha de corte", y)
    y = _kv(c, y, "Socio", pos.get("partner_name",""))
    y = _kv(c, y, "NIF", pos.get("nif","") or "—")
    y = _kv(c, y, "Participaciones a fecha", f"{int(pos.get('shares',0)):,}".replace(",", "."))
    y = _kv(c, y, "Porcentaje a fecha", f"{float(pos.get('pct',0.0)):.4f} %")
    y -= 2 * mm

    # Tabla de trayectoria
    y = _section_title(c, "Asientos que afectan al socio", y)

    # Cabecera
    c.setFont("DejaVuSans-Bold", 9.2)
    x_fecha = MARGIN_X
    x_tipo  = x_fecha + 26 * mm
    x_asiento = x_tipo + 26 * mm
    x_cp   = x_asiento + 18 * mm
    x_rd   = x_cp + 60 * mm
    x_rh   = x_rd + 18 * mm
    x_np   = x_rh + 18 * mm
    x_vn   = x_np + 20 * mm

    def hdr(yy: float) -> float:
        _col(c, x_fecha,  yy, "Fecha")
        _col(c, x_tipo,   yy, "Tipo")
        _col(c, x_asiento,yy, "Nº")
        _col(c, x_cp,     yy, "Contraparte")
        _col(c, x_rd,     yy, "Desde")
        _col(c, x_rh,     yy, "Hasta")
        _col(c, x_np,     yy, "# Parts.")
        _col(c, x_vn,     yy, "VN (€)")
        y1 = yy - 4 * mm
        _hr(c, y1); return y1 - 3 * mm

    y = hdr(y)
    c.setFont("DejaVuSans", 8.7)

    if hist.empty:
        _col(c, MARGIN_X, y, "(No hay asientos en el periodo)"); y -= CONTENT_GAP
    else:
        for _, r in hist.iterrows():
            if y < 25 * mm:
                c.showPage(); y = H - 20 * mm
                y = _section_title(c, "Asientos que afectan al socio", y)
                y = hdr(y); c.setFont("DejaVuSans", 8.7)

            fecha = str(r.get("fecha") or "")
            tipo  = str(r.get("tipo") or "")
            nro   = "" if pd.isna(r.get("correlativo")) else str(int(r.get("correlativo")))
            cp    = _counterparty(r)
            rd    = "" if pd.isna(r.get("rango_desde")) else str(int(r.get("rango_desde")))
            rh    = "" if pd.isna(r.get("rango_hasta")) else str(int(r.get("rango_hasta")))
            np    = _parts(r)
            vn    = r.get("vn_vigente")
            vn_txt = "" if vn in (None, float("nan")) else f"{float(vn):,.2f}".replace(",", ".")

            _col(c, x_fecha,  y, fecha)
            _col(c, x_tipo,   y, tipo)
            _col(c, x_asiento,y, nro)
            _col(c, x_cp,     y, cp, maxw=(x_rd - x_cp - 3*mm))
            c.drawRightString(x_rd + 18*mm - 1.5*mm, y, rd)
            c.drawRightString(x_rh + 18*mm - 1.5*mm, y, rh)
            c.drawRightString(x_np + 20*mm - 1.5*mm, y, np)
            c.drawRightString(x_vn + 22*mm - 1.5*mm, y, (vn_txt or "–"))

            y -= 4.8 * mm

    # Nota legal breve
    y -= 2 * mm
    txt = (
        "Este certificado se emite a efectos informativos, reflejando los asientos del Libro Registro "
        "que afectaron al socio en el periodo indicado. El valor nominal mostrado corresponde al vigente "
        "en cada fecha de asiento, salvo que en dicho asiento se hubiera modificado explícitamente."
    )
    y = _draw_paragraph(c, txt, MARGIN_X, y, content_width, leading=11.0, font="DejaVuSans", font_size=8)

    c.showPage(); c.save()
    buf.seek(0)
    log.info("Export CertificadoHistorico.pdf company_id=%s partner_id=%s from=%s to=%s rows=%s",
             company_id, partner_id, from_date, to_date, 0 if hist is None else len(hist))
    return buf


# ===== app/core/services/governance_service.py =====

# app/core/services/governance_service.py

from __future__ import annotations

import json
from typing import Optional

from ..repositories import governance_repo
from ..validators import normalize_nif_cif, normalize_phone, validate_email
from ..enums import GOVERNANCE_ROLES, GOVERNANCE_ROLE_ALIASES


# Si en algún momento quieres permitir varios Presidentes, cambia a False.
ENFORCE_UNIQUE_PRESIDENT = True


def _normalize_role(value: str | None) -> str | None:
    if not value:
        return value
    v = value.strip()
    # 1) si ya es exactamente uno de los canónicos, devuelve tal cual
    if v in GOVERNANCE_ROLES:
        return v
    # 2) prueba con alias (lower y sin espacios/guiones bajos)
    key = v.lower().replace(" ", "_").replace("-", "_")
    mapped = GOVERNANCE_ROLE_ALIASES.get(key)
    return mapped or v  # si no está, deja lo que vino (mejor que perder el dato)


def list_board(company_id: int) -> list[dict]:
    rows = governance_repo.list_board(company_id)
    for r in rows:
        r["nif"] = normalize_nif_cif(r.get("nif"))
        r["telefono"] = normalize_phone(r.get("telefono"))
        r["cargo"] = _normalize_role(r.get("cargo"))
    return rows


def get_governance(company_id: int) -> dict:
    """
    Devuelve:
      - organo: str | None
      - board: lista de consejeros (prioriza board_members; si está vacío, usa firmantes_json)
      - source: 'board_members' | 'firmantes_json'
    """
    board = list_board(company_id)
    if board:
        meta = governance_repo.get_company_governance(company_id) or {}
        return {"organo": meta.get("organo"), "board": board, "source": "board_members"}

    # Fallback firmantes_json
    meta = governance_repo.get_company_governance(company_id) or {}
    organo = meta.get("organo")
    raw = meta.get("firmantes_json") or "[]"
    try:
        items = json.loads(raw)
    except Exception:
        items = []

    parsed = []
    for it in items:
        nombre = (it.get("nombre") or "").strip()
        rol = _normalize_role(it.get("rol"))
        if nombre:
            parsed.append({
                "id": None,
                "company_id": company_id,
                "nombre": nombre,
                "cargo": rol or "Firmante",
                "nif": None,
                "direccion": None,
                "telefono": None,
                "email": None,
            })
    return {"organo": organo, "board": parsed, "source": "firmantes_json"}


def migrate_firmantes_to_board(company_id: int) -> int:
    current = governance_repo.list_board(company_id)
    if current:
        return 0
    meta = governance_repo.get_company_governance(company_id) or {}
    raw = meta.get("firmantes_json") or "[]"
    try:
        items = json.loads(raw)
    except Exception:
        items = []
    count = 0
    for it in items:
        nombre = (it.get("nombre") or "").strip()
        cargo = _normalize_role(it.get("rol")) or "Firmante"
        if not nombre:
            continue
        governance_repo.upsert_board_member(
            id=None, company_id=company_id, nombre=nombre, cargo=cargo, nif="",
            direccion=None, telefono=None, email=None
        )
        count += 1
    return count


# ============================
# Validaciones reforzadas
# ============================

def _norm_txt(s: str | None) -> str:
    """Normalización suave para comparaciones."""
    return (s or "").strip().lower()


def _assert_role_present(cargo: str | None):
    cargo_norm = (cargo or "").strip()
    if not cargo_norm:
        raise ValueError("El rol/cargo es obligatorio.")
    return cargo_norm


def _assert_no_duplicates(*, company_id: int, member_id: Optional[int], nombre: str, cargo: str):
    """
    Evita duplicados exactos (mismo nombre + mismo cargo) dentro de la misma sociedad.
    - member_id puede ser None (alta) o un id (edición).
    """
    nombre_k = _norm_txt(nombre)
    cargo_k = _norm_txt(_normalize_role(cargo) or cargo)

    for r in list_board(company_id):
        # excluirse a sí mismo si es edición
        rid = r.get("id")
        if member_id is not None and rid == member_id:
            continue
        if _norm_txt(r.get("nombre")) == nombre_k and _norm_txt(r.get("cargo")) == cargo_k:
            raise ValueError(f"Ya existe un consejero con el mismo nombre y cargo: “{nombre} – {r.get('cargo')}”.")


def _assert_unique_president_if_needed(*, company_id: int, member_id: Optional[int], cargo: str):
    """
    Si ENFORCE_UNIQUE_PRESIDENT=True → valida que no haya más de un Presidente en la sociedad.
    """
    if not ENFORCE_UNIQUE_PRESIDENT:
        return
    cargo_final = _normalize_role(cargo) or cargo
    if cargo_final != "Presidente":
        return
    for r in list_board(company_id):
        rid = r.get("id")
        if member_id is not None and rid == member_id:
            continue
        if (r.get("cargo") or "").strip() == "Presidente":
            raise ValueError("Ya existe un Presidente en esta sociedad. Debes cambiar el rol del actual o del nuevo registro.")


# ============================
# Guardado con validación
# ============================

def save_board_member(
    *,
    id: Optional[int],
    company_id: int,
    nombre: str,
    cargo: str,
    nif: str,
    direccion: Optional[str],
    telefono: Optional[str],
    email: Optional[str]
) -> int:
    nombre = (nombre or "").strip()
    if not nombre:
        raise ValueError("El nombre es obligatorio.")

    # Normalizaciones/validaciones básicas existentes
    nif = normalize_nif_cif(nif)
    if email and not validate_email(email):
        raise ValueError("Email no válido.")
    telefono = normalize_phone(telefono)

    # 1) rol obligatorio + normalizado
    cargo_final = _normalize_role(_assert_role_present(cargo)) or cargo.strip()

    # 2) duplicados exactos (nombre+cargo)
    _assert_no_duplicates(company_id=company_id, member_id=id, nombre=nombre, cargo=cargo_final)

    # 3) unico Presidente (opcional, activado)
    _assert_unique_president_if_needed(company_id=company_id, member_id=id, cargo=cargo_final)

    # Persistencia
    return governance_repo.upsert_board_member(
        id=id, company_id=company_id, nombre=nombre, cargo=cargo_final, nif=nif,
        direccion=(direccion or None), telefono=(telefono or None), email=(email or None)
    )


# NUEVO: recompute correlativo del consejo (board_no) por sociedad
def recompute_board_numbers(company_id: Optional[int] = None) -> int:
    """
    Recalcula board_no por sociedad en board_members (idempotente).
    Si 'company_id' es None, lo hace para todas las compañías.
    """
    return governance_repo.recompute_board_no(company_id)

# ===== app/core/services/import_service.py =====

# app/core/services/import_service.py
from __future__ import annotations

import csv
import io
from dataclasses import dataclass
from typing import Optional, Any

import pandas as pd

from app.infra.db import get_connection
from app.core.enums import EVENT_TYPES, normalize_event_type
from app.core.services.events_service import create_event_generic


# ============================================================
# Tipos & resultados
# ============================================================

@dataclass
class DryRunRow:
    rownum: int
    data: dict[str, Any]
    normalized: dict[str, Any] | None
    errors: list[str]


@dataclass
class DryRunReport:
    kind: str                 # "partners" | "events"
    total_rows: int
    ok_rows: int
    error_rows: int
    errors: list[str]         # errores globales (encabezados, etc.)
    rows: list[DryRunRow]     # detalle fila a fila (primeras N filas en UI)


@dataclass
class CommitSummary:
    kind: str
    inserted: int
    updated: int
    errors: list[str]


# ============================================================
# Plantillas CSV
# ============================================================

def get_csv_template(kind: str) -> bytes:
    """
    Devuelve un CSV (bytes UTF-8) con encabezados + 2 filas de ejemplo.
    """
    kind = (kind or "").strip().lower()
    buf = io.StringIO()
    wr = csv.writer(buf)

    if kind == "partners":
        wr.writerow(["nombre", "nif", "nacionalidad", "domicilio", "partner_no"])
        wr.writerow(["Alice S.L.", "B12345678", "España", "C/ Mayor 1, Madrid", "1"])
        wr.writerow(["Bob S.A.", "A11111111", "España", "Av. Libertad 10, Bilbao", "2"])

    elif kind == "events":
        wr.writerow([
            "fecha", "tipo",
            "socio_transmite_nif", "socio_adquiere_nif",
            "rango_desde", "rango_hasta",
            "n_participaciones", "nuevo_valor_nominal",
            "documento", "observaciones",
        ])
        wr.writerow(["2024-01-10", "ALTA", "", "B12345678", "1", "100", "", "", "", "Ampliación"])
        wr.writerow(["2024-02-05", "TRANSMISION", "B12345678", "A11111111", "1", "50", "", "", "", "Traspaso parcial"])

    else:
        raise ValueError("Tipo de plantilla desconocido. Usa 'partners' o 'events'.")

    return buf.getvalue().encode("utf-8")


# ============================================================
# Helpers
# ============================================================

def _read_csv_to_df(file: bytes | io.BytesIO) -> pd.DataFrame:
    """
    Lee CSV (UTF-8, separador coma) a DataFrame sin transformar tipos.
    """
    if isinstance(file, (bytes, bytearray)):
        bio = io.BytesIO(file)
    else:
        bio = file
    bio.seek(0)
    return pd.read_csv(bio, dtype=str).fillna("")


def _partner_id_by_nif(nif: str, company_id: int) -> Optional[int]:
    if not nif:
        return None
    with get_connection() as conn:
        row = conn.execute(
            "SELECT id FROM partners WHERE company_id=? AND nif=? LIMIT 1",
            (company_id, nif.strip()),
        ).fetchone()
    return (int(row[0]) if row else None)


def _ensure_event_type(t: str) -> tuple[str | None, list[str]]:
    """
    Normaliza el tipo y valida contra EVENT_TYPES (permitimos 'OTRO').
    """
    errs: list[str] = []
    t_norm = normalize_event_type(t) if t is not None else None
    if t_norm and (t_norm not in EVENT_TYPES) and t_norm != "OTRO":
        errs.append(f"Tipo no reconocido: {t}")
    return t_norm, errs


# ============================================================
# Validaciones por tipo de import
# ============================================================

def _validate_partners_df(df: pd.DataFrame, company_id: int) -> list[DryRunRow]:
    """
    Reglas:
      - nombre (obligatorio), NIF (recomendado para idempotencia)
      - partner_no opcional (se sobreescribe)
      - Idempotencia: si existe NIF -> UPDATE, si no -> INSERT
    """
    required = ["nombre"]
    for col in required:
        if col not in df.columns:
            return [DryRunRow(0, {}, None, [f"Falta la columna obligatoria '{col}'."])]

    rows: list[DryRunRow] = []
    for idx, raw in df.iterrows():
        i = int(idx) + 2  # +2 por encabezado y base 1
        data = {c: str(raw.get(c, "")).strip() for c in df.columns}
        errs: list[str] = []

        nombre = data.get("nombre", "").strip()
        nif = data.get("nif", "").strip()
        nacionalidad = data.get("nacionalidad", "").strip() or None
        domicilio = data.get("domicilio", "").strip() or None
        partner_no = data.get("partner_no", "").strip()
        partner_no_val: Optional[int] = None
        if partner_no:
            try:
                partner_no_val = int(partner_no)
                if partner_no_val < 0:
                    raise ValueError()
            except Exception:
                errs.append("partner_no debe ser entero ≥ 0.")

        if not nombre:
            errs.append("El campo 'nombre' es obligatorio.")

        # Componer normalized
        normalized = {
            "nombre": nombre,
            "nif": nif or None,
            "nacionalidad": nacionalidad,
            "domicilio": domicilio,
            "partner_no": partner_no_val,
        }

        rows.append(DryRunRow(i, data, (None if errs else normalized), errs))

    return rows


def _validate_events_df(df: pd.DataFrame, company_id: int) -> list[DryRunRow]:
    """
    Reglas básicas MVP:
      - fecha obligatoria (YYYY-MM-DD)
      - tipo válido (EVENT_TYPES u OTRO)
      - si hay rangos -> rango_desde <= rango_hasta
      - socio_* por NIF si vienen (se traducen a IDs)
      - AMPL_VALOR / RED_VALOR requieren nuevo_valor_nominal > 0
    """
    needed = [
        "fecha", "tipo",
        "socio_transmite_nif", "socio_adquiere_nif",
        "rango_desde", "rango_hasta",
        "n_participaciones", "nuevo_valor_nominal",
        "documento", "observaciones",
    ]
    for col in needed:
        if col not in df.columns:
            return [DryRunRow(0, {}, None, [f"Falta la columna '{col}'."])]

    rows: list[DryRunRow] = []
    for idx, raw in df.iterrows():
        i = int(idx) + 2
        data = {c: str(raw.get(c, "")).strip() for c in df.columns}
        errs: list[str] = []

        # fecha
        fecha = data.get("fecha", "")
        if not fecha:
            errs.append("fecha es obligatoria (YYYY-MM-DD).")
        else:
            # validación simple de formato
            ok_fmt = True
            if len(fecha) != 10 or fecha[4] != "-" or fecha[7] != "-":
                ok_fmt = False
            if not ok_fmt:
                errs.append("fecha inválida. Usa YYYY-MM-DD.")

        # tipo
        tipo_norm, t_errs = _ensure_event_type(data.get("tipo", ""))
        errs.extend(t_errs or [])
        tipo_norm = tipo_norm or data.get("tipo", "").upper()

        # socios por NIF
        st_nif = data.get("socio_transmite_nif") or ""
        sa_nif = data.get("socio_adquiere_nif") or ""
        st_id = _partner_id_by_nif(st_nif, company_id) if st_nif else None
        sa_id = _partner_id_by_nif(sa_nif, company_id) if sa_nif else None

        if st_nif and st_id is None:
            errs.append(f"No existe socio con NIF '{st_nif}' (transmite).")
        if sa_nif and sa_id is None:
            errs.append(f"No existe socio con NIF '{sa_nif}' (adquiere).")

        # rangos
        rd = data.get("rango_desde") or ""
        rh = data.get("rango_hasta") or ""
        rd_val = rh_val = None
        if rd:
            try:
                rd_val = int(float(rd))
                if rd_val <= 0:
                    raise ValueError()
            except Exception:
                errs.append("rango_desde debe ser entero > 0.")
        if rh:
            try:
                rh_val = int(float(rh))
                if rh_val <= 0:
                    raise ValueError()
            except Exception:
                errs.append("rango_hasta debe ser entero > 0.")
        if (rd_val is not None) and (rh_val is not None) and (rh_val < rd_val):
            errs.append("rango_hasta no puede ser menor que rango_desde.")

        # nº participaciones
        np_txt = data.get("n_participaciones") or ""
        np_val: Optional[int] = None
        if np_txt:
            try:
                np_val = int(float(np_txt))
                if np_val < 0:
                    raise ValueError()
            except Exception:
                errs.append("n_participaciones debe ser entero ≥ 0.")

        # valor nominal
        nvn_txt = data.get("nuevo_valor_nominal") or ""
        nvn_val: Optional[float] = None
        if nvn_txt:
            try:
                nvn_val = float(nvn_txt)
                if nvn_val < 0:
                    raise ValueError()
            except Exception:
                errs.append("nuevo_valor_nominal debe ser numérico ≥ 0.")

        if tipo_norm in ("AMPL_VALOR", "RED_VALOR") and (not nvn_val or nvn_val <= 0):
            errs.append(f"{tipo_norm} requiere nuevo_valor_nominal > 0.")

        normalized = {
            "company_id": company_id,
            "fecha": fecha,
            "tipo": tipo_norm,
            "socio_transmite": st_id,
            "socio_adquiere": sa_id,
            "rango_desde": rd_val,
            "rango_hasta": rh_val,
            "n_participaciones": np_val,
            "nuevo_valor_nominal": nvn_val,
            "documento": (data.get("documento") or None),
            "observaciones": (data.get("observaciones") or None),
        }

        rows.append(DryRunRow(i, data, (None if errs else normalized), errs))

    return rows


# ============================================================
# API pública
# ============================================================

def dry_run(kind: str, company_id: int, file: bytes | io.BytesIO) -> DryRunReport:
    """
    No escribe en BD. Devuelve un informe por fila con normalización/errores.
    """
    kind = (kind or "").strip().lower()
    df = _read_csv_to_df(file)

    # Validar por tipo
    if kind == "partners":
        rows = _validate_partners_df(df, company_id)
    elif kind == "events":
        rows = _validate_events_df(df, company_id)
    else:
        return DryRunReport(kind, 0, 0, 0, [f"Tipo desconocido '{kind}'."], [])

    total = len(rows)
    ok = sum(1 for r in rows if r.errors == [])
    err = total - ok

    return DryRunReport(
        kind=kind,
        total_rows=total,
        ok_rows=ok,
        error_rows=err,
        errors=[],            # errores globales (si hubiera)
        rows=rows
    )


def commit(kind: str, company_id: int, rows: list[dict]) -> CommitSummary:
    """
    Escribe en BD de forma transaccional. 'rows' debe venir ya normalizado (p.ej. de dry_run).
    - partners: upsert por NIF (si NIF vacío -> INSERT siempre)
    - events: inserta vía create_event_generic(...)
    """
    kind = (kind or "").strip().lower()
    errors: list[str] = []
    inserted = 0
    updated = 0

    if kind == "partners":
        with get_connection() as conn:
            try:
                conn.execute("BEGIN")
                for r in rows:
                    nombre = r.get("nombre")
                    nif = r.get("nif")
                    nacionalidad = r.get("nacionalidad")
                    domicilio = r.get("domicilio")
                    partner_no = r.get("partner_no")

                    if nif:
                        row = conn.execute(
                            "SELECT id FROM partners WHERE company_id=? AND nif=? LIMIT 1",
                            (company_id, nif)
                        ).fetchone()
                        if row:
                            # UPDATE
                            conn.execute(
                                """
                                UPDATE partners
                                SET nombre=?, nacionalidad=?, domicilio=?, partner_no=?
                                WHERE id=? AND company_id=?
                                """,
                                (nombre, nacionalidad, domicilio, partner_no, int(row[0]), company_id)
                            )
                            updated += 1
                        else:
                            # INSERT
                            conn.execute(
                                """
                                INSERT INTO partners(company_id, nombre, nif, nacionalidad, domicilio, partner_no)
                                VALUES (?,?,?,?,?,?)
                                """,
                                (company_id, nombre, nif, nacionalidad, domicilio, partner_no)
                            )
                            inserted += 1
                    else:
                        # Sin NIF: INSERT siempre
                        conn.execute(
                            """
                            INSERT INTO partners(company_id, nombre, nif, nacionalidad, domicilio, partner_no)
                            VALUES (?,?,?,?,?,?)
                            """,
                            (company_id, nombre, None, nacionalidad, domicilio, partner_no)
                        )
                        inserted += 1

                conn.commit()
            except Exception as e:
                conn.rollback()
                errors.append(str(e))

    elif kind == "events":
        # Insertamos uno a uno; si falla, abortamos todo.
        with get_connection() as conn:
            try:
                conn.execute("BEGIN")
                for r in rows:
                    # Todos los campos en r están normalizados por dry_run
                    create_event_generic(**r)
                    inserted += 1
                conn.commit()
            except Exception as e:
                conn.rollback()
                errors.append(str(e))
    else:
        errors.append(f"Tipo desconocido '{kind}'.")

    return CommitSummary(kind=kind, inserted=inserted, updated=updated, errors=errors)

# ===== app/core/services/maintenance_service.py =====

# app/core/services/maintenance_service.py
from __future__ import annotations
from typing import Optional, Literal

from app.infra.db import get_connection
from app.infra.healthcheck import integrity_check, foreign_key_check, quick_summary

from app.core.repositories import events_repo, partners_repo
from app.core.services import governance_service


def run_analyze() -> None:
    with get_connection() as conn:
        conn.execute("ANALYZE;")

def run_reindex() -> None:
    with get_connection() as conn:
        conn.execute("REINDEX;")

def run_vacuum() -> None:
    with get_connection() as conn:
        conn.execute("VACUUM;")

# Re-export helpers
def db_integrity_check(): return integrity_check()
def db_fk_check(): return foreign_key_check()
def db_quick_summary(): return quick_summary()


# ----------------------------
# Correlativos existentes
# ----------------------------
def recompute_events_correlativos(company_id: Optional[int] = None) -> int:
    return events_repo.recompute_correlativo(company_id)

def recompute_partners_correlativos(company_id: Optional[int] = None) -> int:
    return partners_repo.recompute_partner_no(company_id)

# ----------------------------
# NUEVO: correlativos gobernanza
# ----------------------------
def recompute_governance_correlativos(company_id: Optional[int] = None) -> int:
    return governance_service.recompute_board_numbers(company_id)


def recompute_correlativos(
    *,
    company_id: Optional[int] = None,
    scope: Literal["events", "partners", "governance", "both", "all"] = "both"
) -> dict:
    """
    Ejecuta recompute según ámbito seleccionado.
    - "both": events + partners
    - "all": events + partners + governance
    - "events" | "partners" | "governance": solo ese
    Devuelve {'events': n, 'partners': m, 'governance': g}
    """
    out = {"events": 0, "partners": 0, "governance": 0}

    if scope in ("both", "all", "events"):
        out["events"] = recompute_events_correlativos(company_id)
    if scope in ("both", "all", "partners"):
        out["partners"] = recompute_partners_correlativos(company_id)
    if scope in ("all", "governance"):
        out["governance"] = recompute_governance_correlativos(company_id)

    return out

# === Índices mínimos recomendados ===
import sqlite3
from typing import Dict, List, Tuple
from app.infra.db import get_connection

def _have_index(conn: sqlite3.Connection, table: str, idx_name: str) -> bool:
    row = conn.execute("PRAGMA index_list(%s)" % table).fetchall()
    names = {r[1] for r in row} if row else set()
    return idx_name in names

def ensure_min_indexes() -> Dict[str, str]:
    """
    Crea (si no existen) los índices mínimos:
      - events(company_id, fecha, id)
      - partners(company_id)
    Además, si tu esquema los usa, es útil:
      - events(company_id, correlativo)
      - board_members(company_id)
    Devuelve un dict {nombre_indice: 'created'|'exists'}.
    """
    targets: List[Tuple[str, str, str]] = [
        # table, index_name, create_sql
        ("events", "idx_events_company_fecha_id",
         "CREATE INDEX IF NOT EXISTS idx_events_company_fecha_id ON events(company_id, fecha, id)"),
        ("partners", "idx_partners_company",
         "CREATE INDEX IF NOT EXISTS idx_partners_company ON partners(company_id)"),
        # Opcionales pero recomendados si se usan mucho en consultas/UI:
        ("events", "idx_events_company_correlativo",
         "CREATE INDEX IF NOT EXISTS idx_events_company_correlativo ON events(company_id, correlativo)"),
        ("board_members", "idx_board_members_company",
         "CREATE INDEX IF NOT EXISTS idx_board_members_company ON board_members(company_id)"),
    ]

    results: Dict[str, str] = {}
    with get_connection() as conn:
        for table, idx, sql in targets:
            try:
                existed = _have_index(conn, table, idx)
            except Exception:
                # Si falla PRAGMA (tabla puede no existir), intenta crear y que sea IF NOT EXISTS
                existed = False
            try:
                conn.execute(sql)
                # Si ya existía, SQLite igualmente no falla por el IF NOT EXISTS
                results[idx] = "exists" if existed else "created"
            except Exception as e:
                results[idx] = f"error: {e}"
        conn.commit()
    return results

# app/core/services/maintenance_service.py  (añade al final)
from .normalization_service import recompute_denormalized as _recompute_denorm

def recompute_denormalized(company_id: Optional[int] = None) -> dict:
    """
    Wrapper para lanzar el recompute de columnas auxiliares (si existen).
    """
    return _recompute_denorm(company_id)

# ===== app/core/services/normalization_service.py =====

# app/core/services/normalization_service.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Any, Tuple, List, Dict, TypedDict
import sqlite3
import unicodedata
import re

from ...infra.db import get_connection
from ..validators import normalize_nif_cif  # validador existente

# ---------------------------
# Utilidades de normalización
# ---------------------------

# Permite letras, dígitos, espacio y PUNTO (para "s.l.")
_NON_ALNUM_SPACE_RE = re.compile(r"[^a-z0-9 .]+")
_SPACES_RE = re.compile(r"\s+")

# Partículas (minúsculas en title-case)
_LOWER_PARTICLES = {
    "de", "del", "la", "las", "el", "los", "y", "en", "por", "para", "con", "da", "do"
}

# Abreviaturas societarias -> forma canónica (mayúsculas, con puntos)
_ABBR_CANON: Dict[str, str] = {
    "sl": "S.L.",
    "s.l": "S.L.",
    "s.l.": "S.L.",
    "s l": "S.L.",
    "slu": "S.L.U.",
    "s.l.u": "S.L.U.",
    "s.l.u.": "S.L.U.",
    "s l u": "S.L.U.",
    "sa": "S.A.",
    "s.a": "S.A.",
    "s.a.": "S.A.",
    "s a": "S.A.",
    "sau": "S.A.U.",
    "s.a.u": "S.A.U.",
    "s.a.u.": "S.A.U.",
    "s a u": "S.A.U.",
}

_ROMAN_RE = re.compile(
    r"^(?=[MDCLXVI]+$)M{0,4}(CM|CD|D?C{0,3})"
    r"(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$",
    re.I,
)

def _strip_accents(s: str) -> str:
    if not s:
        return s
    return "".join(c for c in unicodedata.normalize("NFKD", s) if unicodedata.category(c) != "Mn")

def build_search_name(name: Optional[str]) -> Optional[str]:
    """
    Nombre para búsquedas: minúsculas, sin tildes, espacios colapsados.
    Conserva '.' para abreviaturas (p.ej., 's.l.'), pero elimina comas y otra
    puntuación irrelevante.
    """
    if not name:
        return None
    s = _strip_accents(str(name)).lower().strip()
    s = _SPACES_RE.sub(" ", s)
    # Eliminar signos comunes de puntuación excepto el punto (.)
    # para respetar 's.l.' / 's.a.' en búsquedas.
    s = re.sub(r"[^a-z0-9. ]+", "", s)
    s = _SPACES_RE.sub(" ", s).strip()
    return s or None

# app/core/services/normalization_service.py

def build_name_ascii(name: Optional[str]) -> Optional[str]:
    """
    Nombre ASCII: minúsculas, sin tildes, solo [a-z0-9 espacio], espacios colapsados.
    Elimina puntuación (incluido el punto) aunque build_search_name la conserve.
    """
    if not name:
        return None
    # Partimos de la versión de búsqueda (minúsculas, sin tildes, espacios normalizados)
    s = build_search_name(name) or ""
    # Eliminar cualquier carácter que NO sea [a-z0-9 espacio] -> quita '.', comas, etc.
    s = re.sub(r"[^a-z0-9 ]+", "", s)
    s = _SPACES_RE.sub(" ", s).strip()
    return s or None

def _normalize_company_token(tok: str) -> str:
    key = tok.replace(",", " ").strip().lower().rstrip(".")
    key = _SPACES_RE.sub(" ", key)
    if key in _ABBR_CANON:
        return _ABBR_CANON[key]
    return tok

def _titlecase_spanish(text: str) -> str:
    """
    Title case en español con:
      - partículas en minúscula
      - números romanos en mayúscula
      - abreviaturas societarias canónicas (S.L., S.A., S.L.U., S.A.U.)
    """
    if not text:
        return text
    s = _SPACES_RE.sub(" ", text.strip())
    tokens = s.split(" ")
    out: List[str] = []
    for raw in tokens:
        if not raw:
            continue
        tok = raw

        canon = _normalize_company_token(tok)
        if canon != tok:
            out.append(canon)
            continue

        if _ROMAN_RE.match(tok):
            out.append(tok.upper())
            continue

        low = tok.lower()
        if low in _LOWER_PARTICLES:
            out.append(low)
            continue

        if len(tok) == 1:
            out.append(tok.upper())
        else:
            out.append(tok[0].upper() + tok[1:].lower())
    return " ".join(out)

def normalize_display_name(name: Optional[str], *, remove_accents: bool = False) -> Optional[str]:
    """
    Normaliza un nombre para mostrar (Title Case español con reglas anteriores).
    Si remove_accents=True, elimina acentos del resultado.
    """
    if not name:
        return None
    s = _SPACES_RE.sub(" ", str(name)).strip()
    s = _titlecase_spanish(s)
    if remove_accents:
        s = _strip_accents(s)
    return s or None


# ============================================================
# RECOMPUTE de columnas denormalizadas (si existen)
# ============================================================

def recompute_denormalized(company_id: Optional[int] = None) -> dict[str, Any]:
    """
    Rellena/actualiza columnas auxiliares si existen en partners:
      - partners.search_name
      - partners.name_ascii
    No crea columnas; si no existen, las ignora.
    """
    out: dict[str, Any] = {"partners": {"examined": 0, "updated": 0, "details": []}}

    with get_connection() as conn:
        conn.row_factory = sqlite3.Row

        cols = {r["name"] for r in conn.execute("PRAGMA table_info(partners)")}
        need_search = "search_name" in cols
        need_ascii = "name_ascii" in cols

        if not (need_search or need_ascii):
            return out

        if company_id is None:
            rows = conn.execute(
                "SELECT id, company_id, nombre, search_name, name_ascii FROM partners"
            ).fetchall()
        else:
            rows = conn.execute(
                "SELECT id, company_id, nombre, search_name, name_ascii FROM partners WHERE company_id=?",
                (company_id,),
            ).fetchall()

        out["partners"]["examined"] = len(rows)

        to_update: List[Tuple[str, List[Any]]] = []
        examples: List[dict] = []

        for r in rows:
            pid = int(r["id"])
            nombre = r["nombre"] or ""
            curr_search = r["search_name"] if need_search else None
            curr_ascii = r["name_ascii"] if need_ascii else None

            new_search = build_search_name(nombre) if need_search else None
            new_ascii = build_name_ascii(nombre) if need_ascii else None

            changed = False
            sets: List[str] = []
            vals: List[Any] = []

            if need_search and (new_search != curr_search):
                sets.append("search_name=?")
                vals.append(new_search)
                changed = True
            if need_ascii and (new_ascii != curr_ascii):
                sets.append("name_ascii=?")
                vals.append(new_ascii)
                changed = True

            if changed:
                vals.append(pid)
                to_update.append((f"UPDATE partners SET {', '.join(sets)} WHERE id=?", vals))
                if len(examples) < 25:
                    examples.append(
                        {
                            "id": pid,
                            "before": {"search_name": curr_search, "name_ascii": curr_ascii},
                            "after": {"search_name": new_search, "name_ascii": new_ascii},
                        }
                    )

        for sql, params in to_update:
            conn.execute(sql, params)
        conn.commit()

        out["partners"]["updated"] = len(to_update)
        out["partners"]["details"] = examples

    return out


# ============================================================
# Normalización avanzada – usada por Utilidades (UI)
# ============================================================

class SectionResult(TypedDict):
    changed: int
    samples: List[dict]

class RunResult(TypedDict):
    dry_run: bool
    partners: SectionResult
    governance: SectionResult

@dataclass
class NormalizationOptions:
    scope: str = "partners"                 # "partners" | "governance" | "both"
    company_id: Optional[int] = None
    fix_names: bool = True
    fix_nif: bool = True
    remove_accents: bool = False
    dry_run: bool = True
    sample_limit: int = 30

def _run_normalization_opts(opts: NormalizationOptions) -> RunResult:
    """
    Aplica normalización en tablas soportadas según `opts.scope`.
    Devuelve un resumen con contadores y muestras de cambios.
    """
    result: RunResult = {
        "dry_run": bool(opts.dry_run),
        "partners": {"changed": 0, "samples": []},
        "governance": {"changed": 0, "samples": []},
    }
    sample_limit = int(opts.sample_limit or 30)

    with get_connection() as conn:
        conn.row_factory = sqlite3.Row

        def _maybe_commit() -> None:
            if not opts.dry_run:
                conn.commit()

        # -------- PARTNERS --------
        if opts.scope in {"partners", "both"}:
            if opts.company_id is None:
                rows = conn.execute(
                    "SELECT id, company_id, nombre, nif FROM partners"
                ).fetchall()
            else:
                rows = conn.execute(
                    "SELECT id, company_id, nombre, nif FROM partners WHERE company_id=?",
                    (opts.company_id,),
                ).fetchall()

            for r in rows:
                pid = int(r["id"])
                nombre_old = r["nombre"] or ""
                nif_old = r["nif"] or ""

                nombre_new = nombre_old
                if opts.fix_names:
                    nombre_new = normalize_display_name(nombre_old, remove_accents=opts.remove_accents) or nombre_old

                nif_new = nif_old
                if opts.fix_nif and nif_old:
                    nif_new = normalize_nif_cif(nif_old)

                if (nombre_new != nombre_old) or (nif_new != nif_old):
                    result["partners"]["changed"] += 1

                    if len(result["partners"]["samples"]) < sample_limit:
                        result["partners"]["samples"].append(
                            {
                                "id": pid,
                                "before": {"nombre": nombre_old, "nif": nif_old},
                                "after": {"nombre": nombre_new, "nif": nif_new},
                            }
                        )

                    if not opts.dry_run:
                        conn.execute(
                            "UPDATE partners SET nombre=?, nif=? WHERE id=?",
                            (nombre_new, nif_new, pid),
                        )

            _maybe_commit()

        # -------- GOVERNANCE (board_members) --------
        if opts.scope in {"governance", "both"}:
            # Si no existe la tabla, ignorar silenciosamente
            have_tables = {r[0] for r in conn.execute("SELECT name FROM sqlite_master WHERE type='table'")}
            if "board_members" in have_tables:
                if opts.company_id is None:
                    rows = conn.execute(
                        "SELECT id, company_id, nombre, nif FROM board_members"
                    ).fetchall()
                else:
                    rows = conn.execute(
                        "SELECT id, company_id, nombre, nif FROM board_members WHERE company_id=?",
                        (opts.company_id,),
                    ).fetchall()

                for r in rows:
                    bid = int(r["id"])
                    nombre_old = r["nombre"] or ""
                    nif_old = r["nif"] or ""

                    nombre_new = nombre_old
                    if opts.fix_names:
                        nombre_new = normalize_display_name(nombre_old, remove_accents=opts.remove_accents) or nombre_old

                    nif_new = nif_old
                    if opts.fix_nif and nif_old:
                        nif_new = normalize_nif_cif(nif_old)

                    if (nombre_new != nombre_old) or (nif_new != nif_old):
                        result["governance"]["changed"] += 1

                        if len(result["governance"]["samples"]) < sample_limit:
                            result["governance"]["samples"].append(
                                {
                                    "id": bid,
                                    "before": {"nombre": nombre_old, "nif": nif_old},
                                    "after": {"nombre": nombre_new, "nif": nif_new},
                                }
                            )

                        if not opts.dry_run:
                            conn.execute(
                                "UPDATE board_members SET nombre=?, nif=? WHERE id=?",
                                (nombre_new, nif_new, bid),
                            )

                _maybe_commit()

    return result

def run_normalization(
    scope: str = "partners",
    company_id: Optional[int] = None,
    *,
    fix_names: bool = True,
    fix_nif: bool = True,
    remove_accents: bool = False,
    dry_run: bool = True,
    sample_limit: int = 30,
) -> RunResult:
    """
    Firma pensada para utilities.py:
      run_normalization(scope="partners" | "governance" | "both", company_id=...,
                        fix_names=True, fix_nif=True, remove_accents=False,
                        dry_run=True, sample_limit=30)
    """
    scope_eff = (scope or "partners").lower()
    if scope_eff not in {"partners", "governance", "both"}:
        scope_eff = "partners"

    opts = NormalizationOptions(
        scope=scope_eff,
        company_id=company_id,
        fix_names=bool(fix_names),
        fix_nif=bool(fix_nif),
        remove_accents=bool(remove_accents),
        dry_run=bool(dry_run),
        sample_limit=int(sample_limit),
    )
    return _run_normalization_opts(opts)

# ===== app/core/services/partners_service.py =====

#app/core/services/partners_services.py

from typing import Optional
from ..repositories import partners_repo
from ..validators import normalize_nif_cif

def list_partners(company_id: int) -> list[dict]:
    rows = partners_repo.list_by_company(company_id)
    for r in rows:
        r["nif"] = normalize_nif_cif(r.get("nif"))
    return rows

def save_partner(*, id: Optional[int], company_id: int, nombre: str, nif: str,
                 domicilio: Optional[str], nacionalidad: Optional[str],
                 fecha_nacimiento_constitucion: Optional[str]) -> int:
    nif = normalize_nif_cif(nif)
    return partners_repo.upsert_partner(
        id=id, company_id=company_id, nombre=nombre, nif=nif,
        domicilio=domicilio, nacionalidad=nacionalidad,
        fecha_nacimiento_constitucion=fecha_nacimiento_constitucion
    )

# ===== app/core/services/reporting_service.py =====

# app/core/services/reporting_service.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, List, Dict, Any, Tuple
import pandas as pd
from datetime import datetime
import sqlite3

from app.core.services.compute_service import compute_snapshot
from app.infra.db import get_connection
from app.core.repositories import events_repo

# ----------------------------- utils introspección ----------------------------
def _table_exists(conn, name: str) -> bool:
    row = conn.execute(
        "SELECT 1 FROM sqlite_master WHERE type IN ('table','view') AND name = ? LIMIT 1", (name,)
    ).fetchone()
    return bool(row)

def _columns(conn, table: str) -> set:
    try:
        cur = conn.execute(f"PRAGMA table_info({table})")
        return {r[1] for r in cur.fetchall()}
    except Exception:
        return set()

def _has_column(conn, table: str, col: str) -> bool:
    return col in _columns(conn, table)

# Posibles nombres de tabla puente y columnas de clase
LINK_TABLE_CANDIDATES = ["event_partners", "events_partners", "event_lines", "event_legs"]
CLASS_COL_CANDIDATES  = ["class", "share_class", "serie", "series"]

# ------------------------------ modelos dto -----------------------------------
@dataclass
class KPIs:
    num_partners: int
    total_shares: int
    share_nominal: float | None
    share_capital: float | None
    last_event_date: str | None
    num_classes: int | None

# --------------------------- CAP TABLE (multi-esquema) ------------------------
# --- CAP TABLE a fecha ---
def cap_table(company_id: int, as_of: str | None = None) -> pd.DataFrame:
    """
    Devuelve la cap table a fecha 'as_of' (YYYY-MM-DD) a partir de compute_snapshot,
    coherente con Overview. Columnas de salida:
      partner_id, partner_name, nif, classes, shares, pct, capital_socio
    """
    ref_date = as_of
    snap = compute_snapshot(company_id, ref_date)
    socios = pd.DataFrame(snap.get("socios_vigentes") or [])

    if socios.empty:
        return pd.DataFrame(columns=["partner_id","partner_name","nif","classes","shares","pct","capital_socio"])

    socios = socios.rename(columns={
        "partner_id": "partner_id",
        "nombre": "partner_name",
        "participaciones": "shares",
        "porcentaje": "pct"
    })
    socios["classes"] = ""  # no manejas clases/series en tu esquema V2

    # Añadimos NIF desde partners
    with get_connection() as conn:
        partners = pd.read_sql_query(
            "SELECT id AS partner_id, COALESCE(nif,'') AS nif FROM partners WHERE company_id = ?",
            conn, params=(company_id,)
        )
    df = socios.merge(partners, on="partner_id", how="left")
    if "nif" not in df.columns:
        df["nif"] = ""
    df["nif"] = df["nif"].fillna("")
    df["shares"] = pd.to_numeric(df["shares"], errors="coerce").fillna(0).astype(int)
    df["pct"] = pd.to_numeric(df["pct"], errors="coerce").fillna(0.0)

    # capital_socio = shares × valor_nominal (si disponible)
    snap2 = compute_snapshot(company_id, as_of)
    meta = snap2.get("meta", {}) if isinstance(snap2, dict) else {}
    valor_nominal = float(meta.get("valor_nominal")) if meta.get("valor_nominal") is not None else None
    if valor_nominal is not None:
        df["capital_socio"] = (df["shares"] * valor_nominal)
    else:
        df["capital_socio"] = None

    return df[["partner_id","partner_name","nif","classes","shares","pct","capital_socio"]]

# ------------------------------------ KPIs ------------------------------------
def kpis(company_id: int, as_of: str | None = None) -> KPIs:
    ref_date = as_of or datetime.today().strftime("%Y-%m-%d")
    snap = compute_snapshot(company_id, ref_date)
    meta = snap.get("meta", {}) if isinstance(snap, dict) else {}

    df_cap = cap_table(company_id, ref_date)
    num_partners = int((df_cap["shares"] > 0).sum())

    total_shares = int(meta.get("total_participaciones") or 0)
    share_nominal = float(meta["valor_nominal"]) if meta.get("valor_nominal") is not None else None
    share_capital = float(meta["capital_social"]) if meta.get("capital_social") is not None else None

    with get_connection() as conn:
        row = conn.execute(
            "SELECT MAX(fecha) FROM events WHERE company_id = ? AND (? IS NULL OR fecha <= ?)",
            (company_id, ref_date, ref_date)
        ).fetchone()
    last_event_date = row[0] if row and row[0] else None
    num_classes = 0

    return KPIs(num_partners, total_shares, share_nominal, share_capital, last_event_date, num_classes)

# ---------------------------- Movimientos (flex) ------------------------------
def movements(company_id: int,
              date_from: Optional[str] = None,
              date_to: Optional[str] = None,
              event_types: Optional[List[str]] = None) -> pd.DataFrame:
    """
    Devuelve movimientos con columnas REALES:
      id, company_id, correlativo, fecha, tipo,
      socio_transmite, socio_adquiere,
      rango_desde, rango_hasta,
      nuevo_valor_nominal, documento, observaciones,
      hora, orden_del_dia, created_at, updated_at
    """
    rows = events_repo.list_events_upto(company_id, date_to)  # corte superior
    df = pd.DataFrame(rows)
    if df.empty:
        return df
    if date_from:
        df = df[df["fecha"] >= date_from]
    if event_types:
        df = df[df["tipo"].isin(event_types)]
    df = df.sort_values(by=["fecha","id"], ascending=[True, True]).reset_index(drop=True)
    return df

# --- Timeline a fecha ---
def event_timeline(company_id: int, as_of: str | None = None) -> pd.DataFrame:
    with get_connection() as conn:
        rows = conn.execute(
            "SELECT DISTINCT fecha FROM events WHERE company_id=? AND (? IS NULL OR fecha <= ?) ORDER BY fecha ASC",
            (company_id, as_of, as_of)
        ).fetchall()
    dates = [r[0] for r in rows]
    if not dates:
        return pd.DataFrame(columns=["date","total_shares_acum"])

    data = []
    for d in dates:
        snap = compute_snapshot(company_id, d)
        tot = int((snap.get("meta") or {}).get("total_participaciones") or 0)
        data.append({"date": d, "total_shares_acum": tot})
    return pd.DataFrame(data)

def capital_timeline(company_id: int, as_of: str | None = None) -> pd.DataFrame:
    with get_connection() as conn:
        rows = conn.execute(
            "SELECT DISTINCT fecha FROM events WHERE company_id=? AND (? IS NULL OR fecha <= ?) ORDER BY fecha ASC",
            (company_id, as_of, as_of)
        ).fetchall()
    dates = [r[0] for r in rows]
    if not dates:
        return pd.DataFrame(columns=["date", "capital_social"])

    data = []
    for d in dates:
        snap = compute_snapshot(company_id, d)
        meta = snap.get("meta", {}) if isinstance(snap, dict) else {}
        cap = meta.get("capital_social")
        cap = float(cap) if cap is not None else None
        data.append({"date": d, "capital_social": cap})
    return pd.DataFrame(data)

# --- Posición socio a fecha ---
def partner_position(company_id: int, partner_id: int, as_of: str | None = None) -> dict:
    df = cap_table(company_id, as_of)
    row = df[df["partner_id"] == partner_id]
    if row.empty:
        return {"partner_id": partner_id, "partner_name": "", "nif": "", "shares": 0, "pct": 0.0, "classes": ""}
    r = row.iloc[0]
    return {
        "partner_id": int(r["partner_id"]),
        "partner_name": str(r["partner_name"]),
        "nif": str(r["nif"] or ""),
        "shares": int(r["shares"]),
        "pct": float(r["pct"]),
        "classes": ""  # no usas clases
    }

# -------------------- Últimos apuntes de un socio (flex) ----------------------
def last_entries_for_partner(company_id: int, partner_id: int, limit: int = 10, as_of: str | None = None) -> pd.DataFrame:
    """
    Últimos eventos donde el socio aparece como transmite o adquiere.
    Columnas: id, fecha, tipo, documento, observaciones, socio_transmite, socio_adquiere
    """
    with get_connection() as conn:
        sql = """
            SELECT id, fecha, tipo, documento, observaciones,
                   socio_transmite, socio_adquiere
            FROM events
            WHERE company_id=?
              AND (socio_transmite=? OR socio_adquiere=?)
              AND (? IS NULL OR fecha <= ?)
            ORDER BY fecha DESC, id DESC
            LIMIT ?
        """
        df = pd.read_sql_query(sql, conn, params=(company_id, partner_id, partner_id, as_of, as_of, limit))
    return df

# --- RANGOS de participaciones vigentes por socio (a fecha) ---
def partner_holdings_ranges(company_id: int, partner_id: int, as_of: str) -> pd.DataFrame:
    """
    Devuelve bloques vigentes del socio a 'as_of' desde compute_snapshot:
      columnas: partner_id, rango_desde, rango_hasta, participaciones
    """
    snap = compute_snapshot(company_id, as_of)
    hv = pd.DataFrame(snap.get("holdings_vigentes") or [])
    if hv.empty:
        return pd.DataFrame(columns=["rango_desde","rango_hasta","participaciones"])
    hv = hv[hv.get("partner_id") == partner_id].copy()
    hv["participaciones"] = pd.to_numeric(hv.get("participaciones"), errors="coerce").fillna(0).astype(int)
    for col in ("rango_desde","rango_hasta"):
        if col in hv.columns:
            hv[col] = pd.to_numeric(hv[col], errors="coerce")
    sort_cols = [c for c in ["rango_desde","rango_hasta"] if c in hv.columns]
    if sort_cols:
        hv = hv.sort_values(by=sort_cols, ascending=True)
    return hv[["rango_desde","rango_hasta","participaciones"]]

# ======================= GRAVÁMENES (Altas / Cancelaciones) ===================
# Compatibilidad de literales:
#  - Altas: PIGNORACION / EMBARGO
#  - Cancelaciones: LEV_GRAVAMEN / ALZAMIENTO  (y admitimos CANCELA_* si existieran)
_ENC_START = ("PIGNORACION", "EMBARGO")
_ENC_CANCEL = ("LEV_GRAVAMEN", "ALZAMIENTO", "CANCELA_PIGNORACION", "CANCELA_EMBARGO")

def _partners_min_map(company_id: int) -> dict[int, dict]:
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            "SELECT id, nombre, nif FROM partners WHERE company_id=?",
            (company_id,)
        ).fetchall()
    return {int(r["id"]): {"nombre": r["nombre"] or "", "nif": r["nif"] or ""} for r in rows}

def encumbrance_events(company_id: int, as_of: Optional[str] = None, partner_id: Optional[int] = None) -> pd.DataFrame:
    """
    Todos los eventos de gravamen (altas/cancelaciones), opcionalmente
    filtrados por titular (partner_id) y truncados a fecha 'as_of'.
    Columnas: fecha, tipo, titular_id, acreedor_id, rango_desde, rango_hasta, documento, observaciones
    """
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        sql = """
            SELECT id, fecha, tipo,
                   socio_transmite   AS titular_id,
                   socio_adquiere    AS acreedor_id,
                   rango_desde, rango_hasta,
                   documento, observaciones
            FROM events
            WHERE company_id=?
              AND tipo IN ({})
        """.format(",".join(["?"] * (len(_ENC_START) + len(_ENC_CANCEL))))
        params: List = [company_id, *list(_ENC_START + _ENC_CANCEL)]
        if as_of:
            sql += " AND fecha<=?"
            params.append(as_of)
        if partner_id:
            # por diseño, el titular debe ir en socio_transmite; mantenemos compatibilidad
            sql += " AND (socio_transmite=? OR socio_adquiere=?)"
            params.extend([partner_id, partner_id])
        sql += " ORDER BY fecha, id"
        rows = conn.execute(sql, params).fetchall()

    if not rows:
        return pd.DataFrame(columns=[
            "fecha","tipo","titular_id","acreedor_id","rango_desde","rango_hasta","documento","observaciones"
        ])
    return pd.DataFrame([{
        "fecha": r["fecha"],
        "tipo":  r["tipo"],
        "titular_id": r["titular_id"],
        "acreedor_id": r["acreedor_id"],
        "rango_desde": r["rango_desde"],
        "rango_hasta": r["rango_hasta"],
        "documento": r["documento"] or "",
        "observaciones": r["observaciones"] or "",
    } for r in rows])

# ---- utilidades de rangos (enteros inclusivos [a,b]) -------------------------
Range = Tuple[int, int]

def _norm_range(a, b) -> Optional[Range]:
    if a is None or b is None:
        return None
    try:
        a, b = int(a), int(b)
    except Exception:
        return None
    if b < a:
        a, b = b, a
    return (a, b)

def _merge_ranges(ranges: List[Range]) -> List[Range]:
    if not ranges: return []
    ranges = sorted(ranges)
    merged = [ranges[0]]
    for a, b in ranges[1:]:
        la, lb = merged[-1]
        if a <= lb + 1:
            merged[-1] = (la, max(lb, b))
        else:
            merged.append((a, b))
    return merged

def _subtract_one(base: List[Range], cut: Range) -> List[Range]:
    if not base: return []
    out: List[Range] = []
    ca, cb = cut
    for a, b in base:
        if cb < a or ca > b:
            out.append((a, b))
        else:
            if a < ca: out.append((a, ca - 1))
            if cb < b: out.append((cb + 1, b))
    return _merge_ranges([r for r in out if r[0] <= r[1]])

def _subtract_many(base: List[Range], cuts: List[Range]) -> List[Range]:
    cur = _merge_ranges(base)
    for c in _merge_ranges(cuts):
        cur = _subtract_one(cur, c)
        if not cur:
            break
    return cur

def _encumbrances_for_titular_and_acreedor(events_df: pd.DataFrame, titular_id: int, acreedor_id: int) -> List[Range]:
    """Rangos vigentes para (titular, acreedor) a la fecha tope del DF."""
    if events_df is None or events_df.empty:
        return []
    df = events_df[
        (events_df["titular_id"] == titular_id) &
        (events_df["acreedor_id"] == acreedor_id)
    ].copy()
    if df.empty:
        return []

    altas: List[Range] = []
    bajas: List[Range] = []
    for _, r in df.iterrows():
        rng = _norm_range(r.get("rango_desde"), r.get("rango_hasta"))
        if not rng:
            continue
        t = str(r.get("tipo") or "").upper()
        if t in _ENC_START:
            altas.append(rng)
        elif t in _ENC_CANCEL:
            bajas.append(rng)

    if not altas:
        return []
    return _subtract_many(_merge_ranges(altas), bajas)

def active_encumbrances(company_id: int, partner_id: int, as_of: str) -> pd.DataFrame:
    """
    Rangos de gravamen VIGENTES a 'as_of' para el partner_id (titular).
    Columnas: fecha, tipo, rango_desde, rango_hasta, documento, observaciones
    """
    ev = encumbrance_events(company_id, as_of=as_of, partner_id=partner_id)
    if ev is None or ev.empty:
        return pd.DataFrame(columns=["fecha","tipo","rango_desde","rango_hasta","documento","observaciones"])

    acreedores = sorted([int(x) for x in ev["acreedor_id"].dropna().unique().tolist()])
    rows = []
    for acre_id in acreedores:
        tramos = _encumbrances_for_titular_and_acreedor(ev, partner_id, acre_id)
        if not tramos:
            continue
        # fecha de referencia ≈ mínima fecha de alta que contribuye al tramo
        ev_altas = ev[(ev["acreedor_id"] == acre_id) & (ev["tipo"].str.upper().isin(_ENC_START))]
        ref_fecha = None
        if not ev_altas.empty:
            try:
                ref_fecha = str(sorted(ev_altas["fecha"].astype(str).tolist())[0])
            except Exception:
                ref_fecha = None
        for a, b in tramos:
            rows.append({
                "fecha": ref_fecha or "",
                "tipo": "GRAVAMEN",
                "rango_desde": a,
                "rango_hasta": b,
                "documento": "",
                "observaciones": "",
            })
    if not rows:
        return pd.DataFrame(columns=["fecha","tipo","rango_desde","rango_hasta","documento","observaciones"])
    df = pd.DataFrame(rows)
    df.sort_values(by=["rango_desde","rango_hasta"], inplace=True, ignore_index=True)
    return df

def _substract_intervals(base: tuple[int,int], cuts: list[tuple[int,int]]) -> list[tuple[int,int]]:
    """Resta a [a,b] una lista de recortes; devuelve lista de residuos ordenados y no solapados."""
    if base is None:
        return []
    a, b = base
    if a is None or b is None:
        return [(a, b)]  # si no hay rango numérico definido, no partimos
    segs = [(a, b)]
    for ca, cb in sorted(cuts):
        new_segs = []
        for x0, x1 in segs:
            if cb < x0 or ca > x1:             # sin solape
                new_segs.append((x0, x1))
            else:
                if ca > x0:
                    new_segs.append((x0, ca-1))
                if cb < x1:
                    new_segs.append((cb+1, x1))
        segs = new_segs
        if not segs:
            break
    # limpia segmentos vacíos
    return [(x0, x1) for (x0, x1) in segs if x0 is not None and x1 is not None and x0 <= x1]


def active_encumbrances_affecting_partner(company_id: int, partner_id: int, as_of: str) -> pd.DataFrame:
    """
    Gravámenes vigentes a 'as_of' cuyos rangos se solapan con los bloques vigentes del socio.
    Aplica cancelaciones parciales (p.ej. ALZAMIENTO 50–75 resta al tramo de inicio).
    Columnas: fecha, tipo, rango_desde, rango_hasta, documento, observaciones,
              acreedor_id, acreedor_nombre, acreedor_nif
    """
    # 1) Bloques vigentes del socio
    rng = partner_holdings_ranges(company_id, partner_id, as_of)
    if rng is None or rng.empty:
        return pd.DataFrame(columns=[
            "fecha","tipo","rango_desde","rango_hasta","documento","observaciones",
            "acreedor_id","acreedor_nombre","acreedor_nif"
        ])
    rng["rango_desde"] = pd.to_numeric(rng["rango_desde"], errors="coerce").astype("Int64")
    rng["rango_hasta"] = pd.to_numeric(rng["rango_hasta"], errors="coerce").astype("Int64")

    with get_connection() as conn:
        conn.row_factory = sqlite3.Row

        # Inicios (pign./emb.) hasta as_of
        sql_start = f"""
            SELECT id, fecha, tipo, rango_desde, rango_hasta,
                   socio_transmite, socio_adquiere, documento, observaciones
            FROM events
            WHERE company_id=? AND fecha<=? AND tipo IN ({",".join("?"*len(_ENC_START))})
            ORDER BY fecha, id
        """
        starts = conn.execute(sql_start, (company_id, as_of, *_ENC_START)).fetchall()

        # Cancelaciones hasta as_of
        sql_cancel = f"""
            SELECT id, fecha, tipo, rango_desde, rango_hasta,
                   socio_transmite, socio_adquiere
            FROM events
            WHERE company_id=? AND fecha<=? AND tipo IN ({",".join("?"*len(_ENC_CANCEL))})
            ORDER BY fecha, id
        """
        cancels = conn.execute(sql_cancel, (company_id, as_of, *_ENC_CANCEL)).fetchall()

        # Mapa de socios para mostrar acreedor
        pmap = {
            int(r["id"]): {"nombre": r["nombre"] or "", "nif": r["nif"] or ""}
            for r in conn.execute("SELECT id, nombre, nif FROM partners WHERE company_id=?", (company_id,)).fetchall()
        }

    # Prepara recortes por acreedor (clave: socio_adquiere del inicio)
    cuts_by_creditor: dict[int, list[tuple[int,int]]] = {}
    for c in cancels:
        ca = pd.to_numeric(c["rango_desde"], errors="coerce")
        cb = pd.to_numeric(c["rango_hasta"], errors="coerce")
        if pd.isna(ca) or pd.isna(cb):
            # Cancelación sin rango numérico: por simplicidad, tratamos como nada que recortar.
            # (Si quieres que anule todo lo del acreedor, convierte esto en (-inf, +inf).)
            continue
        cred = c["socio_adquiere"] or c["socio_transmite"]
        if cred is None:
            continue
        cuts_by_creditor.setdefault(int(cred), []).append((int(ca), int(cb)))

    out_rows = []

    for e in starts:
        ea = pd.to_numeric(e["rango_desde"], errors="coerce")
        eb = pd.to_numeric(e["rango_hasta"], errors="coerce")

        # 2) ¿Se solapa con algún bloque vigente del socio?
        overlaps_partner = False
        if pd.isna(ea) or pd.isna(eb):
            overlaps_partner = True
        else:
            for _, rr in rng.iterrows():
                d = rr["rango_desde"]; h = rr["rango_hasta"]
                if pd.isna(d) or pd.isna(h):
                    continue
                if int(ea) <= int(h) and int(eb) >= int(d):
                    overlaps_partner = True
                    break
        if not overlaps_partner:
            continue

        # 3) Sustracción de cancelaciones del MISMO acreedor
        cred_id = e["socio_adquiere"] or e["socio_transmite"]
        base = None if (pd.isna(ea) or pd.isna(eb)) else (int(ea), int(eb))
        cuts = cuts_by_creditor.get(int(cred_id)) or []
        residuals = _substract_intervals(base, cuts)

        # Si no hay rango numérico, mantenlo tal cual (no partimos)
        if not residuals and (pd.isna(ea) or pd.isna(eb)):
            residuals = [(None, None)]

        # 4) Emitir una fila por cada tramo residual
        cred_nombre = cred_nif = ""
        if cred_id and int(cred_id) in pmap:
            cred_nombre = pmap[int(cred_id)]["nombre"]
            cred_nif    = pmap[int(cred_id)]["nif"]

        for ra, rb in residuals:
            # Si tras recortes no queda nada, saltamos
            if ra is not None and rb is not None and ra > rb:
                continue
            out_rows.append({
                "fecha": e["fecha"],
                "tipo": e["tipo"],
                "rango_desde": ra,
                "rango_hasta": rb,
                "documento": e["documento"] or "",
                "observaciones": e["observaciones"] or "",
                "acreedor_id": cred_id,
                "acreedor_nombre": cred_nombre,
                "acreedor_nif": cred_nif,
            })

    return pd.DataFrame(out_rows, columns=[
        "fecha","tipo","rango_desde","rango_hasta","documento","observaciones",
        "acreedor_id","acreedor_nombre","acreedor_nif"
    ])

# ===== app/core/validators.py =====

#app/core/validators.py

import re
def normalize_nif_cif(value: str | None) -> str | None:
    if not value:
        return value
    v = value.upper().strip().replace("-", "").replace(" ", "")
    return v
def validate_email(value: str | None) -> bool:
    if not value: 
        return True
    return bool(re.match(r"^[^@\s]+@[^@\s]+\.[^@\s]+$", value))
def normalize_phone(value: str | None) -> str | None:
    if not value:
        return value
    return value.strip().replace(" ", "")

# ===== app/infra/__init__.py =====

from .logging import setup_logging, LOG_FILE  # opcional

# ===== app/infra/constants.py =====

from pathlib import Path
ROOT_DIR = Path(__file__).resolve().parents[2]
APP_DIR = ROOT_DIR / "app"
DATA_DIR = ROOT_DIR / "data"
LOGS_DIR = ROOT_DIR / "logs"
ASSETS_DIR = APP_DIR / "assets"
FONTS_DIR = ASSETS_DIR / "fonts"
DB_PATH = DATA_DIR / "libro_socios.db"

# ===== app/infra/db.py =====

#app/infra/db.py

import sqlite3
from contextlib import contextmanager
from .constants import DB_PATH
@contextmanager
def get_connection():
    conn = sqlite3.connect(DB_PATH)
    try:
        conn.row_factory = sqlite3.Row
        yield conn
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        conn.close()

# ===== app/infra/healthcheck.py =====

# app/infra/healthcheck.py
from __future__ import annotations
from typing import List, Tuple, Any
import sqlite3
from app.infra.db import get_connection

def _first_cell(row: Any) -> str:
    """
    Devuelve el primer valor de la fila (soporta tuple, dict, sqlite3.Row).
    Si falla, devuelve str(row) como último recurso.
    """
    # tuple / list
    if isinstance(row, (tuple, list)) and row:
        return row[0]
    # sqlite3.Row (soporta indexado por posición y clave)
    try:
        if isinstance(row, sqlite3.Row):
            # primero por posición
            try:
                return row[0]
            except Exception:
                # luego por nombre habitual del PRAGMA
                for k in ("integrity_check",):
                    try:
                        return row[k]
                    except Exception:
                        pass
                return str(dict(row))  # última opción legible
    except Exception:
        pass
    # dict
    if isinstance(row, dict):
        # intenta claves habituales
        for k in ("integrity_check",):
            if k in row:
                return row[k]
        # o el primer valor
        if row:
            return next(iter(row.values()))
    # fallback
    return str(row)

def integrity_check() -> List[str]:
    """
    PRAGMA integrity_check; devuelve lista de problemas (vacía si todo 'ok').
    """
    out: List[str] = []
    with get_connection() as conn:
        # forzamos Row para tener un formato estable
        conn.row_factory = sqlite3.Row
        cur = conn.execute("PRAGMA integrity_check;")
        rows = cur.fetchall()
        for r in rows:
            val = str(_first_cell(r)).strip()
            if val.lower() != "ok":
                out.append(val)
    return out

def foreign_key_check() -> List[Tuple[str, int, str, int]]:
    """
    PRAGMA foreign_key_check; devuelve (tabla, rowid, parent, fkid).
    Vacío si no hay violaciones o si FK no está habilitado.
    """
    issues: List[Tuple[str, int, str, int]] = []
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        try:
            cur = conn.execute("PRAGMA foreign_key_check;")
            for r in cur.fetchall():
                # el orden típico es: table, rowid, parent, fkid
                def _idx(i, default=None):
                    try:
                        return r[i]
                    except Exception:
                        return default
                table  = str(_idx(0, "") or "")
                rowid  = int(_idx(1, -1) or -1)
                parent = str(_idx(2, "") or "")
                fkid   = int(_idx(3, -1) or -1)
                issues.append((table, rowid, parent, fkid))
        except Exception:
            # PRAGMA no disponible o FK desactivadas
            return []
    return issues

def quick_summary() -> dict:
    integ = integrity_check()
    fks   = foreign_key_check()
    return {
        "integrity_ok": len(integ) == 0,
        "fk_ok": len(fks) == 0,
        "integrity_messages": integ,
        "fk_violations": fks,
    }

# ===== app/infra/logging.py =====

from pathlib import Path
import logging
from logging.handlers import RotatingFileHandler

LOG_DIR  = Path(__file__).resolve().parents[2] / "logs"
LOG_FILE = LOG_DIR / "app.log"

def setup_logging(level: int = logging.INFO) -> logging.Logger:
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    root = logging.getLogger()

    # Evita añadir más de un handler si Streamlit reejecuta
    for h in list(root.handlers):
        if isinstance(h, RotatingFileHandler) and Path(getattr(h, "baseFilename", "")) == LOG_FILE:
            return root

    root.setLevel(level)
    fh = RotatingFileHandler(LOG_FILE, maxBytes=1_000_000, backupCount=3, encoding="utf-8")
    fmt = logging.Formatter("%(asctime)s %(levelname)s [%(name)s] %(message)s")
    fh.setFormatter(fmt)
    root.addHandler(fh)
    return root

__all__ = ["setup_logging", "LOG_FILE"]

# ===== app/infra/pdf_fonts.py =====

# app/infra/pdf_fonts.py
from __future__ import annotations
from pathlib import Path
import logging
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont

log = logging.getLogger(__name__)

# Rutas donde buscar las fuentes (TU estructura: app/assets/fonts)
# app/infra/pdf_fonts.py -> parents[1] = app/
_APP_DIR = Path(__file__).resolve().parents[1]
_CANDIDATE_DIRS = [
    _APP_DIR / "assets" / "fonts",      # ← app/assets/fonts   ✅
    Path.cwd() / "app" / "assets" / "fonts",  # por si cwd cambia
]

_FILES = {
    "DejaVuSans":              "DejaVuSans.ttf",
    "DejaVuSans-Bold":         "DejaVuSans-Bold.ttf",
    "DejaVuSans-Oblique":      "DejaVuSans-Oblique.ttf",
    "DejaVuSans-BoldOblique":  "DejaVuSans-BoldOblique.ttf",
}

_registered = False

def _find(pathname: str) -> Path | None:
    for base in _CANDIDATE_DIRS:
        p = base / pathname
        if p.exists():
            return p
    return None

def register_fonts():
    """Registra DejaVuSans* si existen en app/assets/fonts."""
    global _registered
    if _registered:
        return

    missing = []
    for face, fname in _FILES.items():
        p = _find(fname)
        if not p:
            missing.append(fname)
            continue
        try:
            pdfmetrics.registerFont(TTFont(face, str(p)))
            log.info("Fuente registrada: %s -> %s", face, p)
        except Exception as e:
            log.warning("No se pudo registrar %s (%s): %s", face, p, e)

    if missing:
        log.warning(
            "Faltan fuentes DejaVu: %s. Si persiste el error, usa Helvetica como fallback.",
            ", ".join(missing),
        )
    _registered = True

# ===== app/streamlit_app.py =====

#app/streamlit_app.py

# --- bootstrap de rutas: asegura que la raíz del proyecto está en sys.path ---
import sys
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]  # .../libro_socios_v2
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))
# -----------------------------------------------------------------------------

import streamlit as st
from app.infra.logging import setup_logging
from app.ui.layout import sidebar_selector, sidebar_menu
from app.ui.routing import render_page

# Inicializar logging una sola vez
if "logging_setup" not in st.session_state:
    logger = setup_logging()
    st.session_state["logging_setup"] = True
else:
    import logging
    logger = logging.getLogger()

st.set_page_config(page_title="📘 Libro Registro de Socios – v2", layout="wide")
with st.sidebar:
    sidebar_selector()
    section = sidebar_menu()
render_page(section, st.session_state.get("company_id"))

# ===== app/ui/__init__.py =====



# ===== app/ui/layout.py =====

#app/ui/layout.py

import streamlit as st
from app.core.services.companies_service import list_companies
def sidebar_selector():
    companies = list_companies()
    options = ["(elige)"] + [f"{c['id']} – {c['name']} – {c['cif']}" for c in companies]
    sel = st.selectbox("Sociedad", options, key="company_selector")
    st.session_state.company_id = int(sel.split(" – ")[0]) if sel != "(elige)" else None
def sidebar_menu():
    return st.sidebar.radio(
        "Secciones",
        ["Overview","Sociedades","Gobernanza","Socios","Eventos","Reports","Utilidades"],
        key="section_selector"
    )

# ===== app/ui/pages/__init__.py =====



# ===== app/ui/pages/companies.py =====

# app/ui/pages/companies.py
from __future__ import annotations
import streamlit as st
import pandas as pd
from datetime import date, datetime
import logging

from app.core.services.companies_service import (
    list_companies, get_company, save_company, delete_company
)

log = logging.getLogger(__name__)

MIN_CO_DATE = date(1900, 1, 1)   # soporta sociedades antiguas
MAX_CO_DATE = date.today()

def _to_date_or_none(s: str | None) -> date | None:
    if not s:
        return None
    try:
        return datetime.strptime(s, "%Y-%m-%d").date()
    except Exception:
        return None

def _clear_form_state():
    st.session_state.setdefault("co_id", 0)
    st.session_state["co_name"] = ""
    st.session_state["co_cif"] = ""
    st.session_state["co_dom"] = ""
    st.session_state["co_fec"] = None

def render(company_id: int | None):
    st.subheader("Sociedades")
    
    # --- resets/prefills antes de instanciar widgets ---
    if st.session_state.get("co_form_reset", False):
        for k, v in (("co_id", 0), ("co_name", ""), ("co_cif", ""), ("co_dom", ""), ("co_fec", None)):
            st.session_state[k] = v
        st.session_state["co_form_reset"] = False

    # Listado
    rows = list_companies()
    df = pd.DataFrame(rows) if rows else pd.DataFrame(columns=["id","name","cif","domicilio","fecha_constitucion"])
    st.dataframe(df, use_container_width=True, hide_index=True)

    st.markdown("---")
    with st.expander("➕ Alta / edición de sociedad", expanded=True):
        # Estado inicial del formulario
        if "co_name" not in st.session_state:
            _clear_form_state()

        # Fila superior: ID + Cargar datos
        col_id, col_btn = st.columns([1,1])
        with col_id:
            cid_input = st.number_input(
                "ID (0 para alta)", min_value=0, step=1, key="co_id"
            )
        with col_btn:
            if st.button("🔎 Cargar datos"):
                if cid_input and cid_input > 0:
                    row = get_company(int(cid_input))
                    if row:
                        st.session_state["co_name"] = row.get("name") or ""
                        st.session_state["co_cif"]  = row.get("cif") or ""
                        st.session_state["co_dom"]  = row.get("domicilio") or ""
                        st.session_state["co_fec"]  = _to_date_or_none(row.get("fecha_constitucion"))
                        st.success(f"Cargada sociedad ID {cid_input}.")
                    else:
                        st.warning(f"No se encontró la sociedad ID {cid_input}.")
                else:
                    st.info("Introduce un ID > 0 para cargar.")
                st.rerun()

        # Campos principales (pre-rellenados desde session_state)
        col1, col2 = st.columns(2)
        with col1:
            name = st.text_input("Nombre", value=st.session_state.get("co_name",""), key="co_name")
            domicilio = st.text_input("Domicilio", value=st.session_state.get("co_dom",""), key="co_dom")
        with col2:
            cif = st.text_input("CIF/NIF", value=st.session_state.get("co_cif",""), key="co_cif")
            fec = st.date_input(
                "Fecha constitución",
                min_value=MIN_CO_DATE, max_value=MAX_CO_DATE,
                format="YYYY-MM-DD", key="co_fec"
            )

        # Botonera
        cA, cB, cC = st.columns([1,1,1])
        with cA:
            if st.button("💾 Guardar"):
                fec_txt = st.session_state["co_fec"].isoformat() if st.session_state.get("co_fec") else None
                new_id = save_company(
                    id=(int(st.session_state.get("co_id") or 0) or None),
                    name=st.session_state.get("co_name","").strip(),
                    cif=st.session_state.get("co_cif","").strip(),
                    domicilio=(st.session_state.get("co_dom","").strip() or None),
                    fecha_constitucion=fec_txt
                )
                log.info("UI save company id=%s", new_id)
                st.success(f"Sociedad guardada (ID {new_id}).")
                _clear_form_state()
                st.rerun()
        with cB:
            if st.button("🗑️ Eliminar", disabled=(int(st.session_state.get("co_id",0)) == 0)):
                delete_company(int(st.session_state["co_id"]))
                log.warning("UI delete company id=%s", int(st.session_state["co_id"]))
                st.success(f"Sociedad {int(st.session_state['co_id'])} eliminada.")
                _clear_form_state()
                st.rerun()
        with cC:
            if st.button("🧹 Limpiar formulario"):
                st.session_state["co_form_reset"] = True
                st.rerun()

    st.caption("Esta pantalla usa la capa de servicios/repos para leer y persistir 'companies'.")

# ===== app/ui/pages/events.py =====

# app/ui/pages/events.py
from __future__ import annotations
import streamlit as st
import pandas as pd
from datetime import date, datetime
import logging

from app.core.enums import EVENT_TYPES
from app.core.services.events_service import (
    list_events_for_ui,
    create_event_generic,
    get_event,
    update_event,
    delete_event,
    create_redenominacion,
)
from app.core.services.partners_service import list_partners

log = logging.getLogger(__name__)

MIN_EVENT_DATE = date(1900, 1, 1)
MAX_EVENT_DATE = date.today()

START_TYPES = tuple(t for t in EVENT_TYPES if t in ("PIGNORACION", "EMBARGO"))
CANCEL_TYPES = tuple(
    t for t in EVENT_TYPES
    if t in ("CANCELA_PIGNORACION", "CANCELA_EMBARGO", "LEV_GRAVAMEN", "ALZAMIENTO")
)

def _partners_maps(company_id: int):
    partners = list_partners(company_id)
    choices = [p["id"] for p in partners]
    labels = {p["id"]: f'{p["id"]} – {p["nombre"]} ({p.get("nif") or "-"})' for p in partners}
    names  = {p["id"]: p["nombre"] for p in partners}
    return choices, labels, names

def _to_date_or_none(s: str | None) -> date | None:
    if not s:
        return None
    try:
        return datetime.strptime(s, "%Y-%m-%d").date()
    except Exception:
        return None

def _reset_edit_state():
    st.session_state["ev_id"]   = 0
    st.session_state["ev_tipo"] = (EVENT_TYPES or ["OTRO"])[0]
    st.session_state["ev_fecha"] = None
    st.session_state["ev_st"] = None
    st.session_state["ev_sa"] = None
    st.session_state["ev_rd"] = 0
    st.session_state["ev_rh"] = 0
    st.session_state["ev_np"] = 0
    st.session_state["ev_nvn"] = 0.0
    st.session_state["ev_doc"] = ""
    st.session_state["ev_obs"] = ""

def render(company_id: int):
    st.subheader("Eventos")

    if st.session_state.get("ev_form_reset", False):
        _reset_edit_state()
        st.session_state["ev_form_reset"] = False
    if "ev_id" not in st.session_state:
        _reset_edit_state()

    with st.expander("🔎 Filtros"):
        colf1, colf2 = st.columns(2)
        with colf1:
            f_desde = st.date_input("Desde", value=None, format="YYYY-MM-DD",
                                    min_value=MIN_EVENT_DATE, max_value=MAX_EVENT_DATE, key="ev_filter_from")
        with colf2:
            f_hasta = st.date_input("Hasta", value=None, format="YYYY-MM-DD",
                                    min_value=MIN_EVENT_DATE, max_value=MAX_EVENT_DATE, key="ev_filter_to")

    data_ui = list_events_for_ui(company_id)
    if f_desde:
        data_ui = [e for e in data_ui if e["fecha"] and e["fecha"] >= f_desde.isoformat()]
    if f_hasta:
        data_ui = [e for e in data_ui if e["fecha"] and e["fecha"] <= f_hasta.isoformat()]

    cols_view = [
        "id","correlativo","fecha","tipo",
        "socio_transmite","socio_adquiere",
        "rango_desde","rango_hasta",
        "n_participaciones","nuevo_valor_nominal",
        "documento","observaciones",
    ]
    df_view = pd.DataFrame(data_ui)
    for c in cols_view:
        if c not in df_view.columns:
            df_view[c] = None
    st.dataframe(df_view[cols_view], width="stretch", hide_index=True)

    st.markdown("---")
    st.subheader("➕ Alta de evento")

    tipo_opts = list(dict.fromkeys((EVENT_TYPES or []) + ["OTRO"]))
    tipo = st.selectbox("Tipo de evento", tipo_opts, index=0, key="ev_new_tipo")

    fecha = st.date_input(
        "Fecha del evento",
        value=date.today(), format="YYYY-MM-DD",
        min_value=MIN_EVENT_DATE, max_value=MAX_EVENT_DATE,
        key="ev_new_fecha"
    ).isoformat()
    observaciones = st.text_input("Observaciones (opcional)", value="", key="ev_new_obs")
    choices, labels, _names = _partners_maps(company_id)

    def _soc_select(label: str, default=None, key:str=""):
        opts = [None] + choices
        idx = 0
        if default in choices:
            idx = opts.index(default)
        return st.selectbox(
            label, opts, index=idx,
            format_func=lambda v: "—" if v is None else labels.get(v, str(v)),
            key=key or f"ev_new_sel_{label.replace(' ', '_')}"
        )

    socio_transmite = None
    socio_adquiere = None
    rango_desde = None
    rango_hasta = None
    n_participaciones = None
    nuevo_valor_nominal = None
    documento = st.text_input("Documento (opcional)", value="", key="ev_new_doc")

    # -------- Tipos habituales --------
    if tipo in ("TRANSMISION", "SUCESION"):
        st.info("Mueve un rango de participaciones de un socio a otro.")
        socio_transmite = _soc_select("Socio transmite (origen)", key="ev_new_tran_st")
        socio_adquiere  = _soc_select("Socio adquiere (destino)", key="ev_new_tran_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="ev_new_tran_rd")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="ev_new_tran_rh")
        if st.button("Guardar evento", key="ev_new_tran_save"):
            try:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=int(socio_transmite) if socio_transmite else None,
                    socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                    rango_desde=int(rango_desde) if rango_desde else None,
                    rango_hasta=int(rango_hasta) if rango_hasta else None,
                    n_participaciones=None, nuevo_valor_nominal=None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrada (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    elif tipo in ("ALTA", "AMPL_EMISION"):
        st.info("Añade participaciones nuevas a un socio (por rangos).")
        socio_adquiere = _soc_select("Socio adquiere", key="ev_new_alta_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="alta_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="alta_hasta")
        if st.button("Guardar alta/ampliación", key="ev_new_alta_save"):
            try:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=None,
                    socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                    rango_desde=int(rango_desde) if rango_desde else None,
                    rango_hasta=int(rango_hasta) if rango_hasta else None,
                    n_participaciones=None, nuevo_valor_nominal=None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrada (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    elif tipo in ("BAJA", "RED_AMORT"):
        st.info("Reduce participaciones de un socio (por rangos).")
        socio_transmite = _soc_select("Socio transmite (titular)", key="ev_new_baja_st")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="baja_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="baja_hasta")
        if st.button("Guardar baja/reducción", key="ev_new_baja_save"):
            try:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=int(socio_transmite) if socio_transmite else None,
                    socio_adquiere=None,
                    rango_desde=int(rango_desde) if rango_desde else None,
                    rango_hasta=int(rango_hasta) if rango_hasta else None,
                    n_participaciones=None, nuevo_valor_nominal=None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrada (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    elif tipo in ("USUFRUCTO",):
        st.info("Desdobla plena propiedad en nuda propiedad (transmite) y usufructo (adquiere) para un rango.")
        socio_transmite = _soc_select("Socio titular (nuda)", key="ev_new_usuf_st")
        socio_adquiere  = _soc_select("Socio usufructuario", key="ev_new_usuf_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="usuf_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="usuf_hasta")
        if st.button("Guardar usufructo", key="ev_new_usuf_save"):
            try:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=int(socio_transmite) if socio_transmite else None,
                    socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                    rango_desde=int(rango_desde) if rango_desde else None,
                    rango_hasta=int(rango_hasta) if rango_hasta else None,
                    n_participaciones=None, nuevo_valor_nominal=None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrado (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    # -------- Gravámenes --------
    elif tipo in START_TYPES:
        st.info("Grava un rango a favor de un acreedor. El **titular** va en 'Socio transmite' y el **acreedor** en 'Socio adquiere'.")
        socio_transmite = _soc_select("Socio transmite (titular afectado)", key="ev_new_grav_st")
        socio_adquiere  = _soc_select("Acreedor / beneficiario", key="ev_new_grav_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="grav_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="grav_hasta")

        if st.button("Guardar gravamen", key="ev_new_grav_save"):
            try:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=int(socio_transmite) if socio_transmite else None,
                    socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                    rango_desde=int(rango_desde) if rango_desde else None,
                    rango_hasta=int(rango_hasta) if rango_hasta else None,
                    n_participaciones=None, nuevo_valor_nominal=None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrado (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    elif tipo in CANCEL_TYPES:
        st.info("Cancela total o parcialmente un gravamen previo. Indica el **mismo acreedor** y el **rango** a levantar.")
        socio_transmite = _soc_select("Socio transmite (titular afectado)", key="ev_new_lev_st")
        socio_adquiere  = _soc_select("Acreedor / beneficiario", key="ev_new_lev_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="lev_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="lev_hasta")

        if st.button("Guardar cancelación", key="ev_new_lev_save"):
            try:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=int(socio_transmite) if socio_transmite else None,  # titular
                    socio_adquiere=int(socio_adquiere) if socio_adquiere else None,    # acreedor
                    rango_desde=int(rango_desde) if rango_desde else None,
                    rango_hasta=int(rango_hasta) if rango_hasta else None,
                    n_participaciones=None, nuevo_valor_nominal=None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrado (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    elif tipo in ("AMPL_VALOR", "RED_VALOR"):
        st.info("Ajusta el valor nominal (obligatorio en estos tipos).")
        nuevo_valor_nominal = st.number_input(
            "Nuevo valor nominal (€)",
            min_value=0.0, step=0.01, value=0.0, format="%.2f",
            key="ev_new_nvn_change"
        )
        if st.button("Guardar cambio de valor nominal", key="ev_new_nvn_save"):
            try:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=None, socio_adquiere=None,
                    rango_desde=None, rango_hasta=None,
                    n_participaciones=None,
                    nuevo_valor_nominal=float(nuevo_valor_nominal) if nuevo_valor_nominal else None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrado (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    elif tipo == "REDENOMINACION":
        st.info(
            "La REDENOMINACIÓN se aplica al cierre del día y no altera el % por socio. "
            "Puedes: (a) Global (constancia), (b) Global con recálculo del nº (VN>0 y capital múltiplo), "
            "(c) Por bloque (RD–RH) para compactar/renumerar un bloque)."
        )
        por_bloque = st.toggle("Por bloque (usar RD–RH y socio titular)", value=False, key="ev_new_reden_block")
        recalcular_num = st.toggle("Recalcular nº de participaciones (modo global)", value=False, disabled=por_bloque, key="ev_new_reden_recalc_toggle")

        choices, labels, _ = _partners_maps(company_id)
        socio_bloque = None
        rd = rh = None
        if por_bloque:
            socio_bloque = st.selectbox(
                "Socio (titular del bloque)",
                [None] + choices, index=0,
                format_func=lambda v: "—" if v is None else labels.get(v, str(v)),
                key="ev_new_reden_soc"
            )
            c1, c2 = st.columns(2)
            with c1:
                rd = st.number_input("Rango desde (RD)", min_value=1, step=1, value=1, key="reden_rd")
            with c2:
                rh = st.number_input("Rango hasta (RH)", min_value=int(rd or 1), step=1, value=int(rd or 1), key="reden_rh")

        if st.button("Guardar redenominación", key="ev_new_reden_save"):
            try:
                new_id = create_redenominacion(
                    company_id=company_id,
                    fecha=fecha,
                    por_bloque=bool(por_bloque),
                    socio_id=int(socio_bloque) if (por_bloque and socio_bloque) else None,
                    rango_desde=int(rd) if (por_bloque and rd) else None,
                    rango_hasta=int(rh) if (por_bloque and rh) else None,
                    recalcular_numero=bool(recalcular_num),
                    nuevo_valor_nominal=None,
                    documento=documento or None,
                    observaciones=observaciones or None,
                )
                st.success(f"REDENOMINACION registrada (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    else:  # OTRO
        st.info("Tipo libre: puedes informar cualquiera de los campos opcionalmente.")
        c1, c2 = st.columns(2)
        with c1:
            socio_transmite = _soc_select("Socio transmite (opcional)", key="ev_new_otro_st")
            rango_desde = st.number_input("Rango desde (opcional)", min_value=0, step=1, value=0, key="otro_desde")
        with c2:
            socio_adquiere = _soc_select("Socio adquiere (opcional)", key="ev_new_otro_sa")
            rango_hasta = st.number_input("Rango hasta (opcional)", min_value=0, step=1, value=0, key="otro_hasta")
        n_participaciones = st.number_input("Nº de participaciones (opcional)", min_value=0, step=1, value=0, key="ev_new_otro_np")
        if st.button("Guardar evento genérico", key="ev_new_otro_save"):
            try:
                new_id = create_event_generic(
                    company_id=company_id, tipo="OTRO", fecha=fecha,
                    socio_transmite=int(socio_transmite) if socio_transmite else None,
                    socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                    rango_desde=int(rango_desde) if rango_desde else None,
                    rango_hasta=int(rango_hasta) if rango_hasta else None,
                    n_participaciones=int(n_participaciones) if n_participaciones else None,
                    nuevo_valor_nominal=None,
                    documento=documento or None,
                    observaciones=observaciones or None,
                )
                st.success(f"Evento registrado (ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    # -------- Edición / borrado --------
    st.markdown("---")
    with st.expander("✏️ Editar / Eliminar evento", expanded=False):
        choices_full, labels_map, _ = _partners_maps(company_id)

        def safe_index(options, value, default=0):
            try:
                return options.index(value)
            except Exception:
                return default

        col_id, col_btn = st.columns([1, 1])
        with col_id:
            st.number_input("ID evento", min_value=0, step=1, key="ev_id")
        with col_btn:
            if st.button("🔎 Cargar evento"):
                eid = int(st.session_state.get("ev_id") or 0)
                if eid > 0:
                    ev = get_event(company_id, eid)
                    if ev:
                        st.session_state["ev_tipo"]  = ev.get("tipo") or (EVENT_TYPES[0] if EVENT_TYPES else "OTRO")
                        st.session_state["ev_fecha"] = _to_date_or_none(ev.get("fecha"))
                        st.session_state["ev_st"]    = int(ev["socio_transmite"]) if ev.get("socio_transmite") is not None else None
                        st.session_state["ev_sa"]    = int(ev["socio_adquiere"]) if ev.get("socio_adquiere") is not None else None
                        st.session_state["ev_rd"]    = int(ev["rango_desde"] or 0)
                        st.session_state["ev_rh"]    = int(ev["rango_hasta"] or 0)
                        st.session_state["ev_np"]    = int(ev.get("n_participaciones") or 0)
                        st.session_state["ev_nvn"]   = float(ev.get("nuevo_valor_nominal") or 0.0)
                        st.session_state["ev_doc"]   = ev.get("documento") or ""
                        st.session_state["ev_obs"]   = ev.get("observaciones") or ""
                        st.success(f"Cargado evento ID {eid}.")
                    else:
                        st.warning(f"No se encontró el evento ID {eid}.")
                else:
                    st.info("Introduce un ID > 0 para cargar.")
                st.rerun()

        tipo_opts_full = list(dict.fromkeys((EVENT_TYPES or []) + ["OTRO"]))
        col1, col2 = st.columns(2)
        with col1:
            st.selectbox(
                "Tipo",
                tipo_opts_full,
                index=safe_index(
                    tipo_opts_full,
                    st.session_state.get("ev_tipo", "OTRO"),
                    default=safe_index(tipo_opts_full, "OTRO", 0)
                ),
                key="ev_tipo"
            )
            st.date_input(
                "Fecha",
                value=st.session_state.get("ev_fecha", None),
                min_value=MIN_EVENT_DATE, max_value=MAX_EVENT_DATE,
                format="YYYY-MM-DD",
                key="ev_fecha"
            )
            st.number_input("Rango desde", min_value=0, step=1,
                            value=int(st.session_state.get("ev_rd") or 0), key="ev_rd")
            st.number_input("Rango hasta", min_value=0, step=1,
                            value=int(st.session_state.get("ev_rh") or 0), key="ev_rh")
            st.number_input("Nº de participaciones (si aplica)", min_value=0, step=1,
                            value=int(st.session_state.get("ev_np") or 0), key="ev_np")

        with col2:
            opts_soc = [None] + choices_full
            st.selectbox(
                "Socio transmite",
                opts_soc,
                index=safe_index(opts_soc, st.session_state.get("ev_st")),
                format_func=lambda v: "—" if v is None else labels_map.get(v, str(v)),
                key="ev_st"
            )
            st.selectbox(
                "Socio adquiere",
                opts_soc,
                index=safe_index(opts_soc, st.session_state.get("ev_sa")),
                format_func=lambda v: "—" if v is None else labels_map.get(v, str(v)),
                key="ev_sa"
            )
            st.number_input(
                "Nuevo valor nominal (€)",
                min_value=0.0, step=0.01, format="%.2f",
                value=float(st.session_state.get("ev_nvn") or 0.0),
                key="ev_nvn"
            )
            st.text_input("Documento", value=st.session_state.get("ev_doc",""), key="ev_doc")
            st.text_input("Observaciones", value=st.session_state.get("ev_obs",""), key="ev_obs")

        b1, b2, b3 = st.columns(3)
        with b1:
            if st.button("💾 Guardar cambios"):
                eid = int(st.session_state.get("ev_id") or 0)
                if eid <= 0:
                    st.error("Indica un ID de evento válido.")
                else:
                    try:
                        fecha_edit = (
                            st.session_state["ev_fecha"].isoformat()
                            if st.session_state.get("ev_fecha") else date.today().isoformat()
                        )
                        update_event(
                            event_id=eid,
                            company_id=company_id,
                            tipo=st.session_state.get("ev_tipo"),
                            fecha=fecha_edit,
                            socio_transmite=st.session_state.get("ev_st"),
                            socio_adquiere=st.session_state.get("ev_sa"),
                            rango_desde=(int(st.session_state.get("ev_rd") or 0) or None),
                            rango_hasta=(int(st.session_state.get("ev_rh") or 0) or None),
                            n_participaciones=(int(st.session_state.get("ev_np") or 0) or None),
                            nuevo_valor_nominal=(float(st.session_state.get("ev_nvn") or 0.0) or None),
                            documento=(st.session_state.get("ev_doc") or None),
                            observaciones=(st.session_state.get("ev_obs") or None),
                        )
                        log.info("Event updated id=%s company_id=%s", eid, company_id)
                        st.success("Evento actualizado.")
                        st.rerun()
                    except Exception as e:
                        st.error(str(e))
        with b2:
            if st.button("🗑️ Eliminar evento", disabled=(int(st.session_state.get("ev_id") or 0) == 0)):
                try:
                    eid = int(st.session_state["ev_id"])
                    delete_event(event_id=eid, company_id=company_id)
                    log.warning("Event deleted id=%s company_id=%s", eid, company_id)
                    st.success("Evento eliminado.")
                    st.session_state["ev_form_reset"] = True
                    st.rerun()
                except Exception as e:
                    st.error(str(e))
        with b3:
            if st.button("🧹 Limpiar formulario"):
                st.session_state["ev_form_reset"] = True
                st.rerun()

# ===== app/ui/pages/governance.py =====

# app/ui/pages/governance.py

from __future__ import annotations

import streamlit as st
import pandas as pd

from app.core.services.governance_service import (
    get_governance,
    save_board_member,
    migrate_firmantes_to_board,
    recompute_board_numbers,
)
from app.core.enums import GOVERNANCE_ROLES


def _reset_form_state():
    st.session_state["gov_member_id"] = 0
    st.session_state["gov_nombre"] = ""
    st.session_state["gov_cargo_sel"] = GOVERNANCE_ROLES[0] if GOVERNANCE_ROLES else "Administrador Único"
    st.session_state["gov_cargo_custom"] = ""
    st.session_state["gov_nif"] = ""
    st.session_state["gov_direccion"] = ""
    st.session_state["gov_telefono"] = ""
    st.session_state["gov_email"] = ""


def render(company_id: int):
    st.subheader("Gobernanza (Consejo)")

    # Acción rápida de recompute para esta sociedad
    col_a, col_b = st.columns([1, 3])
    with col_a:
        if st.button("↻ Recomputar correlativo (consejo)"):
            n = recompute_board_numbers(company_id)
            st.success(f"Recomputado board_no para {n} filas.")
            st.rerun()

    data = get_governance(company_id)
    organo = data.get("organo")
    board = data.get("board", [])
    source = data.get("source")

    if organo:
        st.markdown(f"**Órgano de administración:** `{organo}`")

    st.caption(f"Fuente de datos: `{source}`")

    # DataFrame del consejo (con board_no si existe)
    df = pd.DataFrame(board)
    if "board_no" in df.columns:
        df = df.rename(columns={"board_no": "Nº consejero"})
        # Orden visual por correlativo si existe
        df = df.sort_values(by=["Nº consejero", "nombre"], na_position="last")
        cols = ["Nº consejero", "id", "company_id", "nombre", "cargo", "nif", "direccion", "telefono", "email"]
        df = df[[c for c in cols if c in df.columns]]
    st.dataframe(df, width="stretch", hide_index=True)

    if source == "firmantes_json" and len(board) > 0:
        if st.button("Migrar firmantes a tabla 'board_members'"):
            inserted = migrate_firmantes_to_board(company_id)
            st.success(f"Migrados {inserted} registros a board_members.")
            st.rerun()

    st.markdown("---")

    # ---- Formulario de alta/edición ----
    with st.expander("➕ Alta / edición de consejero", expanded=True):
        if "gov_member_id" not in st.session_state:
            _reset_form_state()

        col1, col2 = st.columns(2)
        with col1:
            member_id = st.number_input("ID (0 para alta)", min_value=0, step=1, value=int(st.session_state.get("gov_member_id", 0)), key="gov_member_id")
            nombre = st.text_input("Nombre", value=st.session_state.get("gov_nombre", ""), key="gov_nombre")

            opciones = GOVERNANCE_ROLES + ["Otro…"]
            cargo_sel = st.selectbox(
                "Cargo / Rol",
                opciones,
                index=opciones.index(st.session_state.get("gov_cargo_sel", opciones[0])) if st.session_state.get("gov_cargo_sel") in opciones else 0,
                key="gov_cargo_sel"
            )
            cargo_custom = ""
            if cargo_sel == "Otro…":
                cargo_custom = st.text_input("Especifica el rol", value=st.session_state.get("gov_cargo_custom", ""), placeholder="p. ej. Vocal", key="gov_cargo_custom")

            nif = st.text_input("NIF/NIE", value=st.session_state.get("gov_nif", ""), key="gov_nif")

        with col2:
            direccion = st.text_input("Dirección", value=st.session_state.get("gov_direccion", ""), key="gov_direccion")
            telefono = st.text_input("Teléfono", value=st.session_state.get("gov_telefono", ""), key="gov_telefono")
            email = st.text_input("Email", value=st.session_state.get("gov_email", ""), key="gov_email")

        cargo_final = (cargo_custom.strip() if cargo_sel == "Otro…" else cargo_sel).strip()

        b1, b2 = st.columns(2)
        with b1:
            if st.button("💾 Guardar consejero", use_container_width=True):
                try:
                    fid = int(member_id) if member_id else None
                    new_id = save_board_member(
                        id=fid,
                        company_id=company_id,
                        nombre=nombre.strip(),
                        cargo=cargo_final,
                        nif=nif.strip(),
                        direccion=(direccion or None),
                        telefono=(telefono or None),
                        email=(email or None),
                    )
                    st.success(f"Guardado consejero ID {new_id}")
                    _reset_form_state()
                    st.rerun()
                except Exception as e:
                    st.error(str(e))

        with b2:
            if st.button("🧹 Limpiar formulario", use_container_width=True):
                _reset_form_state()
                st.rerun()

# ===== app/ui/pages/imports.py =====

# app/ui/pages/imports.py
from __future__ import annotations
import logging
import io

import pandas as pd
import streamlit as st

from app.core.services.import_service import dry_run, commit, get_csv_template, DryRunRow

log = logging.getLogger(__name__)

MAX_PREVIEW_ROWS = 200  # límite de filas a mostrar en previsualización


def _rows_to_dataframe(rows: list[DryRunRow]) -> pd.DataFrame:
    """
    Construye un DataFrame amigable con columnas:
    row, ok, errores, ...campos normalizados...
    """
    out = []
    for r in rows[:MAX_PREVIEW_ROWS]:
        norm = r.normalized or {}
        out.append({
            "fila_csv": r.rownum,
            "ok": (len(r.errors) == 0),
            "errores": "; ".join(r.errors) if r.errors else "",
            **norm
        })
    return pd.DataFrame(out)


def render(company_id: int):
    st.subheader("📥 Importación CSV (beta)")

    st.markdown(
        "Carga un CSV en **UTF-8** separado por comas. Primero se realiza un **dry-run** "
        "para validar y previsualizar. Si no hay errores, podrás **confirmar la importación**."
    )

    kind = st.selectbox("Ámbito a importar", ["partners", "events"], index=0)

    # Descarga de plantillas
    ctpl1, ctpl2 = st.columns(2)
    with ctpl1:
        if st.button("📄 Descargar plantilla de este ámbito"):
            buf = get_csv_template(kind)
            st.download_button(
                "Descargar CSV de ejemplo",
                data=buf,
                file_name=f"plantilla_{kind}.csv",
                mime="text/csv",
                use_container_width=True
            )
    with ctpl2:
        st.caption("Las plantillas incluyen encabezados y 2 filas de ejemplo.")

    st.divider()

    # Subida de fichero
    up = st.file_uploader("Sube tu CSV", type=["csv"], accept_multiple_files=False, key="csv_upload")
    if not up:
        st.info("Selecciona un archivo para continuar.")
        return

    # Dry run
    st.markdown("### 1) Dry-run (validación)")
    if st.button("🔍 Validar CSV (dry-run)", use_container_width=True):
        try:
            report = dry_run(kind, company_id, up.getvalue())
            if report.errors:
                st.error("Errores globales en el archivo:")
                for e in report.errors:
                    st.write(f"• {e}")

            st.metric("Filas totales", report.total_rows)
            st.metric("Filas OK", report.ok_rows)
            st.metric("Filas con error", report.error_rows)

            df_preview = _rows_to_dataframe(report.rows)
            if not df_preview.empty:
                st.dataframe(df_preview, use_container_width=True, hide_index=True)
            else:
                st.info("No hay filas para mostrar.")

            # Guardamos en sesión las filas normalizadas OK para el commit
            st.session_state["import_last_kind"] = kind
            st.session_state["import_last_company"] = company_id
            st.session_state["import_rows_ok"] = [
                r.normalized for r in report.rows if r.errors == []
            ]
            st.session_state["import_last_errs"] = [
                (r.rownum, r.errors) for r in report.rows if r.errors
            ]

            if report.error_rows == 0 and report.ok_rows > 0:
                st.success("Dry-run sin errores. Puedes confirmar la importación más abajo.")
            elif report.error_rows > 0:
                st.warning("Hay filas con errores. Corrige tu CSV y vuelve a intentarlo.")

        except Exception as e:
            log.error("Error en dry-run import %s: %s", kind, e, exc_info=True)
            st.error(str(e))

    st.markdown("### 2) Confirmar importación")
    ok_rows = st.session_state.get("import_rows_ok", [])
    last_kind = st.session_state.get("import_last_kind")
    last_company = st.session_state.get("import_last_company")

    disabled = not (ok_rows and last_kind == kind and last_company == company_id)

    if st.button("✅ Importar (commit transaccional)", disabled=disabled, use_container_width=True):
        if disabled:
            st.info("Primero realiza un dry-run válido.")
        else:
            try:
                summary = commit(kind, company_id, ok_rows)
                if summary.errors:
                    st.error("Se produjo un error y no se importó nada.")
                    st.code("\n".join(summary.errors))
                else:
                    if kind == "partners":
                        st.success(f"Completado: insertados {summary.inserted}, actualizados {summary.updated}.")
                    else:
                        st.success(f"Completado: insertados {summary.inserted}.")
                    # Limpiar estado para evitar reimportes accidentales
                    st.session_state["import_rows_ok"] = []
            except Exception as e:
                st.error(str(e))

# ===== app/ui/pages/overview.py =====

# app/ui/pages/overview.py

from __future__ import annotations
import logging
from datetime import date
import math
import streamlit as st

from app.core.services.reporting_service import kpis as kpis_service

log = logging.getLogger(__name__)

# --------- helpers de formato (estilo ES) ---------
def _fmt_int_es(n: int | None) -> str:
    if n is None:
        return "—"
    # miles con punto
    return f"{int(n):,}".replace(",", ".")

def _fmt_eur2_es(x: float | None) -> str:
    if x is None:
        return "—"
    s = f"{x:,.2f}"
    # pasar 1,234,567.89 -> 1.234.567,89
    s = s.replace(",", "·").replace(".", ",").replace("·", ".")
    return f"{s} €"

def _fmt_eur_compacto(x: float | None) -> str:
    """Formatea € en unidades compactas: K / M / B (con coma decimal)."""
    if x is None:
        return "—"
    a = abs(x)
    if a < 1_000:
        s = f"{x:.0f}"
        return _fmt_eur2_es(float(s)).replace(",00 €", " €")  # 999 €
    units = [(1_000_000_000, "B"), (1_000_000, "M"), (1_000, "K")]
    for base, suf in units:
        if a >= base:
            val = x / base
            s = f"{val:.2f}"
            s = s.replace(".", ",")  # coma decimal
            # quitar ceros finales innecesarios
            s = s.rstrip("0").rstrip(",")
            return f"{s} {suf}€"
    return _fmt_eur2_es(x)

def render(company_id: int | None):
    st.subheader("Resumen")

    if not company_id:
        st.write("Elige una sociedad en la barra lateral para comenzar.")
        return

    # Filtro de fecha simple para los KPIs
    as_of = st.date_input("A fecha", value=date.today(), format="YYYY-MM-DD").isoformat()

    # KPIs principales
    try:
        _k = kpis_service(company_id, as_of)
    except Exception as e:
        st.error(f"No fue posible calcular los KPIs: {e}")
        return

    st.markdown("### Indicadores clave")
    c1, c2, c3, c4, c5 = st.columns(5)

    c1.metric("Socios con saldo", str(_k.num_partners))
    c2.metric("Participaciones", _fmt_int_es(_k.total_shares))
    c3.metric("Nominal", _fmt_eur2_es(_k.share_nominal).replace(" €", ""))  # queda “1,00” limpio
    c4.metric("Capital", _fmt_eur_compacto(_k.share_capital))
    c5.metric("Último apunte", _k.last_event_date or "—")

    # Nota con el valor exacto de capital para quien lo necesite
    if _k.share_capital is not None:
        st.caption(f"Capital exacto: {_fmt_eur2_es(_k.share_capital)}")
    st.caption(f"Datos calculados a {as_of}.")

# ===== app/ui/pages/partners.py =====

# app/ui/partners.py
from __future__ import annotations
import streamlit as st
import pandas as pd
import logging
from datetime import date, datetime

from app.core.services.partners_service import list_partners, save_partner
from app.core.repositories.partners_repo import get_partner, list_by_company
from app.core.services.reporting_service import active_encumbrances_affecting_partner as enc_aff
from app.infra.db import get_connection                     # delete simple

log = logging.getLogger(__name__)

MIN_PERSON_DATE = date(1900, 1, 1)
MAX_PERSON_DATE = date.today()

# ---------------- helpers ----------------
def _to_date_or_none(s: str | None) -> date | None:
    if not s:
        return None
    try:
        return datetime.strptime(s, "%Y-%m-%d").date()
    except Exception:
        return None

def _delete_partner(company_id: int, partner_id: int) -> None:
    """Elimina un socio por id/compañía. (Podemos moverlo a partners_service más adelante.)"""
    with get_connection() as conn:
        conn.execute("DELETE FROM partners WHERE id=? AND company_id=?", (partner_id, company_id))

def _reset_form_state():
    # Valores por defecto del formulario
    st.session_state["pa_id"] = 0
    st.session_state["pa_nombre"] = ""
    st.session_state["pa_nif"] = ""
    st.session_state["pa_dom"] = ""
    st.session_state["pa_nac"] = ""
    st.session_state["pa_fecha"] = None

# ---------------- UI ---------------------
def render(company_id: int):
    st.subheader("Socios")

    # ---- estado inicial y “pendientes” (ANTES de dibujar widgets) ----
    if "pa_id" not in st.session_state:
        _reset_form_state()
    if "pa_id_pending" not in st.session_state:
        st.session_state["pa_id_pending"] = None
    if "pa_form_reset" not in st.session_state:
        st.session_state["pa_form_reset"] = False

    # aplica pa_id_pending en el arranque del render y límpialo
    if st.session_state["pa_id_pending"] is not None:
        st.session_state["pa_id"] = int(st.session_state["pa_id_pending"])
        st.session_state["pa_id_pending"] = None

    # reset solicitado en el ciclo anterior
    if st.session_state.get("pa_form_reset", False):
        _reset_form_state()
        st.session_state["pa_form_reset"] = False

    # Listado socios
    try:
        rows = list_by_company(company_id) if company_id else []
    except Exception as e:
        log.error("Error listando socios: %s", e)
        rows = []

    # Columnas base
    base_cols = ["id", "company_id", "nombre", "nif", "domicilio", "nacionalidad", "fecha_nacimiento_constitucion"]

    if rows and "partner_no" in rows[0]:
        cols = ["partner_no"] + base_cols
    else:
        cols = base_cols

    df = pd.DataFrame(rows)
    # Asegura que todas las columnas existen
    for c in cols:
        if c not in df.columns:
            df[c] = None

    # Reordena y renombra
    df = df[cols]
    if "partner_no" in df.columns:
        df = df.rename(columns={"partner_no": "Nº socio"})

    st.dataframe(df, use_container_width=True, hide_index=True)

    st.markdown("---")
    with st.expander("➕ Alta / edición de socio", expanded=True):
        # Fila ID + cargar
        col_id, col_btn = st.columns([1, 1])
        with col_id:
            st.number_input("ID (0 para alta)", min_value=0, step=1, key="pa_id")
        with col_btn:
            if st.button("🔎 Cargar datos"):
                pid = int(st.session_state.get("pa_id") or 0)
                if pid > 0:
                    row = get_partner(company_id, pid)
                    if row:
                        st.session_state["pa_nombre"] = row.get("nombre") or ""
                        st.session_state["pa_nif"] = row.get("nif") or ""
                        st.session_state["pa_dom"] = row.get("domicilio") or ""
                        st.session_state["pa_nac"] = row.get("nacionalidad") or ""
                        st.session_state["pa_fecha"] = _to_date_or_none(row.get("fecha_nacimiento_constitucion"))
                        st.success(f"Cargado socio ID {pid}.")
                    else:
                        st.warning(f"No se encontró el socio ID {pid}.")
                else:
                    st.info("Introduce un ID > 0 para cargar.")
                st.rerun()

        # Campos (usan session_state como única fuente de verdad)
        col1, col2 = st.columns(2)
        with col1:
            st.text_input("Nombre", key="pa_nombre")
            st.text_input("NIF/NIE/CIF", key="pa_nif")
            st.text_input("Domicilio", key="pa_dom")
        with col2:
            st.text_input("Nacionalidad", key="pa_nac")
            st.date_input(
                "Fecha nacimiento / constitución",
                min_value=MIN_PERSON_DATE, max_value=MAX_PERSON_DATE,
                format="YYYY-MM-DD", key="pa_fecha"
            )

        # Botonera
        bA, bB, bC = st.columns([1, 1, 1])
        with bA:
            if st.button("💾 Guardar socio"):
                fid = int(st.session_state.get("pa_id") or 0) or None
                fecha_iso = st.session_state["pa_fecha"].isoformat() if st.session_state.get("pa_fecha") else None
                new_id = save_partner(
                    id=fid,
                    company_id=company_id,
                    nombre=st.session_state.get("pa_nombre", "").strip(),
                    nif=st.session_state.get("pa_nif", "").strip(),
                    domicilio=(st.session_state.get("pa_dom", "").strip() or None),
                    nacionalidad=(st.session_state.get("pa_nac", "").strip() or None),
                    fecha_nacimiento_constitucion=fecha_iso
                )
                log.info("Partner saved id=%s company_id=%s", new_id, company_id)
                st.success(f"Guardado socio ID {new_id}")
                st.session_state["pa_id_pending"] = int(new_id)
                st.rerun()

        with bB:
            if st.button("🗑️ Eliminar socio", disabled=(int(st.session_state.get("pa_id") or 0) == 0)):
                pid = int(st.session_state["pa_id"])
                try:
                    _delete_partner(company_id, pid)
                    log.warning("Partner deleted id=%s company_id=%s", pid, company_id)
                    st.success(f"Socio {pid} eliminado.")
                    st.session_state["pa_form_reset"] = True
                except Exception as e:
                    st.error(f"No se pudo eliminar: {e}")
                st.rerun()

        with bC:
            if st.button("🧹 Limpiar formulario"):
                st.session_state["pa_form_reset"] = True
                st.rerun()

# ===== app/ui/pages/reports.py =====

# app/ui/pages/reports.py
from __future__ import annotations
import streamlit as st
import pandas as pd
import logging
import sqlite3
import datetime as dt
from pathlib import Path

log = logging.getLogger(__name__)

from app.infra.db import get_connection
from app.core.services.reporting_service import (
    cap_table, kpis, movements, event_timeline, partner_position,
    partner_holdings_ranges, active_encumbrances_affecting_partner as active_encumbrances_aff,
    capital_timeline,
)
from app.core.services.export_service import (
    export_cap_table_excel, export_movements_excel, export_partner_certificate_pdf,
    export_ledger_pdf_legalizable, export_ledger_excel_legalizable,
)

# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------
def _event_types() -> list[str]:
    with get_connection() as conn:
        rows = conn.execute("SELECT DISTINCT tipo FROM events ORDER BY tipo").fetchall()
    return [r[0] for r in rows if r and r[0]]

def _as_of_state_key() -> str:
    return "rep_global_as_of"

def _get_global_as_of_iso() -> str:
    """Obtiene 'A fecha' global desde session_state en ISO (YYYY-MM-DD)."""
    if _as_of_state_key() not in st.session_state:
        st.session_state[_as_of_state_key()] = dt.date.today()
    return st.session_state[_as_of_state_key()].isoformat()

# ------------------------------------------------------------
# Página
# ------------------------------------------------------------
def render(company_id: int | None = None):
    st.subheader("📊 Reporting")

    if not company_id:
        st.write("Elige una sociedad en la barra lateral para comenzar.")
        return

    # ---------- Filtro GLOBAL "A fecha" ----------
    st.markdown("#### Filtros generales")
    st.session_state[_as_of_state_key()] = st.date_input(
        "A fecha (global)",
        value=st.session_state.get(_as_of_state_key(), dt.date.today()),
        format="YYYY-MM-DD",
        key="rep_global_as_of_input",
    )
    as_of_global = _get_global_as_of_iso()
    st.caption("Este valor se utiliza en Cap table/KPIs, Detalle socio, Certificaciones y Gráficas, "
               "así como en las exportaciones asociadas.")
    st.divider()

    tabs = st.tabs([
        "Cap table & KPIs",
        "Detalle socio",
        "Movimientos",
        "Certificaciones",
        "Gráficas",
    ])

    # --------------------------------------------------------
    # 1) Cap table & KPIs
    # --------------------------------------------------------
    with tabs[0]:
        _k = kpis(company_id, as_of_global)
        colk1, colk2, colk3, colk4, colk5 = st.columns(5)
        colk1.metric("Socios con saldo", f"{_k.num_partners}")
        colk2.metric("Participaciones totales", f"{_k.total_shares:,}".replace(",", "."))
        colk3.metric("Nominal", f"{_k.share_nominal:.2f}" if _k.share_nominal is not None else "—")
        colk4.metric("Capital", f"{_k.share_capital:,.2f}".replace(",", ".") if _k.share_capital is not None else "—")
        colk5.metric("Último apunte", _k.last_event_date or "—")
        st.caption(f"Datos calculados a {as_of_global}.")

        st.markdown("#### Tabla de capitalización")
        df = cap_table(company_id, as_of_global).copy()

        # Si el servicio trae partner_no, anteponerlo y ocultar partner_id visualmente
        if "partner_no" in df.columns:
            df.rename(columns={
                "partner_no": "Nº socio",
                "partner_name": "Socio",
                "nif": "NIF",
                "classes": "Clase",
                "shares": "Participaciones",
                "capital_socio": "Capital socio (€)",
                "pct": "%"
            }, inplace=True)
            cols = [c for c in ["Nº socio", "Socio", "NIF", "Clase", "Participaciones", "Capital socio (€)", "%"] if c in df.columns]
            st.dataframe(df[cols], hide_index=True, use_container_width=True)
        else:
            st.dataframe(
                df.rename(columns={
                    "partner_id": "partner_id",
                    "partner_name": "Socio",
                    "nif": "NIF",
                    "classes": "Clase",
                    "shares": "Participaciones",
                    "capital_socio": "Capital socio (€)",
                    "pct": "%"
                }),
                hide_index=True,
                use_container_width=True
            )

        # --- Filtros para el LIBRO ---
        st.markdown("##### Libro registro – filtros")
        colf1, colf2, colf3 = st.columns([1, 1, 2])
        with colf1:
            dfrom_cap = st.date_input("Desde (libro)", value=None, format="YYYY-MM-DD", key="rep_cap_lib_from")
        with colf2:
            dto_cap = st.date_input("Hasta (libro)", value=None, format="YYYY-MM-DD", key="rep_cap_lib_to")
        with colf3:
            ev_opts_cap = _event_types()
            selected_types_cap = st.multiselect("Tipos de evento (libro)", ev_opts_cap, default=[], key="rep_cap_lib_types")

        date_from = dfrom_cap.isoformat() if dfrom_cap else None
        date_to   = dto_cap.isoformat() if dto_cap else None

        # --- Exportaciones ---
        st.markdown("##### Exportaciones")
        c1, c2, c3 = st.columns(3)
        with c1:
            if st.button("⤵️ Exportar Cap Table (Excel)", key="rep_cap_export_xlsx"):
                xls = export_cap_table_excel(company_id, as_of=as_of_global)
                st.download_button(
                    label="Descargar CapTable.xlsx",
                    data=xls.getvalue(),
                    file_name=f"cap_table_{company_id}_{as_of_global}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    use_container_width=True
                )
        with c2:
            if st.button("⤵️ Libro (PDF legalizable)", key="rep_cap_export_pdf_ledger"):
                pdf = export_ledger_pdf_legalizable(
                    company_id,
                    date_from,
                    date_to,
                    selected_types_cap or None,
                    as_of=as_of_global,                 # 👈 SIEMPRE explícito
                    diligencia_apertura=None,
                    diligencia_cierre=None,
                )
                st.download_button(
                    "Descargar LibroRegistro.pdf",
                    data=pdf.getvalue(),
                    file_name=f"libro_registro_{company_id}.pdf",
                    mime="application/pdf",
                    use_container_width=True
                )
        with c3:
            if st.button("⤵️ Libro (Excel legalizable)", key="rep_cap_export_xlsx_ledger"):
                xls_leg = export_ledger_excel_legalizable(
                    company_id,
                    date_from,
                    date_to,
                    selected_types_cap or None,
                    diligencia_apertura=None,
                    diligencia_cierre=None,
                    as_of=as_of_global,
                )
                st.download_button(
                    "Descargar LibroRegistro.xlsx",
                    data=xls_leg.getvalue(),
                    file_name=f"libro_registro_{company_id}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    use_container_width=True
                )

    # --------------------------------------------------------
    # 2) Detalle socio
    # --------------------------------------------------------
    with tabs[1]:
        st.markdown(f"#### Detalle de un socio a fecha {as_of_global}")

        # Traer partner_no si existe (NULLS LAST)
        with get_connection() as conn:
            conn.row_factory = sqlite3.Row
            have = {r["name"] for r in conn.execute("PRAGMA table_info(partners)")}
            if "partner_no" in have:
                dfp = pd.read_sql_query(
                    """SELECT id, nombre, nif, partner_no
                       FROM partners
                       WHERE company_id = ?
                       ORDER BY CASE WHEN partner_no IS NULL THEN 1 ELSE 0 END, partner_no, nombre""",
                    conn, params=(company_id,)
                )
                labels = [
                    f"{int(r['id'])} – Nº {int(r['partner_no']) if pd.notna(r['partner_no']) else '—'} – {r['nombre']} ({r['nif'] or ''})"
                    for _, r in dfp.iterrows()
                ]
            else:
                dfp = pd.read_sql_query(
                    "SELECT id, nombre, nif FROM partners WHERE company_id = ? ORDER BY nombre",
                    conn, params=(company_id,)
                )
                labels = [f"{int(r['id'])} – {r['nombre']} ({r['nif'] or ''})" for _, r in dfp.iterrows()]

        if dfp.empty:
            st.info("No hay socios en esta sociedad.")
        else:
            pick = st.selectbox("Socio", labels, index=0, key="rep_det_partner_pick")
            partner_id = int(pick.split("–", 1)[0].strip())

            # Resumen del socio
            pos = partner_position(company_id, partner_id, as_of_global)
            st.subheader("Resumen")
            cA, cB, cC = st.columns(3)
            cA.metric("Participaciones", f"{pos.get('shares',0):,}".replace(",", "."))
            cB.metric("%", f"{pos.get('pct',0.0):.4f} %")
            cC.metric("NIF", pos.get("nif") or "—")

            # Bloques de participaciones
            st.markdown("##### Bloques de participaciones")
            rangos = partner_holdings_ranges(company_id, partner_id, as_of_global)
            if rangos.empty:
                st.info("Sin bloques vigentes.")
            else:
                st.dataframe(
                    rangos.rename(columns={
                        "rango_desde": "Desde",
                        "rango_hasta": "Hasta",
                        "participaciones": "Participaciones"
                    }),
                    hide_index=True,
                    use_container_width=True
                )
                total_bloques = int(rangos["participaciones"].sum())
                st.caption(f"Suma de bloques: {total_bloques} • Total socio: {int(pos.get('shares',0))}")

            # Gravámenes
            st.markdown("### Gravámenes a la fecha (pignoraciones/embargos)")
            enc = active_encumbrances_aff(company_id, partner_id, as_of_global)

            if enc is None or enc.empty:
                enc_view = pd.DataFrame(columns=["Fecha","Tipo","A favor de","Desde","Hasta"])
            else:
                enc = enc.copy()
                enc["acreedor_nombre"] = enc.get("acreedor_nombre").fillna("").astype(str).str.strip()
                enc["acreedor_nif"]    = enc.get("acreedor_nif").fillna("").astype(str).str.strip()

                def _compose_name_nif(row):
                    nom = row["acreedor_nombre"]
                    nif = row["acreedor_nif"]
                    return f"{nom} ({nif})" if nif else nom

                enc["A favor de"] = enc.apply(_compose_name_nif, axis=1)

                enc_view = enc.rename(columns={
                    "fecha": "Fecha",
                    "tipo": "Tipo",
                    "rango_desde": "Desde",
                    "rango_hasta": "Hasta",
                })[["Fecha", "Tipo", "A favor de", "Desde", "Hasta"]]

                enc_view["Desde"] = pd.to_numeric(enc_view["Desde"], errors="coerce")
                enc_view["Hasta"] = pd.to_numeric(enc_view["Hasta"], errors="coerce")
                enc_view = enc_view.sort_values(by=["Fecha", "Desde", "Hasta"], na_position="last").reset_index(drop=True)

            st.dataframe(enc_view, width="stretch", hide_index=True)

        # --------------------------------------------------------
        # 3) Movimientos
        # --------------------------------------------------------
        with tabs[2]:
            st.markdown("#### Filtros")
            colf1, colf2, colf3 = st.columns([1, 1, 2])

            with colf1:
                dfrom = st.date_input("Desde", value=None, format="YYYY-MM-DD", key="rep_mov_from")
            with colf2:
                dto = st.date_input("Hasta", value=None, format="YYYY-MM-DD", key="rep_mov_to")
            with colf3:
                ev_opts = _event_types()
                selected_types = st.multiselect("Tipos de evento", ev_opts, default=[], key="rep_mov_types")

            date_from = dfrom.isoformat() if dfrom else None
            date_to = dto.isoformat() if dto else None

            dfm = movements(company_id, date_from, date_to, selected_types).copy()

            # --- Normalización nombres/orden de columnas para la vista ---
            # Renombrar correlativo si existe
            if "correlativo" in dfm.columns:
                dfm.rename(columns={"correlativo": "Nº asiento"}, inplace=True)

            # Ocultamos columnas internas
            ocultas = {"id", "company_id", "correlativo"}

            # Orden recomendado
            prefer = [
                "Nº asiento", "fecha", "tipo",
                "socio_transmite", "socio_adquiere",
                "rango_desde", "rango_hasta",
                "n_participaciones", "nuevo_valor_nominal",
                "documento", "observaciones",
                "hora", "orden_del_dia",
                "created_at", "updated_at",
            ]

            # Construye la lista final sin duplicados
            cols = []
            seen = set()
            for c in prefer + [c for c in dfm.columns if c not in prefer]:
                if c in ocultas:
                    continue
                if c not in dfm.columns:
                    continue
                if c not in seen:
                    cols.append(c)
                    seen.add(c)

            st.dataframe(dfm[cols], hide_index=True, use_container_width=True)

            c1, _ = st.columns(2)
            with c1:
                if st.button("⤵️ Exportar movimientos (Excel)", key="rep_mov_export_xlsx"):
                    xls = export_movements_excel(company_id, date_from, date_to, selected_types or None)
                    st.download_button(
                        label="Descargar Movimientos.xlsx",
                        data=xls.getvalue(),
                        file_name=f"movimientos_{company_id}.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        use_container_width=True
                    )

    # --------------------------------------------------------
    # 4) Certificaciones
    # --------------------------------------------------------
    with tabs[3]:
        with st.expander(f"📜 Certificado de titularidad (a {as_of_global})", expanded=False):
            #st.markdown(f"#### Certificación de titularidad (a {as_of_global})")

            # Selector con Nº socio
            with get_connection() as conn:
                conn.row_factory = sqlite3.Row
                have = {r["name"] for r in conn.execute("PRAGMA table_info(partners)")}
                if "partner_no" in have:
                    dfp = pd.read_sql_query(
                        """SELECT id, nombre, nif, partner_no
                        FROM partners
                        WHERE company_id = ?
                        ORDER BY CASE WHEN partner_no IS NULL THEN 1 ELSE 0 END, partner_no, nombre""",
                        conn, params=(company_id,)
                    )
                    labels = [
                        f"{int(r['id'])} – Nº {int(r['partner_no']) if pd.notna(r['partner_no']) else '—'} – {r['nombre']} ({r['nif'] or ''})"
                        for _, r in dfp.iterrows()
                    ]
                else:
                    dfp = pd.read_sql_query(
                        "SELECT id, nombre, nif FROM partners WHERE company_id = ? ORDER BY nombre",
                        conn, params=(company_id,)
                    )
                    labels = [f"{int(r['id'])} – {r['nombre']} ({r['nif'] or ''})" for _, r in dfp.iterrows()]

            if dfp.empty:
                st.info("No hay socios en esta sociedad.")
            else:
                selection = st.selectbox("Socio", labels, index=0, key="rep_cert_partner_pick")
                partner_id = int(selection.split("–", 1)[0].strip())

                pos = partner_position(company_id, partner_id, as_of_global)

                cA, cB, cC, cD = st.columns(4)
                cA.metric("Participaciones", f"{pos.get('shares',0):,}".replace(",", "."))
                cB.metric("Porcentaje", f"{pos.get('pct',0.0):.4f} %")
                cC.metric("Clase", pos.get("classes") or "—")
                cD.metric("NIF", pos.get("nif") or "—")

                if st.button("⤵️ Exportar certificado (PDF)", key="rep_cert_export_pdf"):
                    pdf = export_partner_certificate_pdf(company_id, partner_id, as_of=as_of_global)
                    st.download_button(
                        label="Descargar Certificado.pdf",
                        data=pdf.getvalue(),
                        file_name=f"certificado_partner_{partner_id}_{as_of_global}.pdf",
                        mime="application/pdf",
                        use_container_width=True
                    )

        # === Certificado histórico (trayectoria socio en PDF) ===
        with st.expander("📜 Certificado histórico (trayectoria del socio)", expanded=False):
            from app.core.services.partners_service import list_partners
            from app.core.services.export_service import export_partner_history_pdf

            partners = list_partners(company_id)
            opts = [(p["id"], f'{p["id"]} – {p["nombre"]} ({p.get("nif") or "-"})') for p in partners]
            if not opts:
                st.info("No hay socios en esta sociedad.")
            else:
                sel = st.selectbox("Socio", opts, index=0, format_func=lambda t: t[1])  # (id, label)
                pid = sel[0]

                c1, c2 = st.columns(2)
                with c1:
                    d_from = st.date_input("Desde (opcional)", value=None, format="YYYY-MM-DD", key="hist_from")
                with c2:
                    d_to = st.date_input("Hasta (opcional)", value=None, format="YYYY-MM-DD", key="hist_to")

                if st.button("🖨️ Generar PDF", use_container_width=True, key="btn_hist_pdf"):
                    try:
                        pdf = export_partner_history_pdf(
                            company_id=company_id,
                            partner_id=int(pid),
                            date_from=(d_from.isoformat() if d_from else None),
                            date_to=(d_to.isoformat() if d_to else None),
                        )
                        st.success("Certificado generado.")
                        st.download_button(
                            "⬇️ Descargar certificado",
                            data=pdf.getvalue(),
                            file_name=f"certificado_historico_partner_{pid}.pdf",
                            mime="application/pdf",
                            use_container_width=True
                        )
                    except Exception as e:
                        st.error(f"Error generando el PDF: {e}")

    # --------------------------------------------------------
    # 5) Gráficas
    # --------------------------------------------------------
    with tabs[4]:
        st.markdown(f"#### Evolución de participaciones y capital social (hasta {as_of_global})")

        tl = event_timeline(company_id, as_of_global)
        if tl.empty:
            st.info("No hay datos para graficar participación acumulada.")
        else:
            st.subheader("Participaciones acumuladas")
            tl_plot = tl.copy()
            tl_plot["date"] = pd.to_datetime(tl_plot["date"])
            st.line_chart(
                tl_plot.set_index("date")["total_shares_acum"],
                use_container_width=True
            )

        st.divider()

        cl = capital_timeline(company_id, as_of_global)
        if cl.empty:
            st.info("No hay datos para graficar capital social.")
        else:
            st.subheader("Capital social (€)")
            cl_plot = cl.copy()
            cl_plot["date"] = pd.to_datetime(cl_plot["date"])
            st.line_chart(
                cl_plot.set_index("date")["capital_social"],
                use_container_width=True
            )

# Hook para routing
def main():
    render()

if __name__ == "__main__":
    render()

# ===== app/ui/pages/utilities.py =====

# app/ui/pages/utilities.py
from __future__ import annotations
import logging
from pathlib import Path
from datetime import datetime
from io import BytesIO
import streamlit as st

from app.core.services.backup_service import (
    create_backup, list_backups, restore_backup, BK_DIR
)
from app.core.services.maintenance_service import (
    db_quick_summary, db_integrity_check, db_fk_check,
    run_analyze, run_reindex, run_vacuum,
    recompute_correlativos, ensure_min_indexes,
)
from app.core.services.normalization_service import run_normalization  # 👈 NUEVO

from app.infra.db import get_connection
from app.infra.logging import LOG_FILE

# ⬇️ Importaciones (CSV)
from app.ui.pages import imports

log = logging.getLogger(__name__)

LEVELS = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]

def _read_tail(path: Path, max_lines: int) -> list[str]:
    if not path.exists():
        return []
    with path.open("r", encoding="utf-8") as f:
        lines = f.readlines()
    return lines[-max_lines:]

def render(company_id: int | None = None):
    st.subheader("🛠️ Utilidades")

    tabs = st.tabs([
        "💾 Backups",
        "🩺 Salud BD",
        "🧹 Mantenimiento",
        "📜 Logs",
        "📥 Importar CSV",
        "🧽 Normalización",
    ])

    # =========================
    # 1) BACKUPS
    # =========================
    with tabs[0]:
        st.markdown("### Copias de seguridad")
        colA, colB = st.columns([1, 2], gap="large")

        # Crear backup
        with colA:
            with st.form("form_create_backup", clear_on_submit=False):
                st.caption("Crea una copia de la base de datos actual en `data/backups/`.")
                submit = st.form_submit_button("🧩 Crear backup ahora", use_container_width=True)
                if submit:
                    try:
                        with st.status("Creando backup…", expanded=True) as status:
                            created = create_backup()
                            status.update(label="Backup creado ✅", state="complete")
                        st.success(f"Backup creado: {', '.join(p.name for p in created)}")
                        st.rerun()
                    except Exception as e:
                        log.error("Error creando backup: %s", e, exc_info=True)
                        st.error(f"Error creando backup: {e}")

        # Restaurar / descargar
        with colB:
            backups = list_backups()
            if not backups:
                st.info(f"No hay backups en `{BK_DIR}`.")
            else:
                names = [bk.name for bk in backups]
                idx_default = max(0, len(names) - 1)
                with st.form("form_restore_backup", clear_on_submit=False):
                    st.caption("Selecciona y restaura un backup existente. Se hará copia previa del actual.")
                    sel_name = st.selectbox("Backup (.db) disponible", names, index=idx_default, key="bk_pick")
                    cols = st.columns([1, 1, 2])
                    with cols[0]:
                        down = st.form_submit_button("⬇️ Descargar seleccionado")
                    with cols[1]:
                        confirm = st.text_input("Confirmación", value="", placeholder="Escribe RESTAURAR")
                    with cols[2]:
                        do_restore = st.form_submit_button(
                            "⚠️ Restaurar seleccionado",
                            disabled=(confirm != "RESTAURAR"),
                            use_container_width=True
                        )

                    if down:
                        picked = BK_DIR / sel_name
                        if picked.exists():
                            with picked.open("rb") as f:
                                st.download_button(
                                    "Descargar ahora",
                                    data=f.read(),
                                    file_name=picked.name,
                                    mime="application/octet-stream",
                                    use_container_width=True
                                )
                        else:
                            st.error("El backup seleccionado ya no existe.")

                    if do_restore:
                        try:
                            with st.status("Restaurando backup…", expanded=True) as status:
                                restored = restore_backup(BK_DIR / sel_name)
                                status.update(label="Restauración completada ✅", state="complete")
                            st.success(f"Restaurado: {', '.join(p.name for p in restored)}. Reinicia la app si es necesario.")
                        except Exception as e:
                            log.error("Error restaurando backup: %s", e, exc_info=True)
                            st.error(f"Error restaurando backup: {e}")

        st.caption(f"BD activa: `{(BK_DIR.parent / 'libro_socios.db')}`  •  Carpeta de backups: `{BK_DIR}`")

    # =========================
    # 2) SALUD BD
    # =========================
    with tabs[1]:
        st.markdown("### Comprobaciones de integridad")
        c1, c2 = st.columns(2)
        with c1:
            if st.button("🔎 Comprobar integridad / FK", use_container_width=True, key="btn_check_both"):
                with st.status("Ejecutando PRAGMA integrity_check y foreign_key_check…", expanded=True) as status:
                    summary = db_quick_summary()
                    status.update(label="Comprobaciones finalizadas ✅", state="complete")
                _render_health_summary(summary)

        with c2:
            st.caption("Comprueba integridad de la BD y violaciones de claves foráneas.")

        st.divider()

        col3, col4, col5 = st.columns(3)
        with col3:
            if st.button("Solo integrity_check", use_container_width=True, key="btn_integrity"):
                msgs = db_integrity_check()
                if not msgs:
                    st.success("OK: integrity_check sin incidencias.")
                else:
                    st.error("PRAGMA integrity_check devolvió incidencias:")
                    st.code("\n".join(msgs) or "(sin detalles)")
        with col4:
            if st.button("Solo foreign_key_check", use_container_width=True, key="btn_fk"):
                fks = db_fk_check()
                if not fks:
                    st.success("OK: foreign_key_check sin incidencias.")
                else:
                    st.error("Violaciones FK:")
                    lines = [f"tabla={t} rowid={r} fk_tabla={p} fk_id={fk}" for (t, r, p, fk) in fks]
                    st.code("\n".join(lines) or "(sin detalles)")
        with col5:
            st.caption("Botones individuales por si necesitas aislar un problema.")
        
        # =========================
        # 3) CORRELATIVOS POR SOCIEDAD
        # =========================
        st.divider()
        st.markdown("### Correlativos por sociedad")

        with get_connection() as _conn:
            _conn.row_factory = lambda c, r: {c.description[i][0]: r[i] for i in range(len(r))}
            _companies = _conn.execute("SELECT id, name FROM companies ORDER BY id").fetchall()

        names = ["(Todas)"] + [f"{r['id']} – {r['name']}" for r in _companies]
        choice = st.selectbox("Sociedad", names, index=0, key="recomp_company_selector")
        selected_company_id = None
        if choice != "(Todas)":
            try:
                selected_company_id = int(choice.split(" – ")[0])
            except Exception:
                selected_company_id = None

        c1, c2, c3 = st.columns(3)
        with c1:
            chk_partners = st.checkbox("Socios (partner_no)", value=True)
        with c2:
            chk_events = st.checkbox("Eventos (correlativo)", value=True)
        with c3:
            chk_govern = st.checkbox("Gobernanza (board_no)", value=True)

        btn = st.button("↻ Recalcular correlativos", use_container_width=True)
        if btn:
            if not any([chk_partners, chk_events, chk_govern]):
                st.warning("Selecciona al menos un ámbito (Socios / Eventos / Gobernanza).")
            else:
                selected = [x for x, ok in (("partners", chk_partners), ("events", chk_events), ("governance", chk_govern)) if ok]
                if len(selected) == 3:
                    scope = "all"
                elif len(selected) == 2 and set(selected) == {"partners", "events"}:
                    scope = "both"
                else:
                    scope = selected[0]

                with st.status("Recalculando correlativos…", expanded=True) as status:
                    try:
                        res = recompute_correlativos(company_id=selected_company_id, scope=scope)
                        status.update(label="Recompute finalizado ✅", state="complete")
                        st.success(
                            f"Hecho. Socios: {res.get('partners',0)} • "
                            f"Eventos: {res.get('events',0)} • "
                            f"Gobernanza: {res.get('governance',0)}"
                        )
                    except Exception as e:
                        status.update(label="Error durante el recompute", state="error")
                        st.error(f"Error: {e}")  
        
        st.divider()
        st.markdown("### Índices SQL mínimos")
        coli1, coli2 = st.columns([1, 1])
        with coli1:
            st.code(
                "events(company_id, fecha, id)\n"
                "partners(company_id)\n"
                "(opcionales) events(company_id, correlativo), board_members(company_id)"
            )
        with coli2:
            if st.button("⚙️ Crear índices mínimos", use_container_width=True):
                try:
                    out = ensure_min_indexes()
                    st.success("Índices verificados ✅")
                    st.code("\n".join(out) or "(sin cambios)")
                except Exception as e:
                    st.error(f"Error creando/verificando índices: {e}")

    # =========================
    # 4) MANTENIMIENTO
    # =========================
    with tabs[2]:
        st.markdown("### Operaciones periódicas")
        with st.form("form_maintenance"):
            st.caption("Selecciona las tareas a ejecutar:")
            colx, coly, colz = st.columns(3)
            with colx:
                do_analyze = st.checkbox("ANALYZE", value=True)
            with coly:
                do_reindex = st.checkbox("REINDEX", value=False)
            with colz:
                do_vacuum = st.checkbox("VACUUM", value=False)

            run = st.form_submit_button("▶️ Ejecutar selección", use_container_width=True)

            if run:
                with st.status("Ejecutando mantenimiento…", expanded=True) as status:
                    if do_analyze:
                        status.write("• ANALYZE…"); run_analyze()
                    if do_reindex:
                        status.write("• REINDEX…"); run_reindex()
                    if do_vacuum:
                        status.write("• VACUUM…"); run_vacuum()
                    status.update(label="Mantenimiento completado ✅", state="complete")
                st.success("Operación finalizada.")

        st.caption("Sugerencias: ANALYZE tras cargas grandes; REINDEX si sospechas corrupción de índices; VACUUM para compactar.")

    # =========================
    # 5) LOGS
    # =========================
    with tabs[3]:
        st.markdown("### Visor de logs")
        if LOG_FILE.exists():
            size_kb = LOG_FILE.stat().st_size / 1024
            ts = datetime.fromtimestamp(LOG_FILE.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')
            st.caption(f"Ruta: `{LOG_FILE}` • Tamaño: {size_kb:.1f} KB • Últ. modif: {ts}")
        else:
            st.info(f"No se encontró el log en: {LOG_FILE}")

        with st.form("form_logs"):
            colA, colB, colC, colD = st.columns([1, 1.2, 1, 2])
            with colA:
                max_lines = st.number_input("Líneas", min_value=50, max_value=10000, value=500, step=50, key="log_lines")
            with colB:
                levels = st.multiselect("Niveles", LEVELS, default=["INFO", "WARNING", "ERROR", "CRITICAL"], key="log_levels")
            with colC:
                regex_mode = st.toggle("Regex", value=False, key="log_regex")
            with colD:
                query = st.text_input("Buscar", value="", placeholder=("expresión regular" if regex_mode else "contiene…"), key="log_query")

            submitted = st.form_submit_button("🔄 Mostrar / refrescar", use_container_width=True)

        if submitted and LOG_FILE.exists():
            lines = _read_tail(LOG_FILE, max_lines)

            def _keep(line: str) -> bool:
                if levels and not any(f" {lvl} " in line for lvl in levels):
                    return False
                if query:
                    if regex_mode:
                        import re
                        try:
                            return re.search(query, line, flags=re.IGNORECASE) is not None
                        except re.error:
                            return False
                    else:
                        return query.lower() in line.lower()
                return True

            filtered = [ln for ln in lines if _keep(ln)]
            st.text("".join(filtered) if filtered else "(sin resultados)")

            if filtered:
                buf = BytesIO("".join(filtered).encode("utf-8"))
                st.download_button(
                    "⬇️ Descargar líneas mostradas",
                    data=buf.getvalue(),
                    file_name="app_log_filtrado.txt",
                    mime="text/plain",
                    use_container_width=True
                )
        elif submitted and not LOG_FILE.exists():
            st.warning("No hay archivo de log para mostrar.")

    # =========================
    # 6) IMPORTACIONES (CSV)
    # =========================
    with tabs[4]:
        imports.render(company_id)

    # =========================
    # 7) NORMALIZACIÓN AVANZADA
    # =========================
    with tabs[5]:
        st.markdown("### Normalización avanzada")
        st.caption("Limpia nombres (espacios, mayúsculas/minúsculas, partículas) y NIF/NIE/CIF. Puedes ejecutar en modo ‘dry-run’ para ver ejemplos sin escribir.")

        col_top1, col_top2 = st.columns([1, 1])
        with col_top1:
            scope = st.selectbox("Ámbito", ["both", "partners", "governance"], index=0, help="Dónde aplicar la normalización.")
        with col_top2:
            selected_company = company_id if company_id else None
            st.text_input("Sociedad (id)", value=str(selected_company or ""), disabled=True, help="Se usa la sociedad seleccionada en la barra lateral.")

        col_opt1, col_opt2, col_opt3 = st.columns(3)
        with col_opt1:
            fix_name = st.checkbox("Corregir nombres", value=True)
        with col_opt2:
            fix_nif = st.checkbox("Corregir NIF/NIE/CIF", value=True)
        with col_opt3:
            remove_accents = st.checkbox("Quitar tildes", value=False, help="⚠️ Úsalo solo si quieres nombres sin tildes.")

        dry = st.toggle("Dry-run (simular sin escribir)", value=True)
        if st.button("🚿 Ejecutar normalización", use_container_width=True):
            try:
                res = run_normalization(
                    company_id=selected_company,
                    scope=scope, fix_name=fix_name, fix_nif=fix_nif,
                    remove_accents=remove_accents, dry_run=dry, sample_limit=30
                )
                st.success("Normalización simulada." if dry else "Normalización aplicada.")
                st.json({
                    "resumen": {
                        "partners_cambiados": res["partners"]["changed"],
                        "gobernanza_cambiados": res["governance"]["changed"],
                        "dry_run": res["dry_run"]
                    }
                })
                with st.expander("Muestra de cambios (partners)"):
                    st.json(res["partners"]["samples"])
                with st.expander("Muestra de cambios (gobernanza)"):
                    st.json(res["governance"]["samples"])
            except Exception as e:
                st.error(f"Error en normalización: {e}")
        
        # --- Columnas auxiliares (denormalizadas) ---
        st.markdown("##### Columnas auxiliares (si existen)")
        st.caption("Rellena `partners.search_name` y `partners.name_ascii` a partir de `nombre` (solo si las columnas existen).")

        c1, c2 = st.columns([1,3])
        with c1:
            do_denorm = st.button("↻ Rellenar columnas auxiliares", key="btn_denorm_fields", use_container_width=True)
        with c2:
            st.write("")

        if do_denorm:
            try:
                from app.core.services.maintenance_service import recompute_denormalized
                res = recompute_denormalized(company_id)
                msg = res.get("partners", {})
                st.success(f"partners: examinados {msg.get('examined',0)}, actualizados {msg.get('updated',0)}")
                if msg.get("details"):
                    st.json(msg["details"])
            except Exception as e:
                st.error(f"Error ejecutando el recompute: {e}")

def _render_health_summary(summary: dict):
    ok_i = summary.get("integrity_ok", False)
    ok_f = summary.get("fk_ok", False)
    c1, c2 = st.columns(2)
    with c1:
        st.metric("Integrity check", "OK" if ok_i else "ERROR")
    with c2:
        st.metric("Foreign key check", "OK" if ok_f else "ERROR")

    if not ok_i:
        st.error("PRAGMA integrity_check devolvió incidencias:")
        st.code("\n".join(summary.get("integrity_messages", [])) or "(sin detalles)")

    if not ok_f:
        st.error("Violaciones FK:")
        lines = [
            f"tabla={t} rowid={r} fk_tabla={p} fk_id={fk}"
            for (t, r, p, fk) in summary.get("fk_violations", [])
        ]
        st.code("\n".join(lines) or "(sin detalles)")

# ===== app/ui/routing.py =====

# app/ui/routing.py
from __future__ import annotations
from typing import Optional

from .pages import overview, governance, partners, events, reports, utilities, companies

def render_page(section: str, company_id: Optional[int]):
    """
    Debe coincidir EXACTAMENTE con las opciones del sidebar:
    ["Overview","Gobernanza","Socios","Eventos","Reports","Utilidades"]
    """
    match section:
        case "Overview":
            overview.render(company_id)
        case "Sociedades":
            companies.render(company_id)
        case "Gobernanza":
            governance.render(company_id)
        case "Socios":
            partners.render(company_id)
        case "Eventos":
            events.render(company_id)
        case "Reports":
            reports.render(company_id)
        case "Utilidades":
            utilities.render(company_id)
        case _:
            # Fallback explícito por si llegase un valor no esperado
            overview.render(company_id)

# ===== tests/conftest.py =====

# tests/conftest.py
import sys
import sqlite3
from pathlib import Path
import pytest

# --- AÑADE LA RAÍZ DEL REPO AL sys.path ---
# tests/ está en <repo>/tests → la raíz es parent
REPO_ROOT = Path(__file__).resolve().parent.parent
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

# --- FIXTURE: conexión SQLite en memoria compartida ---
@pytest.fixture()
def inmemory_conn():
    """
    Conexión SQLite en memoria compartida para un módulo concreto.
    Devolvemos siempre la MISMA conexión (yield) para que el esquema persista
    a lo largo del test.
    """
    conn = sqlite3.connect(":memory:")
    conn.execute("PRAGMA foreign_keys = ON")
    try:
        yield conn
    finally:
        conn.close()

# ===== tests/test_enums.py =====

# tests/test_enums.py
from app.core.enums import normalize_event_type, EVENT_TYPE_ALIASES
from app.core.services.governance_service import _normalize_role

def test_normalize_event_type_aliases():
    # sanity: alias deben resolver al canónico
    assert normalize_event_type("trasmision") == "TRANSMISION"
    assert normalize_event_type("REDENOM") == "REDENOMINACION"
    assert normalize_event_type("ALZAMIENTO_DE_EMBARGO") == "ALZAMIENTO"
    # canónico ya correcto
    assert normalize_event_type("BAJA") == "BAJA"
    # None / vacío
    assert normalize_event_type(None) is None

def test_governance_role_aliases_titlecase_and_alias():
    # alias en snake/lower -> canónico
    assert _normalize_role("administrador_unico") == "Administrador Único"
    assert _normalize_role("consejero_delegado") == "Consejero Delegado"
    # ya canónico se mantiene
    assert _normalize_role("Presidente") == "Presidente"
    # si no hay mapping, devolver lo recibido (no perder dato)
    assert _normalize_role("Vocal") == "Vocal"

# ===== tests/test_normalization.py =====

# tests/test_normalization.py
from app.core.services.normalization_service import build_search_name, build_name_ascii
from app.core.validators import normalize_nif_cif  # asumiendo que ya existe

def test_build_search_name_basic():
    assert build_search_name("  José  Pérez  ") == "jose perez"
    assert build_search_name("ÁLICE S.L.") == "alice s.l."

def test_build_name_ascii_basic():
    assert build_name_ascii("  José  Pérez  ") == "jose perez"
    assert build_name_ascii("ÁLICE, S.L.") == "alice sl"

def test_normalize_nif_basic():
    # Casos ilustrativos; adapta a tu lógica real de validators.py
    assert normalize_nif_cif("  b12345678 ") == "B12345678"
    assert normalize_nif_cif("a-11111111") == "A11111111"

# ===== tests/test_normalization_denorm.py =====

# tests/test_normalization_denorm.py
import types
import sqlite3
from app.core.services import normalization_service as ns

def _setup_schema(conn: sqlite3.Connection):
    conn.executescript("""
    CREATE TABLE partners (
        id INTEGER PRIMARY KEY,
        company_id INTEGER NOT NULL,
        nombre TEXT,
        search_name TEXT,
        name_ascii TEXT
    );
    """)
    conn.commit()

def test_recompute_denormalized(monkeypatch, inmemory_conn):
    _setup_schema(inmemory_conn)
    cur = inmemory_conn.cursor()
    # Inserta nombres con tildes/ruido
    cur.executemany(
        "INSERT INTO partners (id, company_id, nombre, search_name, name_ascii) VALUES (?, ?, ?, ?, ?)",
        [
            (1, 10, "  José   Pérez  ", None, None),
            (2, 10, "ÁLICE, S.L.",    None, None),
            (3, 11, None,             None, None),  # nombre vacío -> no cambia
        ],
    )
    inmemory_conn.commit()

    # monkeypatch del get_connection usado EN ESTE MÓDULO
    def _fake_get_connection():
        return inmemory_conn
    monkeypatch.setattr(ns, "get_connection", _fake_get_connection, raising=True)

    # Ejecuta para company_id=10 (no debe tocar la 11)
    out = ns.recompute_denormalized(company_id=10)
    part = out["partners"]
    assert part["examined"] == 2  # solo company_id=10
    assert part["updated"] >= 1
    # Muestras razonables
    assert isinstance(part["details"], list)
    assert len(part["details"]) <= 25

    # Verifica resultados
    rows = inmemory_conn.execute(
        "SELECT id, search_name, name_ascii FROM partners ORDER BY id"
    ).fetchall()
    row1 = rows[0]
    row2 = rows[1]
    # id=1
    assert row1[1] == "jose perez"
    assert row1[2] == "jose perez"
    # id=2  (ojo: name_ascii elimina signos pero respeta 's.l' tras pasar por build_name_ascii)
    assert row2[1] == "alice s.l."
    assert row2[2] == "alice sl"

# ===== tests/test_validators.py =====

# tests/test_validators.py
import pytest
from app.core.validators import normalize_nif_cif

@pytest.mark.parametrize("raw,expected", [
    ("  b12345678 ", "B12345678"),
    ("a-11111111",  "A11111111"),
    ("  x1234567l", "X1234567L"),   # NIE ejemplo
    (" y-1234567-z ", "Y1234567Z"),
])
def test_normalize_nif_variants(raw, expected):
    assert normalize_nif_cif(raw) == expected