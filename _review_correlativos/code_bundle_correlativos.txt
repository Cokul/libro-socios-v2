

# >>>>>>>>>>>>> _review_correlativos/_archive/app/core/services/legacy_bridge_service.py <<<<<<<<<<<<<


"""
Bridge hacia la lógica v1 sin reescribirla.
Importa dinámicamente app.legacy_v1.services y expone funciones finas.
"""

import sys
from pathlib import Path
from importlib import import_module

# Asegura que el paquete app.legacy_v1 es importable si v2 se ejecuta desde raíz del proyecto
# (el archivo __init__.py ya está creado en app/legacy_v1)
def _legacy():
    return import_module("app.legacy_v1.services")

# ------------------- Lecturas básicas -------------------
def list_companies():
    svc = _legacy()
    with svc.get_connection() as conn:  # usa la conexión v1
        cur = conn.execute("SELECT id, name, cif FROM companies ORDER BY id")
        cols = [c[0] for c in cur.description]
        return [dict(zip(cols, row)) for row in cur.fetchall()]

def list_partners(company_id: int):
    svc = _legacy()
    with svc.get_connection() as conn:
        cur = conn.execute("SELECT id, company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion FROM partners WHERE company_id=? ORDER BY id", (company_id,))
        cols = [c[0] for c in cur.description]
        return [dict(zip(cols, row)) for row in cur.fetchall()]

def list_board(company_id: int):
    svc = _legacy()
    with svc.get_connection() as conn:
        cur = conn.execute("SELECT id, company_id, nombre, cargo, nif, direccion, telefono, email FROM board_members WHERE company_id=? ORDER BY id", (company_id,))
        cols = [c[0] for c in cur.description]
        return [dict(zip(cols, row)) for row in cur.fetchall()]

def list_events(company_id: int):
    svc = _legacy()
    with svc.get_connection() as conn:
        cur = conn.execute("SELECT id, company_id, tipo, fecha, socio_origen_id, socio_destino_id, n_participaciones, referencia FROM events WHERE company_id=? ORDER BY fecha, id", (company_id,))
        cols = [c[0] for c in cur.description]
        return [dict(zip(cols, row)) for row in cur.fetchall()]

# ------------------- Escrituras mínimas (delegando en v1 si existen) -------------------
def upsert_partner(*, id, company_id, nombre, nif, domicilio=None, nacionalidad=None, fecha_nacimiento_constitucion=None):
    svc = _legacy()
    # Si v1 ya tiene helpers para alta/edición de socio, llama a esas funciones; si no, ejecuta SQL directo
    with svc.get_connection() as conn:
        if id:
            conn.execute(
                "UPDATE partners SET nombre=?, nif=?, domicilio=?, nacionalidad=?, fecha_nacimiento_constitucion=? WHERE id=? AND company_id=?",
                (nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion, id, company_id)
            )
            return id
        else:
            cur = conn.execute(
                "INSERT INTO partners(company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion) VALUES(?,?,?,?,?,?)",
                (company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion)
            )
            return cur.lastrowid

def upsert_board_member(*, id, company_id, nombre, cargo, nif, direccion=None, telefono=None, email=None):
    svc = _legacy()
    with svc.get_connection() as conn:
        if id:
            conn.execute(
                "UPDATE board_members SET nombre=?, cargo=?, nif=?, direccion=?, telefono=?, email=? WHERE id=? AND company_id=?",
                (nombre, cargo, nif, direccion, telefono, email, id, company_id)
            )
            return id
        else:
            cur = conn.execute(
                "INSERT INTO board_members(company_id, nombre, cargo, nif, direccion, telefono, email) VALUES(?,?,?,?,?,?,?)",
                (company_id, nombre, cargo, nif, direccion, telefono, email)
            )
            return cur.lastrowid


# >>>>>>>>>>>>> _review_correlativos/_archive/app/legacy_v1/db.py <<<<<<<<<<<<<

# db.py
import sqlite3
from datetime import datetime
from config import DB_PATH


# ----------------------------- Helpers / Migrations -----------------------------

def column_exists(conn: sqlite3.Connection, table: str, column: str) -> bool:
    """
    Devuelve True si la columna existe en la tabla.
    """
    cur = conn.execute(f"PRAGMA table_info({table})")
    return any(row[1] == column for row in cur.fetchall())


def migrate_add_nacionalidad(conn: sqlite3.Connection) -> None:
    """
    Asegura la columna partners.nacionalidad y rellena valor por defecto 'Española'
    cuando esté NULL o cadena vacía.
    """
    if not column_exists(conn, "partners", "nacionalidad"):
        conn.execute("ALTER TABLE partners ADD COLUMN nacionalidad TEXT")

    # backfill seguro (sirve tanto si acabamos de crear la columna como si ya existía)
    conn.execute("""
        UPDATE partners
           SET nacionalidad = 'Española'
         WHERE nacionalidad IS NULL OR TRIM(nacionalidad) = ''
    """)


# --------------------------------- Conexión ------------------------------------

def get_connection() -> sqlite3.Connection:
    """
    Devuelve una conexión lista para usar y que:
    - Permite hilos (Streamlit re-ejecuta el script).
    - Espera si la BD está ocupada (timeout).
    - Activa foreign_keys.
    - Usa WAL para reducir bloqueos.
    """
    conn = sqlite3.connect(str(DB_PATH), check_same_thread=False, timeout=30)
    conn.row_factory = sqlite3.Row
    try:
        conn.execute("PRAGMA foreign_keys = ON;")
        conn.execute("PRAGMA journal_mode = WAL;")
        conn.execute("PRAGMA synchronous = NORMAL;")
        conn.execute("PRAGMA busy_timeout = 5000;")  # 5s extra para evitar "database is locked"
    except Exception:
        # En entornos donde PRAGMA pudiera fallar no interrumpimos la app
        pass
    return conn

# --- Esquema / Versionado ---
def ensure_schema_meta(conn: sqlite3.Connection) -> None:
    conn.execute("""
        CREATE TABLE IF NOT EXISTS schema_meta(
            id INTEGER PRIMARY KEY CHECK (id = 1),
            version INTEGER NOT NULL DEFAULT 0,
            applied_at TEXT NOT NULL
        )
    """)
    row = conn.execute("SELECT version FROM schema_meta WHERE id=1").fetchone()
    if row is None:
        conn.execute("INSERT INTO schema_meta(id, version, applied_at) VALUES (1, 0, datetime('now'))")
    conn.commit()

def get_schema_version(conn: sqlite3.Connection) -> int:
    ensure_schema_meta(conn)
    v = conn.execute("SELECT version FROM schema_meta WHERE id=1").fetchone()
    return int(v[0]) if v else 0

def set_schema_version(conn: sqlite3.Connection, new_version: int) -> None:
    conn.execute("UPDATE schema_meta SET version=?, applied_at=datetime('now') WHERE id=1", (new_version,))
    conn.commit()

# ------------------------------ Inicialización ---------------------------------

def init_db() -> None:
    """
    Inicializa la base de datos y aplica migraciones versionadas.
    Puede invocarse en cada arranque (idempotente).
    """
    with get_connection() as conn:
        cur = conn.cursor()
        # Esquema base
        with open("models.sql", "r", encoding="utf-8") as f:
            cur.executescript(f.read())
        conn.commit()

        # Asegura tabla de versionado y aplica migraciones
        ensure_schema_meta(conn)
        final_ver = apply_migrations(conn)

        # Índices (idempotentes; por si migraciones añadieron tablas/cols)
        ensure_indexes(conn)

        conn.commit()
        # Opcional: log simple en consola
        try:
            print(f"[init_db] schema version = {final_ver}")
        except Exception:
            pass


# --------------------------------- Índices -------------------------------------

def ensure_indexes(conn: sqlite3.Connection) -> None:
    """
    Crea índices necesarios para acelerar consultas habituales (solo si existen las tablas).
    """
    def table_exists(name: str) -> bool:
        r = conn.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
            (name,)
        ).fetchone()
        return r is not None

    # events
    if table_exists("events"):
        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_events_company_fecha_id
              ON events(company_id, fecha, id);
        """)

    # partners
    if table_exists("partners"):
        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_partners_company_nombre
              ON partners(company_id, nombre);
        """)

    # holdings (muy útil para joins y recálculos)
    if table_exists("holdings"):
        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_holdings_company_socio
              ON holdings(company_id, socio_id);
        """)
        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_holdings_company_estado
              ON holdings(company_id, estado);
        """)
        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_holdings_company_right_rangos
              ON holdings(company_id, right_type, rango_desde, rango_hasta);
        """)

    conn.commit()


# --------------------------- Columnas / Migraciones ----------------------------

def ensure_extra_columns(conn: sqlite3.Connection) -> None:
    """
    Añade columnas opcionales y realiza migraciones ligeras:
      - companies.organo + companies.firmantes_json 
      - events.hora (TEXT)
      - events.orden_del_dia (INTEGER)
      - partners.nacionalidad (TEXT) + backfill 'Española'
    """
    
    # ---- companies.organo + companies.firmantes_json ----
    cols_comp = {row[1] for row in conn.execute("PRAGMA table_info(companies)").fetchall()}
    if "organo" not in cols_comp:
        conn.execute("ALTER TABLE companies ADD COLUMN organo TEXT DEFAULT 'admin_unico'")
    if "firmantes_json" not in cols_comp:
        conn.execute("ALTER TABLE companies ADD COLUMN firmantes_json TEXT")
    
    # ---- events.hora / events.orden_del_dia ----
    cols_events = {row[1] for row in conn.execute("PRAGMA table_info(events)").fetchall()}
    if "hora" not in cols_events:
        conn.execute("ALTER TABLE events ADD COLUMN hora TEXT;")
    if "orden_del_dia" not in cols_events:
        conn.execute("ALTER TABLE events ADD COLUMN orden_del_dia INTEGER;")

    # ---- partners.nacionalidad ----
    migrate_add_nacionalidad(conn)

    conn.commit()


# --------------------------- Utilidades de mantenimiento -----------------------

def backfill_orden_del_dia(conn: sqlite3.Connection, company_id: int) -> None:
    """
    Rellena events.orden_del_dia de forma incremental por fecha (si estaba a NULL).
    Útil para ordenar eventos en la misma fecha.
    """
    cur = conn.execute("""
        SELECT id, fecha
          FROM events
         WHERE company_id = ?
         ORDER BY fecha, id
    """, (company_id,))
    rows = cur.fetchall()

    from collections import defaultdict
    counters = defaultdict(int)

    for row in rows:
        ev_id = row["id"]
        fecha = row["fecha"]
        counters[fecha] += 1
        conn.execute(
            "UPDATE events SET orden_del_dia = ? WHERE id = ? AND orden_del_dia IS NULL",
            (counters[fecha], ev_id)
        )

    conn.commit()
    
def compact_db() -> dict:
    """
    Ejecuta wal_checkpoint(TRUNCATE) + VACUUM + ANALYZE para:
      - Consolidar el WAL y reducir tamaño.
      - Reescribir el fichero .db y desfragmentar.
      - Actualizar estadísticas de índices.
    Devuelve un dict con info básica para mostrar en UI/log.
    """
    start = datetime.now()
    # Usamos una conexión corta y aislada
    with sqlite3.connect(str(DB_PATH)) as conn:
        try:
            conn.execute("PRAGMA foreign_keys = ON;")
            conn.execute("PRAGMA journal_mode = WAL;")
            conn.execute("PRAGMA synchronous = NORMAL;")
            conn.execute("PRAGMA busy_timeout = 5000;")
        except Exception:
            pass

        cur = conn.cursor()
        # Recomendable en modo WAL antes de VACUUM
        cur.execute("PRAGMA wal_checkpoint(TRUNCATE);")
        # VACUUM debe ir fuera de transacciones activas
        cur.execute("VACUUM;")
        cur.execute("ANALYZE;")
        cur.close()

    elapsed = (datetime.now() - start).total_seconds()
    return {"ok": True, "elapsed_s": elapsed, "db_path": DB_PATH}

# -------- Migraciones numeradas (idempotentes) --------
def mig_1_add_schema_basics(conn: sqlite3.Connection) -> None:
    """
    v1:
    - Añade indices básicos si faltan (backup de ensure_indexes por si el usuario llega aquí sin ellos).
    """
    ensure_indexes(conn)  # idempotente

def mig_2_add_events_hora_orden(conn: sqlite3.Connection) -> None:
    """
    v2:
    - Asegura events.hora (TEXT) y events.orden_del_dia (INTEGER)
    """
    cols_events = {row[1] for row in conn.execute("PRAGMA table_info(events)").fetchall()}
    if "hora" not in cols_events:
        conn.execute("ALTER TABLE events ADD COLUMN hora TEXT")
    if "orden_del_dia" not in cols_events:
        conn.execute("ALTER TABLE events ADD COLUMN orden_del_dia INTEGER")

def mig_3_companies_governance(conn: sqlite3.Connection) -> None:
    """
    v3:
    - Asegura companies.organo y companies.firmantes_json
    """
    cols_comp = {row[1] for row in conn.execute("PRAGMA table_info(companies)").fetchall()}
    if "organo" not in cols_comp:
        conn.execute("ALTER TABLE companies ADD COLUMN organo TEXT DEFAULT 'admin_unico'")
    if "firmantes_json" not in cols_comp:
        conn.execute("ALTER TABLE companies ADD COLUMN firmantes_json TEXT")

def mig_4_partners_nacionalidad(conn: sqlite3.Connection) -> None:
    """
    v4:
    - Asegura partners.nacionalidad + backfill 'Española' si está NULL o vacío
    """
    migrate_add_nacionalidad(conn)

def mig_5_audit_columns(conn: sqlite3.Connection) -> None:
    """
    v5:
    - Auditoría ligera: created_at, updated_at en tablas clave (si no existen)
    - Trigger UPDATE para updated_at
    """
    def ensure_audit_for(table: str, pk: str = "id"):
        cols = {r[1] for r in conn.execute(f"PRAGMA table_info({table})").fetchall()}
        if "created_at" not in cols:
            conn.execute(f"ALTER TABLE {table} ADD COLUMN created_at TEXT")
            conn.execute(f"UPDATE {table} SET created_at = COALESCE(created_at, datetime('now'))")
        if "updated_at" not in cols:
            conn.execute(f"ALTER TABLE {table} ADD COLUMN updated_at TEXT")
            conn.execute(f"UPDATE {table} SET updated_at = COALESCE(updated_at, datetime('now'))")
        # Trigger update
        conn.execute(f"""
            CREATE TRIGGER IF NOT EXISTS trg_{table}_updated_at
            AFTER UPDATE ON {table}
            FOR EACH ROW
            BEGIN
                UPDATE {table} SET updated_at = datetime('now') WHERE {pk} = NEW.{pk};
            END;
        """)

    # Ajusta pks si fuera distinto
    ensure_audit_for("companies", "id")
    ensure_audit_for("partners", "id")
    ensure_audit_for("events", "id")
    ensure_audit_for("holdings", "id")

# --- v6: Auditoría ligera (created_at / updated_at + triggers) ---

def _ensure_audit_cols(conn: sqlite3.Connection, table: str) -> None:
    cur = conn.execute(f"PRAGMA table_info({table})")
    cols = {r[1] for r in cur.fetchall()}
    if "created_at" not in cols:
        conn.execute(f"ALTER TABLE {table} ADD COLUMN created_at TEXT")
    if "updated_at" not in cols:
        conn.execute(f"ALTER TABLE {table} ADD COLUMN updated_at TEXT")

def _backfill_audit(conn: sqlite3.Connection, table: str) -> None:
    # Rellena nulos con timestamps actuales
    conn.execute(
        f"""UPDATE {table}
               SET created_at = COALESCE(created_at, CURRENT_TIMESTAMP),
                   updated_at = COALESCE(updated_at, CURRENT_TIMESTAMP)
        """
    )

def _create_updated_at_trigger(conn: sqlite3.Connection, table: str, pk: str = "id") -> None:
    # Evita recursión: la segunda UPDATE sólo cambia updated_at -> WHEN ya no coincide
    conn.execute(f"DROP TRIGGER IF EXISTS trg_{table}_updated_at;")
    conn.executescript(f"""
    CREATE TRIGGER IF NOT EXISTS trg_{table}_updated_at
    AFTER UPDATE ON {table}
    FOR EACH ROW
    WHEN NEW.updated_at = OLD.updated_at
    BEGIN
        UPDATE {table}
           SET updated_at = CURRENT_TIMESTAMP
         WHERE {pk} = NEW.{pk};
    END;
    """)

def migrate_v6_auditoria(conn: sqlite3.Connection) -> None:
    tables = ["companies", "partners", "events", "holdings"]
    for t in tables:
        _ensure_audit_cols(conn, t)
        _backfill_audit(conn, t)
        _create_updated_at_trigger(conn, t, pk="id")
    conn.commit()

# Lista ordenada de migraciones: (versión_objetivo, función)
MIGRATIONS: list[tuple[int, callable]] = [
    (1, mig_1_add_schema_basics),
    (2, mig_2_add_events_hora_orden),
    (3, mig_3_companies_governance),
    (4, mig_4_partners_nacionalidad),
    (5, mig_5_audit_columns),
    (6, migrate_v6_auditoria),
]

def apply_migrations(conn: sqlite3.Connection) -> int:
    """
    Aplica migraciones pendientes, dentro de transacciones por versión.
    Devuelve la versión final.
    """
    ensure_schema_meta(conn)
    current = get_schema_version(conn)
    for ver, fn in MIGRATIONS:
        if ver > current:
            # Cada migración en su propia transacción: si falla, no se avanza de versión
            try:
                conn.execute("BEGIN")
                fn(conn)
                set_schema_version(conn, ver)
                conn.commit()
            except Exception as e:
                conn.rollback()
                raise RuntimeError(f"Fallo en migración v{ver}: {e}") from e
    return get_schema_version(conn)

# >>>>>>>>>>>>> _review_correlativos/_archive/app/legacy_v1/services.py <<<<<<<<<<<<<

# services.py

import sqlite3
from datetime import date, datetime
import pandas as pd
import hashlib
import json
from typing import Any, Optional, Tuple
from pathlib import Path
from config import BACKUP_DIR as CFG_BACKUP_DIR

def adapt_date_iso(val: date) -> str:
    return val.isoformat()

def adapt_datetime_iso(val: datetime) -> str:
    return val.isoformat(" ")

sqlite3.register_adapter(date, adapt_date_iso)
sqlite3.register_adapter(datetime, adapt_datetime_iso)

# --- Backups y restauración segura (SQLite online backup API) ---
BACKUP_DIR = CFG_BACKUP_DIR

def ensure_backup_dir() -> Path:
    BACKUP_DIR.mkdir(parents=True, exist_ok=True)
    return BACKUP_DIR

# Compatibilidad hacia atrás (por si algo llama aún a la privada)
_ensure_backup_dir = ensure_backup_dir

def backup_database(include_hash: bool = True) -> dict:
    """
    Crea una copia consistente del DB usando la API `Connection.backup`.
    Devuelve dict con info: {ok, path, sha256?, size_bytes}.
    """
    from db import DB_PATH  # ruta actual del .db
    ensure_backup_dir()

    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    out_path = BACKUP_DIR / f"libro_socios_{ts}.db"

    # Hacemos backup "online" (consistente) sin copiar archivos -wal/-shm
    with sqlite3.connect(str(DB_PATH)) as src, sqlite3.connect(str(out_path)) as dst:
        # si quieres feedback de progreso, puedes pasar un callback
        src.backup(dst)

        # Recomendable dejar mismas pragmas para el nuevo archivo
        try:
            dst.execute("PRAGMA journal_mode = WAL;")
            dst.execute("PRAGMA synchronous = NORMAL;")
            dst.execute("PRAGMA foreign_keys = ON;")
            dst.commit()
        except Exception:
            pass

    size = out_path.stat().st_size
    info = {"ok": True, "path": str(out_path), "size_bytes": size}

    if include_hash:
        try:
            info["sha256"] = _sha256_file(str(out_path))
        except Exception:
            info["sha256"] = None

    return info

def list_backups(limit: int | None = None) -> list[dict]:
    """
    Lista backups existentes en backups/*.db con tamaño y mtime.
    Ordena por fecha de modificación desc.
    """
    ensure_backup_dir()
    files = sorted(BACKUP_DIR.glob("*.db"), key=lambda p: p.stat().st_mtime, reverse=True)
    if limit is not None:
        files = files[:limit]
    out = []
    for p in files:
        out.append({
            "path": str(p),
            "name": p.name,
            "size_bytes": p.stat().st_size,
            "mtime": datetime.fromtimestamp(p.stat().st_mtime).isoformat(timespec="seconds"),
        })
    return out

def restore_database_from_path(backup_path: str, create_pre_restore_backup: bool = True) -> dict:
    """
    Restaura el contenido de `backup_path` sobre el DB actual usando `Connection.backup`.
    Por seguridad, puede hacer un backup previo automático.
    """
    ensure_backup_dir()
    from db import DB_PATH
    src_path = Path(backup_path)
    if not src_path.exists() or not src_path.is_file():
        return {"ok": False, "error": f"No existe el fichero: {backup_path}"}

    # Evita src == dst
    try:
        if DB_PATH.resolve() == src_path.resolve():
            return {"ok": False, "error": "No puedes restaurar desde el mismo fichero de base de datos activo."}
    except Exception:
        pass

    # Backup previo automático (por si hay que deshacer)
    pre = None
    if create_pre_restore_backup:
        try:
            pre = backup_database(include_hash=False)
        except Exception as e:
            # No abortamos, pero lo reportamos
            pre = {"ok": False, "error": f"No se pudo crear backup previo: {e}"}

    # Restauración con API de backup (no copiamos fichero; volcamos páginas)
    with sqlite3.connect(str(src_path)) as src, sqlite3.connect(str(DB_PATH)) as dst:
        # OJO: esto sobreescribe TODO el contenido de la base de datos destino
        src.backup(dst)

        # Reaplicar pragmas recomendados
        try:
            dst.execute("PRAGMA journal_mode = WAL;")
            dst.execute("PRAGMA synchronous = NORMAL;")
            dst.execute("PRAGMA foreign_keys = ON;")
            dst.commit()
        except Exception:
            pass

    return {"ok": True, "restored_from": str(src_path), "pre_backup": pre}

# ---------------- Autochequeo ----------------
def run_autochequeo() -> dict:
    """
    Ejecuta chequeos básicos de consistencia:
      - Versión actual de esquema (schema_meta).
      - Foreign keys huérfanas (PRAGMA foreign_key_check).
      - Conteos básicos de tablas clave.
    Devuelve un dict con resultados.
    """
    from db import get_connection, get_schema_version
    results = {}
    with get_connection() as conn:
        # Versión actual de esquema
        try:
            results["schema_version"] = get_schema_version(conn)
        except Exception as e:
            results["schema_version"] = f"Error: {e}"

        # FK check
        try:
            cur = conn.execute("PRAGMA foreign_key_check;")
            fk = cur.fetchall()
            cols = ["table", "rowid", "parent", "fkid"]
            results["fk_errors"] = [dict(zip(cols, r)) for r in fk] if fk else []
        except Exception as e:
            results["fk_errors"] = f"Error: {e}"

        # Conteos básicos
        counts = {}
        for table in ["companies", "partners", "events", "holdings"]:
            try:
                n = conn.execute(f"SELECT COUNT(*) FROM {table}").fetchone()[0]
                counts[table] = n
            except Exception:
                counts[table] = None
        results["counts"] = counts

    return results

# ---------------- Helpers ----------------
def _fetchall_dict(cur) -> list:
    cols = [c[0] for c in cur.description]
    return [dict(zip(cols, row)) for row in cur.fetchall()]

def _fetchone_dict(cur) -> Optional[dict]:
    row = cur.fetchone()
    if row is None:
        return None
    cols = [c[0] for c in cur.description]
    return dict(zip(cols, row))

def _get_table_columns(conn, table_name:str) -> set[str]:
    return {r[1] for r in conn.execute(f"PRAGMA table_info({table_name})").fetchall()}

def _company_exists(conn, company_id:int) -> bool:
    row = conn.execute("SELECT 1 FROM companies WHERE id=?", (company_id,)).fetchone()
    return bool(row)

def _sha256_file(path:str) -> str:
    h = hashlib.sha256()
    with open(path,"rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

def _df_para_excel(df: pd.DataFrame | None) -> pd.DataFrame | None:
    """Convierte ±inf->NaN y luego NaN/NaT->None para que XlsxWriter no reviente."""
    if df is None:
        return None
    import numpy as np
    df = df.copy()
    df.replace([np.inf, -np.inf], np.nan, inplace=True)
    # None => celda en blanco en Excel con XlsxWriter
    return df.where(pd.notnull(df), None)

# --- Vistas, triggers e índices ---
def ensure_db_consistency_primitives(conn):
    """
    Crea vistas, triggers de validación ligera e índices para mejorar
    consistencia y rendimiento. Es idempotente.
    """
    conn.executescript("""
    -- =========================
    -- VISTAS
    -- =========================

    -- Foto actual de participaciones vigentes (plena propiedad).
    CREATE VIEW IF NOT EXISTS view_participaciones_actuales AS
    SELECT
        h.company_id,
        h.socio_id,
        p.nombre AS socio_nombre,
        SUM(h.participaciones) AS participaciones
    FROM holdings h
    JOIN partners p
      ON p.id = h.socio_id AND p.company_id = h.company_id
    WHERE h.estado = 'vigente'
      AND h.right_type = 'plena'
    GROUP BY h.company_id, h.socio_id, p.nombre;

    -- Cuotas (%) por compañía con denominador = suma vigente de 'plena'
    -- (evita depender de companies.participaciones_totales si hubiera
    -- diferencias mientras editas eventos).
    CREATE VIEW IF NOT EXISTS view_cuotas_actuales AS
    WITH totales AS (
        SELECT company_id, SUM(participaciones) AS total_part
        FROM view_participaciones_actuales
        GROUP BY company_id
    )
    SELECT
        v.company_id,
        v.socio_id,
        v.socio_nombre,
        v.participaciones,
        CASE
          WHEN t.total_part > 0 THEN (1.0 * v.participaciones / t.total_part)
          ELSE 0.0
        END AS cuota
    FROM view_participaciones_actuales v
    JOIN totales t ON t.company_id = v.company_id;

    -- =========================
    -- TRIGGERS (validación ligera en EVENTS)
    -- =========================

    -- Regla común de rangos para tipos que los requieren.
    CREATE TRIGGER IF NOT EXISTS trg_events_check_range_ins
    BEFORE INSERT ON events
    WHEN NEW.tipo IN ('ALTA','AMPL_EMISION','TRANSMISION','BAJA','RED_AMORT','PIGNORACION','EMBARGO','USUFRUCTO')
    BEGIN
        SELECT
          CASE
            WHEN NEW.rango_desde IS NULL OR NEW.rango_hasta IS NULL
                 OR NEW.rango_desde < 1 OR NEW.rango_hasta < 1
                 OR NEW.rango_desde > NEW.rango_hasta
            THEN RAISE(ABORT, 'Rango Desde/Hasta inválido (>=1 y Desde <= Hasta)')
          END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_check_range_upd
    BEFORE UPDATE OF tipo, rango_desde, rango_hasta ON events
    WHEN NEW.tipo IN ('ALTA','AMPL_EMISION','TRANSMISION','BAJA','RED_AMORT','PIGNORACION','EMBARGO','USUFRUCTO')
    BEGIN
        SELECT
          CASE
            WHEN NEW.rango_desde IS NULL OR NEW.rango_hasta IS NULL
                 OR NEW.rango_desde < 1 OR NEW.rango_hasta < 1
                 OR NEW.rango_desde > NEW.rango_hasta
            THEN RAISE(ABORT, 'Rango Desde/Hasta inválido (>=1 y Desde <= Hasta)')
          END;
    END;

    -- Nominal obligatorio y > 0 para AMPL_VALOR / RED_VALOR / REDENOMINACION (si lo informas).
    CREATE TRIGGER IF NOT EXISTS trg_events_check_nominal_ins
    BEFORE INSERT ON events
    WHEN NEW.tipo IN ('AMPL_VALOR','RED_VALOR','REDENOMINACION')
    BEGIN
        SELECT
          CASE
            WHEN NEW.nuevo_valor_nominal IS NULL OR NEW.nuevo_valor_nominal <= 0
            THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0')
          END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_check_nominal_upd
    BEFORE UPDATE OF tipo, nuevo_valor_nominal ON events
    WHEN NEW.tipo IN ('AMPL_VALOR','RED_VALOR','REDENOMINACION')
    BEGIN
        SELECT
          CASE
            WHEN NEW.nuevo_valor_nominal IS NULL OR NEW.nuevo_valor_nominal <= 0
            THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0')
          END;
    END;

    -- Reglas de presencia de socios según tipo (mínimas; la lógica profunda ya la haces en Python).
    CREATE TRIGGER IF NOT EXISTS trg_events_required_parties_ins
    BEFORE INSERT ON events
    BEGIN
        -- tipos que requieren adquirente/acreedor
        SELECT CASE
          WHEN NEW.tipo IN ('ALTA','AMPL_EMISION','TRANSMISION','PIGNORACION','EMBARGO','USUFRUCTO')
               AND NEW.socio_adquiere IS NULL
          THEN RAISE(ABORT, 'Falta socio adquirente/acreedor') END;

        -- tipos que requieren transmitente/titular
        SELECT CASE
          WHEN NEW.tipo IN ('TRANSMISION','BAJA','RED_AMORT','USUFRUCTO')
               AND NEW.socio_transmite IS NULL
          THEN RAISE(ABORT, 'Falta socio transmitente/titular') END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_required_parties_upd
    BEFORE UPDATE OF tipo, socio_transmite, socio_adquiere ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('ALTA','AMPL_EMISION','TRANSMISION','PIGNORACION','EMBARGO','USUFRUCTO')
               AND NEW.socio_adquiere IS NULL
          THEN RAISE(ABORT, 'Falta socio adquirente/acreedor') END;

        SELECT CASE
          WHEN NEW.tipo IN ('TRANSMISION','BAJA','RED_AMORT','USUFRUCTO')
               AND NEW.socio_transmite IS NULL
          THEN RAISE(ABORT, 'Falta socio transmitente/titular') END;
    END;

    -- REDENOMINACION: coherencia entre modo "global" y "por rangos".
    -- Regla: o bien es GLOBAL (sin rangos y sin socios), o bien es POR RANGOS (con rangos y con al menos un socio).
    CREATE TRIGGER IF NOT EXISTS trg_events_reden_mode_ins
    BEFORE INSERT ON events
    WHEN NEW.tipo='REDENOMINACION'
    BEGIN
        SELECT CASE
          WHEN (NEW.rango_desde IS NULL AND NEW.rango_hasta IS NULL AND NEW.socio_transmite IS NULL AND NEW.socio_adquiere IS NULL)
             OR (NEW.rango_desde IS NOT NULL AND NEW.rango_hasta IS NOT NULL AND (NEW.socio_transmite IS NOT NULL OR NEW.socio_adquiere IS NOT NULL))
          THEN NULL
          ELSE RAISE(ABORT, 'REDENOMINACION: usa modo global (sin rangos y sin socios) o modo por rangos (con rangos y socio).')
        END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_reden_mode_upd
    BEFORE UPDATE OF tipo, rango_desde, rango_hasta, socio_transmite, socio_adquiere ON events
    WHEN NEW.tipo='REDENOMINACION'
    BEGIN
        SELECT CASE
          WHEN (NEW.rango_desde IS NULL AND NEW.rango_hasta IS NULL AND NEW.socio_transmite IS NULL AND NEW.socio_adquiere IS NULL)
             OR (NEW.rango_desde IS NOT NULL AND NEW.rango_hasta IS NOT NULL AND (NEW.socio_transmite IS NOT NULL OR NEW.socio_adquiere IS NOT NULL))
          THEN NULL
          ELSE RAISE(ABORT, 'REDENOMINACION: usa modo global (sin rangos y sin socios) o modo por rangos (con rangos y socio).')
        END;
    END;

    -- =========================
    -- ÍNDICES
    -- =========================
    CREATE INDEX IF NOT EXISTS idx_events_company_date ON events(company_id, fecha, id);
    CREATE INDEX IF NOT EXISTS idx_events_tipo ON events(tipo);
    CREATE INDEX IF NOT EXISTS idx_holdings_company_flags ON holdings(company_id, right_type, estado);
    CREATE INDEX IF NOT EXISTS idx_partners_company_name ON partners(company_id, nombre);
    """)
    conn.commit()
    
def patch_triggers_redenominacion(conn):
    """
    REDENOMINACION: nominal NO obligatorio (NULL permitido).
    Si se informa, debe ser > 0.
    Y el trigger de 'modo global vs por rangos' se evalúa primero.
    """
    conn.executescript("""
    DROP TRIGGER IF EXISTS trg_events_check_nominal_ins;
    DROP TRIGGER IF EXISTS trg_events_check_nominal_upd;
    DROP TRIGGER IF EXISTS trg_events_reden_mode_ins;
    DROP TRIGGER IF EXISTS trg_events_reden_mode_upd;
    DROP TRIGGER IF EXISTS trg_events_000_reden_mode_ins;
    DROP TRIGGER IF EXISTS trg_events_000_reden_mode_upd;
    DROP TRIGGER IF EXISTS trg_events_100_check_nominal_ins;
    DROP TRIGGER IF EXISTS trg_events_100_check_nominal_upd;

    -- 1) Primero: coherencia REDENOMINACION (global vs por rangos)
    CREATE TRIGGER IF NOT EXISTS trg_events_000_reden_mode_ins
    BEFORE INSERT ON events
    WHEN NEW.tipo='REDENOMINACION'
    BEGIN
        SELECT CASE
          WHEN (NEW.rango_desde IS NULL AND NEW.rango_hasta IS NULL AND NEW.socio_transmite IS NULL AND NEW.socio_adquiere IS NULL)
            OR (NEW.rango_desde IS NOT NULL AND NEW.rango_hasta IS NOT NULL AND (NEW.socio_transmite IS NOT NULL OR NEW.socio_adquiere IS NOT NULL))
          THEN NULL
          ELSE RAISE(ABORT, 'REDENOMINACION: usa modo global (sin rangos y sin socios) o modo por rangos (con rangos y socio).')
        END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_000_reden_mode_upd
    BEFORE UPDATE OF tipo, rango_desde, rango_hasta, socio_transmite, socio_adquiere ON events
    WHEN NEW.tipo='REDENOMINACION'
    BEGIN
        SELECT CASE
          WHEN (NEW.rango_desde IS NULL AND NEW.rango_hasta IS NULL AND NEW.socio_transmite IS NULL AND NEW.socio_adquiere IS NULL)
            OR (NEW.rango_desde IS NOT NULL AND NEW.rango_hasta IS NOT NULL AND (NEW.socio_transmite IS NOT NULL OR NEW.socio_adquiere IS NOT NULL))
          THEN NULL
          ELSE RAISE(ABORT, 'REDENOMINACION: usa modo global (sin rangos y sin socios) o modo por rangos (con rangos y socio).')
        END;
    END;

    -- 2) Después: nominal obligatorio SÓLO para AMPL_VALOR/RED_VALOR.
    --    En REDENOMINACION es opcional: si viene informado, debe ser > 0.
    CREATE TRIGGER IF NOT EXISTS trg_events_100_check_nominal_ins
    BEFORE INSERT ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('AMPL_VALOR','RED_VALOR')
           AND (NEW.nuevo_valor_nominal IS NULL OR NEW.nuevo_valor_nominal <= 0)
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;

        SELECT CASE
          WHEN NEW.tipo='REDENOMINACION'
           AND NEW.nuevo_valor_nominal IS NOT NULL
           AND NEW.nuevo_valor_nominal <= 0
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_100_check_nominal_upd
    BEFORE UPDATE OF tipo, nuevo_valor_nominal ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('AMPL_VALOR','RED_VALOR')
           AND (NEW.nuevo_valor_nominal IS NULL OR NEW.nuevo_valor_nominal <= 0)
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;

        SELECT CASE
          WHEN NEW.tipo='REDENOMINACION'
           AND NEW.nuevo_valor_nominal IS NOT NULL
           AND NEW.nuevo_valor_nominal <= 0
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;
    END;
    """)
    conn.commit()


# --- Accessors explícitos ---
def get_company(conn, company_id:int) -> Optional[dict]:
    cur = conn.execute("SELECT * FROM companies WHERE id=?", (company_id,))
    return _fetchone_dict(cur)

def update_company(conn, company_id:int, **fields: Any) -> int:
    """
    UPDATE companies SET k1=?, k2=? ... WHERE id=?
    Devuelve número de filas afectadas.
    """
    if not fields:
        return 0
    keys = list(fields.keys())
    sets = ", ".join([f"{k}=?" for k in keys])
    vals = [fields[k] for k in keys] + [company_id]
    cur = conn.execute(f"UPDATE companies SET {sets} WHERE id=?", vals)
    conn.commit()
    return cur.rowcount

# --- Utilidades JSON (opcional pero recomendado) ---
def normalize_json_text(text:str) -> str:
    """
    Valida que text es JSON válido y devuelve una versión canónica (compacta, UTF-8).
    Lanza ValueError si no es JSON válido.
    """
    try:
        obj = json.loads(text)
    except Exception as e:
        raise ValueError(f"JSON inválido: {e}") from e
    # compacta y mantiene acentos
    return json.dumps(obj, ensure_ascii=False, separators=(",",":"))

# --- compactar base de datos ---
def compact_database() -> Tuple[bool, str]:
    try:
        # Import local para evitar problemas de orden/circularidad en Streamlit
        from db import compact_db  # importa el símbolo exacto cuando se necesite
        info = compact_db()
        return True, f"DB compactada en {info['elapsed_s']:.2f}s"
    except Exception as e:
        return False, f"Error compactando DB: {e}"

# ---------------- Gobernanza ----------------
def set_governance(conn, company_id:int, organo:str, firmantes:list[dict]):
    conn.execute("UPDATE companies SET organo=?, firmantes_json=? WHERE id=?",
                 (organo, json.dumps(firmantes, ensure_ascii=False), company_id))

def get_governance(conn, company_id:int):
    row = conn.execute("SELECT organo, firmantes_json FROM companies WHERE id=?",
                       (company_id,)).fetchone()
    organo = (row["organo"] if row and row["organo"] else "admin_unico")
    try:
        firmantes = json.loads(row["firmantes_json"]) if row and row["firmantes_json"] else []
    except Exception:
        firmantes = []
    # normalizamos claves
    norm = []
    for f in firmantes or []:
        norm.append({
            "nombre": f.get("nombre") or f.get("name") or "",
            "rol": (f.get("rol") or f.get("role") or "").lower()
        })
    return {"organo": organo, "firmantes": norm}

# --------- Bloques (inventario por rangos) -----------
def _split_block(block: dict, d:int, h:int) -> list:
    res = []
    a, b = block['rango_desde'], block['rango_hasta']
    if h < a or d > b:
        return [block]
    if d > a:
        res.append({**block, 'rango_desde': a, 'rango_hasta': d-1,
                    'participaciones': d-1 - a + 1})
    if h < b:
        res.append({**block, 'rango_desde': h+1, 'rango_hasta': b,
                    'participaciones': b - (h+1) + 1})
    return res

def _consolidate(blocks: list) -> list:
    clean = [b for b in blocks if b.get('rango_desde') is not None and b.get('rango_hasta') is not None]
    if not clean:
        return []
    clean = sorted(clean, key=lambda x: (x['socio_id'], x['right_type'], x['rango_desde'], x['rango_hasta']))
    merged = [clean[0].copy()]
    for b in clean[1:]:
        last = merged[-1]
        if (b['socio_id']==last['socio_id'] and
            b['right_type']==last['right_type'] and
            b['rango_desde']==last['rango_hasta']+1):
            last['rango_hasta'] = b['rango_hasta']
            last['participaciones'] = last['rango_hasta'] - last['rango_desde'] + 1
        else:
            nb = b.copy()
            nb['participaciones'] = nb['rango_hasta'] - nb['rango_desde'] + 1
            merged.append(nb)
    return merged

def replace_holdings(conn, company_id:int, new_blocks:list, fecha:str):
    conn.execute("DELETE FROM holdings WHERE company_id=?", (company_id,))
    for b in new_blocks:
        conn.execute(
            "INSERT INTO holdings (company_id, socio_id, right_type, rango_desde, rango_hasta, participaciones, estado, fecha_inicio) "
            "VALUES (?,?,?,?,?,?, 'vigente', ?)",
            (company_id, b['socio_id'], b['right_type'], b['rango_desde'], b['rango_hasta'],
             b['rango_hasta']-b['rango_desde']+1, fecha)
        )
    conn.commit()

# --------- VALIDACIONES ---------
def owner_blocks(conn, company_id:int, socio_id:int, right_type:str='plena'):
    cur = conn.execute("""
        SELECT rango_desde, rango_hasta
        FROM holdings
        WHERE company_id=? AND socio_id=? AND right_type=? AND estado='vigente'
        ORDER BY rango_desde
    """, (company_id, socio_id, right_type))
    return _fetchall_dict(cur)

def _covers(blocks, d, h) -> bool:
    need = [(d, h)]
    for b in blocks:
        a, z = b['rango_desde'], b['rango_hasta']
        new_need = []
        for (x, y) in need:
            if z < x or a > y:
                new_need.append((x, y)); continue
            if a > x: new_need.append((x, a-1))
            if z < y: new_need.append((z+1, y))
        need = [(x, y) for (x, y) in new_need if x <= y]
        if not need:
            return True
    return len(need) == 0

def validate_event(conn, ev:dict) -> list:
    import pandas as _pd
    errors = []
    def nint(x):
        try:
            if x is None or (isinstance(x, float) and _pd.isna(x)): return None
            return int(x)
        except: return None

    d = nint(ev.get("rango_desde"))
    h = nint(ev.get("rango_hasta"))
    t = ev.get("tipo")
    cid = ev.get("company_id")
    stid = ev.get("socio_transmite")
    said = ev.get("socio_adquiere")

    needs_range = t in {"ALTA","AMPL_EMISION","TRANSMISION","BAJA","RED_AMORT","PIGNORACION","EMBARGO","USUFRUCTO"}
    needs_adq   = t in {"ALTA","AMPL_EMISION","TRANSMISION","PIGNORACION","EMBARGO","USUFRUCTO"}
    needs_trans = t in {"TRANSMISION","BAJA","RED_AMORT","USUFRUCTO"}

    if needs_range and (d is None or h is None or d < 1 or h < 1 or d > h):
        errors.append("Rango 'Desde/Hasta' inválido (entero ≥1 y Desde ≤ Hasta).")
    if needs_adq and said is None:
        errors.append("Falta el socio adquirente/acreedor.")
    if needs_trans and stid is None:
        errors.append("Falta el socio transmitente/titular.")
    if t in {"AMPL_VALOR","RED_VALOR"}:
        nv = ev.get("nuevo_valor_nominal")
        if nv is None or nv <= 0:
            errors.append("Indica 'Nuevo valor nominal' > 0.")

    if errors: return errors

    if t in {"ALTA","AMPL_EMISION"}:
        cur = conn.execute("""
            SELECT 1 FROM holdings
            WHERE company_id=? AND right_type='plena' AND estado='vigente'
              AND NOT (rango_hasta < ? OR rango_desde > ?)
            LIMIT 1
        """, (cid, d, h))
        if cur.fetchone():
            errors.append("El rango indicado ya está asignado en plena propiedad a otro socio.")
    elif t == "TRANSMISION":
        blocks = owner_blocks(conn, cid, stid, 'plena')
        if not _covers(blocks, d, h):
            errors.append("El socio transmitente no posee en plena propiedad todo el rango indicado.")
    elif t in {"BAJA","RED_AMORT"}:
        blocks = owner_blocks(conn, cid, stid, 'plena')
        if not _covers(blocks, d, h):
            errors.append("No se pueden amortizar participaciones que el socio no tiene en plena propiedad.")
    elif t in {"PIGNORACION","EMBARGO"}:
        cur = conn.execute("""
            SELECT 1 FROM holdings
            WHERE company_id=? AND right_type='plena' AND estado='vigente'
              AND rango_desde <= ? AND rango_hasta >= ?
            LIMIT 1
        """, (cid, d, h))
        if not cur.fetchone():
            errors.append("No existe plena propiedad sobre todo el rango indicado; no puede gravarse.")
    elif t == "USUFRUCTO":
        blocks = owner_blocks(conn, cid, stid, 'plena')
        if not _covers(blocks, d, h):
            errors.append("Para desdoblar en nuda/uso, el transmitente debe tener plena propiedad del rango.")

    return errors

# --------- Motor genérico (aplica lista de eventos) ----------
def _apply_events(events:list, valor_nominal_inicial:float=5.0, part_tot_inicial:int=0):
    """
    Aplica los eventos agrupando por fecha y ordenando dentro del día para evitar
    que se intercalen REDENOMINACION con RED_AMORT/TRANSMISION.
    Orden por día:
      1) BAJA/RED_AMORT
      2) TRANSMISION
      3) ALTA/AMPL_EMISION
      4) USUFRUCTO/PIGNORACION/EMBARGO y AMPL_VALOR/RED_VALOR
      5) REDENOMINACION (al cierre del día)
    """
    from collections import defaultdict
    from datetime import date
    from decimal import Decimal, getcontext, ROUND_FLOOR

    # Precisión alta para cálculos de % en redenominación
    getcontext().prec = 28
    D = Decimal

    blocks = []
    valor_nominal = valor_nominal_inicial
    total_part = part_tot_inicial
    last_fecha = str(date.today())

    # --- agrupar por fecha ---
    def _to_datestr(f):
        return f if isinstance(f, str) else f.strftime("%Y-%m-%d")

    by_date = defaultdict(list)
    for ev in events:
        by_date[_to_datestr(ev['fecha'])].append(ev)

    for f in sorted(by_date.keys()):
        day = by_date[f]
        last_fecha = f

        # 1) BAJA / RED_AMORT (quitan)
        for ev in sorted([e for e in day if e['tipo'] in ('BAJA','RED_AMORT')],
                         key=lambda e: ((e.get('rango_desde') or 0), (e.get('rango_hasta') or 0))):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            new_blocks = []
            for b in blocks:
                if b['right_type']=='plena' and b['socio_id']==ev['socio_transmite']:
                    new_blocks.extend(_split_block(b, d, h))
                else:
                    new_blocks.append(b)
            blocks = _consolidate(new_blocks)

        # 2) TRANSMISION (mueven)
        for ev in sorted([e for e in day if e['tipo']=='TRANSMISION'],
                         key=lambda e: ((e.get('rango_desde') or 0), (e.get('rango_hasta') or 0))):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            # quitar al transmite
            new_blocks = []
            for b in blocks:
                if b['right_type']=='plena' and b['socio_id']==ev['socio_transmite']:
                    new_blocks.extend(_split_block(b, d, h))
                else:
                    new_blocks.append(b)
            blocks = _consolidate(new_blocks)
            # poner al adquiere
            blocks.append(dict(socio_id=ev['socio_adquiere'], right_type='plena',
                               rango_desde=d, rango_hasta=h))
            blocks = _consolidate(blocks)

        # 3) ALTAS y AMPL_EMISION (añaden)
        for ev in sorted([e for e in day if e['tipo'] in ('ALTA','AMPL_EMISION')],
                         key=lambda e: ((e.get('rango_desde') or 0), (e.get('rango_hasta') or 0))):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            blocks.append(dict(socio_id=ev['socio_adquiere'], right_type='plena',
                               rango_desde=d, rango_hasta=h))
            if h:
                total_part = max(total_part, h)
            blocks = _consolidate(blocks)

        # 4) USUFRUCTO/PIGNORACION/EMBARGO + cambio de valor nominal puntual
        for ev in [e for e in day if e['tipo'] in ('USUFRUCTO','PIGNORACION','EMBARGO')]:
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            if ev['tipo'] == 'USUFRUCTO':
                new_blocks = []
                for b in blocks:
                    if b['right_type']=='plena' and b['socio_id']==ev['socio_transmite']:
                        new_blocks.extend(_split_block(b, d, h))
                    else:
                        new_blocks.append(b)
                new_blocks.append(dict(socio_id=ev['socio_transmite'], right_type='nuda',
                                       rango_desde=d, rango_hasta=h))
                new_blocks.append(dict(socio_id=ev['socio_adquiere'], right_type='usufructo',
                                       rango_desde=d, rango_hasta=h))
                blocks = _consolidate(new_blocks)
            else:
                holder = ev['socio_adquiere'] or ev['socio_transmite']
                blocks.append(dict(socio_id=holder,
                                   right_type=('prenda' if ev['tipo']=='PIGNORACION' else 'embargo'),
                                   rango_desde=d, rango_hasta=h))
                blocks = _consolidate(blocks)

        for ev in [e for e in day if e['tipo'] in ('AMPL_VALOR','RED_VALOR')]:
            valor_nominal = ev['nuevo_valor_nominal']

        # 5) REDENOMINACION (al cierre del día) — NO altera capital ni %; compacta bloques
        if any(e['tipo'] == 'REDENOMINACION' for e in day):
            # --- Totales vigentes por socio (solo 'plena') ---
            current = {}
            for b in blocks:
                if b['right_type'] != 'plena':
                    continue
                n = b['rango_hasta'] - b['rango_desde'] + 1
                current[b['socio_id']] = current.get(b['socio_id'], 0) + n

            old_total = sum(current.values())
            old_vn = D(str(valor_nominal))
            old_capital = old_vn * D(old_total)

            # VN nuevo (opcional). Si hay varios en el día, deben ser iguales.
            vn_candidates = [
                e.get('nuevo_valor_nominal') for e in day
                if e['tipo'] == 'REDENOMINACION' and e.get('nuevo_valor_nominal') not in (None, "")
            ]
            new_vn = None
            if vn_candidates:
                vals = [float(v) for v in vn_candidates]
                if len({round(v, 6) for v in vals}) > 1:
                    raise ValueError(f"Valores nominales distintos en REDENOMINACION del día {f}: {vals}")
                new_vn = D(str(vals[-1]))
                if new_vn <= 0:
                    raise ValueError(f"Nuevo valor nominal inválido en REDENOMINACION del día {f}: {new_vn}")

            # Determinar total de participaciones tras redenominación
            if new_vn is None:
                new_total = old_total  # solo compacta/renumera
            else:
                # Capital invariable: capital debe ser múltiplo del nuevo VN
                ratio = (old_capital / new_vn)
                if ratio != ratio.to_integral_value():
                    raise ValueError(
                        f"El capital {old_capital} no es múltiplo del nuevo VN {new_vn} en REDENOMINACION del día {f}."
                    )
                new_total = int(ratio)
                valor_nominal = float(new_vn)

            # Reparto proporcional (método de restos mayores) para mantener % exactos
            if old_total == 0:
                blocks = _consolidate(blocks)
                total_part = 0
            else:
                socios = sorted(current.keys())  # orden estable por socio_id
                exact = {sid: (D(current[sid]) * D(str(new_total)) / D(old_total)) for sid in socios}
                base  = {sid: int(exact[sid].to_integral_value(rounding=ROUND_FLOOR)) for sid in socios}
                asignadas = sum(base.values())
                resto = new_total - asignadas

                if resto < 0:
                    # defensa: (no debería ocurrir), quitamos 1 a los últimos hasta cuadrar
                    for sid in reversed(socios):
                        if resto == 0: break
                        if base[sid] > 0:
                            base[sid] -= 1
                            resto += 1
                elif resto > 0:
                    # repartir restos por parte fraccionaria desc.; desempate por socio_id asc
                    fracs = sorted(
                        [(sid, exact[sid] - D(base[sid])) for sid in socios],
                        key=lambda x: (x[1], -x[0]),
                        reverse=True
                    )
                    for i in range(resto):
                        base[fracs[i][0]] += 1

                # Construir bloques compactos, un bloque por socio
                cursor = 1
                new_blocks = []
                for sid in socios:
                    n = base[sid]
                    if n <= 0:
                        continue
                    new_blocks.append(dict(
                        socio_id=sid,
                        right_type='plena',
                        rango_desde=cursor,
                        rango_hasta=cursor + n - 1
                    ))
                    cursor += n

                blocks = _consolidate(new_blocks)
                total_part = new_total

        # -- Ajuste final del día: capital en circulación por suma de bloques 'plena' --
        total_part = sum(
            b['rango_hasta'] - b['rango_desde'] + 1
            for b in blocks if b['right_type'] == 'plena'
        )

    return blocks, valor_nominal, total_part, last_fecha

# --------- Recalcular y Foto Fija ----------
def recompute_company(conn: sqlite3.Connection, company_id:int):
    """
    Recalcula las participaciones de una compañía aplicando todos los eventos
    en orden cronológico robusto:
      - Por fecha
      - Por hora (si existe)
      - Por tipo de evento (BAJA/RED_AMORT -> TRANSMISION -> ALTA/AMPL_EMISION
        -> USUFRUCTO/PIGNORACION/EMBARGO/AMPL_VALOR/RED_VALOR -> REDENOMINACION)
      - Por orden_del_dia (si existe)
      - Por id (último desempate)
    """
    cur = conn.execute("""
        SELECT *
        FROM events
        WHERE company_id=?
        ORDER BY
          fecha,
          COALESCE(hora, ''),              -- primero por hora si existe
          CASE tipo
            WHEN 'BAJA'           THEN 0
            WHEN 'RED_AMORT'      THEN 0
            WHEN 'TRANSMISION'    THEN 1
            WHEN 'ALTA'           THEN 2
            WHEN 'AMPL_EMISION'   THEN 2
            WHEN 'USUFRUCTO'      THEN 3
            WHEN 'PIGNORACION'    THEN 3
            WHEN 'EMBARGO'        THEN 3
            WHEN 'AMPL_VALOR'     THEN 4
            WHEN 'RED_VALOR'      THEN 4
            WHEN 'REDENOMINACION' THEN 5
            ELSE 6
          END,
          COALESCE(orden_del_dia, 0),
          id
    """, (company_id,))
    events = _fetchall_dict(cur)

    c = conn.execute(
        "SELECT valor_nominal, participaciones_totales FROM companies WHERE id=?",
        (company_id,)
    ).fetchone()

    blocks, vn, tot, last_fecha = _apply_events(
        events,
        c[0] if c else 5.0,
        c[1] if c else 0
    )

    # Comprobación de consistencia
    total_bloques = sum(
        b['rango_hasta'] - b['rango_desde'] + 1
        for b in blocks if b['right_type'] == 'plena'
    )
    assert total_bloques == tot, f"Descuadre: bloques={total_bloques} != total_part={tot}"

    replace_holdings(conn, company_id, blocks, fecha=last_fecha)
    conn.execute(
        "UPDATE companies SET valor_nominal=?, participaciones_totales=? WHERE id=?",
        (vn, tot, company_id)
    )
    conn.commit()
    
def snapshot_socios(conn, company_id:int):
    cur = conn.execute("""
        SELECT p.id as socio_id, p.nombre, COALESCE(SUM(h.participaciones),0) as participaciones
        FROM partners p
        LEFT JOIN holdings h 
          ON h.socio_id = p.id 
         AND h.company_id = p.company_id 
         AND h.right_type='plena' 
         AND h.estado='vigente'
        WHERE p.company_id=?
        GROUP BY p.id, p.nombre
        ORDER BY p.nombre
    """, (company_id,))
    return [dict(row) for row in cur.fetchall()]

def snapshot_socios_vigentes(conn, company_id:int):
    """
    Solo socios con participaciones vigentes (plena propiedad) > 0.
    """
    cur = conn.execute("""
        SELECT p.id AS socio_id, p.nombre, SUM(h.participaciones) AS participaciones
          FROM holdings h
          JOIN partners p
            ON p.id = h.socio_id AND p.company_id = h.company_id
         WHERE h.company_id = ?
           AND h.right_type = 'plena'
           AND h.estado = 'vigente'
         GROUP BY p.id, p.nombre
         HAVING SUM(h.participaciones) > 0
         ORDER BY p.nombre
    """, (company_id,))
    return [dict(row) for row in cur.fetchall()]

def snapshot_as_of(conn: sqlite3.Connection, company_id:int, fecha_corte:str):
    """Devuelve bloques y resumen de socios a fecha de corte (sin tocar la BD)."""
    cur = conn.execute("SELECT * FROM events WHERE company_id=? AND fecha<=? ORDER BY fecha, id", (company_id, fecha_corte))
    events = _fetchall_dict(cur)
    c = conn.execute("SELECT valor_nominal, participaciones_totales FROM companies WHERE id=?", (company_id,)).fetchone()
    blocks, vn, tot, _ = _apply_events(events, c[0] if c else 5.0, c[1] if c else 0)

    data = []
    for b in blocks:
        if b['right_type']!='plena': continue
        data.append((b['socio_id'], b['rango_hasta']-b['rango_desde']+1))
    df = pd.DataFrame(data, columns=['socio_id','n'])
    if df.empty:
        resumen = pd.DataFrame(columns=['socio_id','nombre','participaciones'])
    else:
        agg = df.groupby('socio_id')['n'].sum().reset_index()
        socios = pd.read_sql_query("SELECT id as socio_id, nombre FROM partners WHERE company_id=?", conn, params=(company_id,))
        resumen = agg.merge(socios, on='socio_id', how='left')[['socio_id','nombre','n']].rename(columns={'n':'participaciones'}).sort_values('nombre')

    if blocks:
        bl = pd.DataFrame(blocks)
        socios = pd.read_sql_query("SELECT id as socio_id, nombre FROM partners WHERE company_id=?", conn, params=(company_id,))
        bl = bl.merge(socios, on='socio_id', how='left')
        bl['participaciones'] = bl['rango_hasta'] - bl['rango_desde'] + 1
        bl = bl[['socio_id','nombre','right_type','rango_desde','rango_hasta','participaciones']].sort_values(['nombre','right_type','rango_desde'])
    else:
        bl = pd.DataFrame(columns=['socio_id','nombre','right_type','rango_desde','rango_hasta','participaciones'])

    return bl, resumen, vn, tot

# --------- Exportación a Excel (con nombres en movimientos) ----------
def export_excel(conn: sqlite3.Connection, company_id:int, fecha_corte:str, path:str):
    import xlsxwriter
    from datetime import datetime

    # --- Datos de compañía
    comp = conn.execute("SELECT * FROM companies WHERE id=?", (company_id,)).fetchone()
    if not comp:
        raise ValueError("Sociedad no encontrada.")
    nombre = comp['name']; cif = comp['cif']; dom = comp['domicilio']; fconst = comp['fecha_constitucion']

    # --- Foto fija
    bloques, resumen, valor_nominal, part_tot = snapshot_as_of(conn, company_id, fecha_corte)

    # --- Movimientos con nombres
    eventos = pd.read_sql_query("""
        SELECT e.fecha AS Fecha,
               e.tipo  AS Tipo,
               pt.nombre AS 'Socio transmite',
               pa.nombre AS 'Socio adquiere',
               e.rango_desde AS Desde,
               e.rango_hasta AS Hasta,
               e.participaciones AS Participaciones,
               e.nuevo_valor_nominal AS 'Nuevo valor nominal',
               e.documento AS Documento,
               e.observaciones AS Observaciones
        FROM events e
        LEFT JOIN partners pt ON pt.id = e.socio_transmite
        LEFT JOIN partners pa ON pa.id = e.socio_adquiere
        WHERE e.company_id=? AND e.fecha<=?
        ORDER BY e.fecha, e.id
    """, conn, params=(company_id, fecha_corte))

    # --- Cargas desde bloques
    cargas = bloques[bloques['right_type'].isin(['prenda','embargo','usufructo','nuda'])].copy() if isinstance(bloques, pd.DataFrame) and not bloques.empty else pd.DataFrame()

    # --- Tabla "Socios actuales" como en el PDF
    with conn:
        df_snap = pd.read_sql_query("""
            SELECT p.id AS socio_id, p.nombre, SUM(h.participaciones) AS participaciones
            FROM holdings h
            JOIN partners p
                ON p.id = h.socio_id AND p.company_id = h.company_id
            WHERE h.company_id = ?
              AND h.right_type = 'plena'
              AND h.estado = 'vigente'
            GROUP BY p.id, p.nombre
            HAVING SUM(h.participaciones) > 0
            ORDER BY p.nombre
        """, conn, params=(company_id,))

        df_meta = pd.read_sql_query("""
            SELECT id, nombre, nif, nacionalidad, domicilio
            FROM partners
            WHERE company_id = ?
        """, conn, params=(company_id,))

    df_snap = df_snap[["socio_id", "participaciones"]]
    socios_pdf_like = df_meta.merge(df_snap, left_on="id", right_on="socio_id", how="inner")
    socios_pdf_like["Participaciones"] = socios_pdf_like["participaciones"].fillna(0).astype(int)
    total_part = int(socios_pdf_like["Participaciones"].sum())
    socios_pdf_like["Cuota (%)"] = (socios_pdf_like["Participaciones"] / total_part * 100).round(4) if total_part > 0 else 0.0

    socios_pdf_like = socios_pdf_like.rename(columns={
        "nombre": "Nombre o razón social",
        "nif": "NIF",
        "nacionalidad": "Nacionalidad",
        "domicilio": "Domicilio"
    })[["Nombre o razón social","NIF","Nacionalidad","Domicilio","Participaciones","Cuota (%)"]]

    # Fila TOTAL
    fila_total = {
        "Nombre o razón social": "TOTAL",
        "NIF": "",
        "Nacionalidad": "",
        "Domicilio": "",
        "Participaciones": total_part,
        "Cuota (%)": 100.0 if total_part > 0 else 0.0
    }
    socios_pdf_like = pd.concat([socios_pdf_like, pd.DataFrame([fila_total])], ignore_index=True)

    # --- Saneos (evitar NaN/Inf/NaT)
    resumen = _df_para_excel(resumen) if isinstance(resumen, pd.DataFrame) else resumen
    bloques  = _df_para_excel(bloques) if isinstance(bloques, pd.DataFrame) else bloques
    cargas   = _df_para_excel(cargas)  if isinstance(cargas,  pd.DataFrame) else cargas
    eventos  = _df_para_excel(eventos) if isinstance(eventos, pd.DataFrame) else eventos
    socios_pdf_like = _df_para_excel(socios_pdf_like)

    # Fecha texto (evita NaT)
    if isinstance(eventos, pd.DataFrame) and not eventos.empty and 'Fecha' in eventos.columns:
        eventos['Fecha'] = eventos['Fecha'].astype(str)

    # --- Mapa de tipos cortos (como PDF) y leyenda
    TIPO_MAP = {
        "ALTA": "ALTA",
        "AMPL_EMISION": "AMP-EMIS",
        "AMPL_VALOR": "AMP-VAL",
        "TRANSMISION": "TRANS",
        "BAJA": "BAJA",
        "RED_AMORT": "RED-AM",
        "RED_VALOR": "RED-VAL",
        "PIGNORACION": "PIGN",
        "EMBARGO": "EMB",
        "USUFRUCTO": "USUF",
        "REDENOMINACION": "REDEN",
    }
    legend_text = ("ALTA: Alta; AMP-EMIS: Ampliación por emisión de participaciones; AMP-VAL: Ampliación por valor nominal; "
                   "TRANS: Transmisión; BAJA: Baja; RED-AM: Reducción por amortización; RED-VAL: Reducción por valor nominal; "
                   "PIGN: Pignoración; EMB: Embargo; USUF: Usufructo; REDEN: Redenominación")

    if isinstance(eventos, pd.DataFrame) and not eventos.empty:
        eventos.insert(1, "Tipo (corto)", eventos["Tipo"].map(lambda x: TIPO_MAP.get(str(x), str(x))))

    # --- Workbook (protección ante NaN/Inf)
    wb = xlsxwriter.Workbook(path, {'nan_inf_to_errors': True})

    h1 = wb.add_format({'bold': True, 'font_size': 14})
    h2 = wb.add_format({'bold': True, 'bg_color': '#F2F2F2', 'border': 1})
    cell = wb.add_format({'border': 1})
    ital = wb.add_format({'italic': True})
    num0 = wb.add_format({'border': 1, 'num_format': '#,##0'})
    pct4 = wb.add_format({'border': 1, 'num_format': '0.0000%'})

    # === Portada (como PDF) ===
    ws = wb.add_worksheet("Portada")
    ws.write("A1", "Libro Registro de Socios (SL)", h1)
    ws.write("A3", "Sociedad:", h2); ws.write("B3", nombre)
    ws.write("A4", "CIF:", h2); ws.write("B4", cif)
    ws.write("A5", "Domicilio:", h2); ws.write("B5", dom or "")
    ws.write("A6", "Fecha constitución:", h2); ws.write("B6", str(fconst or ""))
    ws.write("A7", "Valor nominal (€):", h2); ws.write("B7", valor_nominal)
    ws.write("A8", "Participaciones totales:", h2); ws.write("B8", part_tot)
    ws.write("A9", "Fecha de corte:", h2); ws.write("B9", fecha_corte)
    ws.write("A10","Generado el:", h2); ws.write("B10", datetime.now().strftime("%Y-%m-%d %H:%M"))
    ws.set_column("A:A", 28); ws.set_column("B:B", 60)
    ws.write("A12", "Incluye: Socios actuales, inventario, cargas, movimientos, firmas y leyenda.", ital)

    # === Socios actuales (idéntico al PDF) ===
    ws = wb.add_worksheet("Socios actuales")
    headers = ["Nombre o razón social","NIF","Nacionalidad","Domicilio","Participaciones","Cuota (%)"]
    ws.write_row(0, 0, headers, h2)
    if isinstance(socios_pdf_like, pd.DataFrame) and not socios_pdf_like.empty:
        for i, row in socios_pdf_like[headers].reset_index(drop=True).iterrows():
            # Porcentaje en Excel como número (0..1) => para mostrar 4 decimales de % aplicamos formato pct4
            cuota = row["Cuota (%)"]
            cuota_num = (float(cuota)/100.0) if isinstance(cuota, (int,float)) else None
            ws.write(i+1, 0, row["Nombre o razón social"], cell)
            ws.write(i+1, 1, row["NIF"], cell)
            ws.write(i+1, 2, row["Nacionalidad"], cell)
            ws.write(i+1, 3, row["Domicilio"], cell)
            ws.write_number(i+1, 4, int(row["Participaciones"]) if row["Participaciones"] not in (None,"") else 0, num0)
            if cuota_num is None:
                ws.write(i+1, 5, None, cell)
            else:
                ws.write_number(i+1, 5, cuota_num, pct4)
    ws.set_column(0, 0, 36); ws.set_column(1, 1, 18); ws.set_column(2, 2, 14); ws.set_column(3, 3, 40)
    ws.set_column(4, 4, 16); ws.set_column(5, 5, 12)

    # === Inventario actual ===
    ws = wb.add_worksheet("Inventario actual")
    ws.write_row(0, 0, ["ID socio","Nombre","Derecho","Desde","Hasta","Participaciones"], h2)
    if isinstance(bloques, pd.DataFrame) and not bloques.empty:
        for i, row in bloques.reset_index(drop=True).iterrows():
            ws.write_row(i+1, 0, [row['socio_id'], row['nombre'], row['right_type'],
                                  row['rango_desde'], row['rango_hasta'], row['participaciones']], cell)
    ws.set_column("A:A", 10); ws.set_column("B:B", 40); ws.set_column("C:C", 14)
    ws.set_column("D:E", 10); ws.set_column("F:F", 16)

    # === Cargas ===
    ws = wb.add_worksheet("Cargas")
    ws.write_row(0, 0, ["ID socio/titular","Nombre","Derecho","Desde","Hasta","Participaciones"], h2)
    if isinstance(cargas, pd.DataFrame) and not cargas.empty:
        for i, row in cargas.reset_index(drop=True).iterrows():
            ws.write_row(i+1, 0, [row['socio_id'], row['nombre'], row['right_type'],
                                  row['rango_desde'], row['rango_hasta'], row['participaciones']], cell)
    else:
        ws.write_row(1, 0, ["–","–","–","–","–","–"], cell)
    ws.set_column("A:A", 16); ws.set_column("B:B", 40); ws.set_column("C:C", 14)
    ws.set_column("D:E", 10); ws.set_column("F:F", 16)

    # === Movimientos (con Tipo corto como en PDF) ===
    ws = wb.add_worksheet("Movimientos")
    if isinstance(eventos, pd.DataFrame) and not eventos.empty:
        headers = ["Fecha","Tipo (corto)","Tipo","Socio transmite","Socio adquiere","Desde","Hasta",
                   "Participaciones","Nuevo valor nominal","Documento","Observaciones"]
        ws.write_row(0, 0, headers, h2)
        for i, row in eventos[headers].reset_index(drop=True).iterrows():
            ws.write_row(i+1, 0, [
                row["Fecha"], row["Tipo (corto)"], row["Tipo"], row["Socio transmite"], row["Socio adquiere"],
                row["Desde"], row["Hasta"], row["Participiciones"] if "Participiciones" in row else row["Participaciones"],
                row["Nuevo valor nominal"], row["Documento"], row["Observaciones"]
            ], cell)
        ws.set_column("A:A", 12); ws.set_column("B:B", 12); ws.set_column("C:C", 16); ws.set_column("D:E", 22)
        ws.set_column("F:H", 12); ws.set_column("I:I", 20); ws.set_column("J:K", 40)
    else:
        ws.write("A1", "No hay movimientos hasta la fecha de corte.", ital)

    # === Firmas (como PDF) ===
    ws = wb.add_worksheet("Firmas")
    gov = get_governance(conn, company_id)
    organo = gov["organo"]
    firmantes = gov["firmantes"]  # [{"nombre","rol"}, ...]

    def pick_signers(organo:str, firmantes:list[dict]):
        by = {}
        for f in firmantes:
            by.setdefault(f["rol"], []).append(f["nombre"])
        lines = []
        if organo == "admin_unico":
            nombre = (by.get("administrador_unico") or by.get("administrador único") or [""])[0]
            lines.append(("El Administrador Único", nombre))
        elif organo == "admins_solidarios":
            admins = by.get("administrador_solidario") or by.get("administradores_solidarios") or [f["nombre"] for f in firmantes]
            for n in admins:
                lines.append(("Administrador Solidario", n))
        else:
            pres = (by.get("presidente") or [""])[0]
            sec  = (by.get("secretario") or [])
            cd   = (by.get("consejero_delegado") or [])
            cons = (by.get("consejero") or [])
            vp   = (by.get("vicepresidente") or [])
            if pres: lines.append(("Presidente del Consejo", pres))
            if vp:   lines.append(("Vicepresidente del Consejo", vp[0]))
            if sec:  lines.append(("Secretario del Consejo", sec[0]))
            elif cd: lines.append(("Consejero Delegado", cd[0]))
            elif cons: lines.append(("Consejero", cons[0]))
            if len(lines) == 1 and len(cons) > 1:
                lines.append(("Consejero", cons[1]))
            if not lines:
                lines = [("Presidente del Consejo",""), ("Secretario del Consejo","")]
        return lines

    ws.write_row(0, 0, ["Cargo","Nombre","Firma"], h2)
    rowi = 1
    for cargo, nombre_sig in pick_signers(organo, firmantes):
        ws.write_row(rowi, 0, [cargo, nombre_sig, "_______________________________"], cell)
        rowi += 1
    ws.set_column("A:A", 28); ws.set_column("B:B", 42); ws.set_column("C:C", 30)
    ws.write(rowi+1, 0, "Las firmas anteriores se adecúan al órgano de administración configurado para la sociedad.", ital)

    # === Leyenda de tipos (texto) ===
    ws = wb.add_worksheet("Leyenda")
    ws.write("A1", "Leyenda de códigos de 'Tipo' (Movimientos)", h1)
    ws.write("A3", legend_text)
    ws.set_column("A:A", 120)

    wb.close()

# --------- Socios: alta, modificación y consultas ---------

def create_partner(conn, company_id:int, nombre:str, nif:str, domicilio:str, nacionalidad:str="Española"):
    """
    Da de alta un socio.
    """
    conn.execute("""
        INSERT INTO partners (company_id, nombre, nif, domicilio, nacionalidad)
        VALUES (?, ?, ?, ?, ?)
    """, (company_id, nombre, nif, domicilio, nacionalidad))


def update_partner(conn, socio_id:int, nombre:str, nif:str, domicilio:str, nacionalidad:str):
    """
    Actualiza los datos de un socio existente.
    """
    conn.execute("""
        UPDATE partners
           SET nombre = ?, nif = ?, domicilio = ?, nacionalidad = ?
         WHERE id = ?
    """, (nombre, nif, domicilio, nacionalidad, socio_id))


def list_partners(conn, company_id:int):
    """
    Devuelve todos los socios de una compañía con sus datos básicos.
    """
    cur = conn.execute("""
        SELECT id, nombre, nif, domicilio, nacionalidad
          FROM partners
         WHERE company_id = ?
         ORDER BY nombre
    """, (company_id,))
    return [dict(row) for row in cur.fetchall()]


def last_annotations(conn, company_id:int):
    """
    Devuelve dict {socio_id: 'YYYY-MM-DD'} con la última fecha en la que el socio aparece
    como transmitente o adquirente en events para esa compañía.
    """
    cur = conn.execute("""
        SELECT socio_id, MAX(fecha) AS ultima
        FROM (
            SELECT socio_transmite AS socio_id, fecha
              FROM events
             WHERE company_id = ? AND socio_transmite IS NOT NULL
            UNION ALL
            SELECT socio_adquiere AS socio_id, fecha
              FROM events
             WHERE company_id = ? AND socio_adquiere IS NOT NULL
        )
        GROUP BY socio_id
    """, (company_id, company_id))
    return {row["socio_id"]: row["ultima"] for row in cur.fetchall()}

# ---------------------------------------------
# Exportación a PDF (apaisado) con TIPOS cortos
# ---------------------------------------------
def export_pdf(conn: sqlite3.Connection, company_id:int, fecha_corte:str, path:str):
    """
    Genera el PDF legalizable (A4 apaisado) con:
    - Portada info + Socios + Inventario + Cargas + Movimientos + Firmas
    - 'Movimientos':
        * 'Tipo' con códigos cortos
        * Leyenda de códigos SOLO en páginas de Movimientos (pie de página, cursiva, 6 pt, 1 línea)
        * Cabeceras y celdas largas con Paragraph(wordWrap='CJK')
        * colWidths reescalados al ancho útil, números a la derecha, repeatRows=1, splitByRow=1
    - Portada adicional con hash SHA-256
    """
    from reportlab.lib.pagesizes import A4, landscape
    from reportlab.platypus import (
        BaseDocTemplate, PageTemplate, Frame, NextPageTemplate,
        Paragraph, Spacer, Table, TableStyle, PageBreak
    )
    from reportlab.lib import colors
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import cm
    from reportlab.pdfgen import canvas as _canvas
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont

    pdfmetrics.registerFont(TTFont("DejaVuSans", "DejaVuSans.ttf"))
    

    # --- Mapeo a códigos cortos para 'Tipo' ---
    TIPO_MAP = {
        "ALTA": "ALTA",
        "AMPL_EMISION": "AMP-EMIS",
        "AMPL_VALOR": "AMP-VAL",
        "TRANSMISION": "TRANS",
        "BAJA": "BAJA",
        "RED_AMORT": "RED-AM",
        "RED_VALOR": "RED-VAL",
        "PIGNORACION": "PIGN",
        "EMBARGO": "EMB",
        "USUFRUCTO": "USUF",
        "REDENOMINACION": "REDEN",
    }

    # --- Leyenda en UNA LÍNEA para el pie de página (solo Movimientos) ---
    legend_text = (
        "ALTA: Alta; AMP-EMIS: Ampliación por emisión de participaciones; "
        "AMP-VAL: Ampliación por valor nominal; TRANS: Transmisión; BAJA: Baja; "
        "RED-AM: Reducción por amortización; RED-VAL: Reducción por valor nominal; "
        "PIGN: Pignoración; EMB: Embargo; USUF: Usufructo; REDEN: Redenominación"
    )

    # --- Datos sociedad ---
    comp = conn.execute("SELECT * FROM companies WHERE id=?", (company_id,)).fetchone()
    if not comp:
        raise ValueError("Sociedad no encontrada.")
    nombre = comp['name']; cif = comp['cif']; dom = comp['domicilio']; fconst = comp['fecha_constitucion']

    # --- Foto fija e inputs ---
    bloques, resumen, valor_nominal, part_tot = snapshot_as_of(conn, company_id, fecha_corte)

    # --- Eventos con nombres (hasta fecha corte) ---
    eventos = pd.read_sql_query("""
        SELECT DATE(e.fecha)       AS Fecha,
               e.tipo              AS Tipo,
               pt.nombre           AS "Socio transmite",
               pa.nombre           AS "Socio adquiere",
               e.rango_desde       AS Desde,
               e.rango_hasta       AS Hasta,
               e.participaciones   AS Participaciones,
               e.nuevo_valor_nominal AS "Nuevo valor nominal",
               e.documento         AS Documento,
               e.observaciones     AS Observaciones
        FROM events e
        LEFT JOIN partners pt ON pt.id = e.socio_transmite
        LEFT JOIN partners pa ON pa.id = e.socio_adquiere
        WHERE e.company_id=? AND e.fecha<=?
        ORDER BY e.fecha, e.id
    """, conn, params=(company_id, fecha_corte))

    has_moves = isinstance(eventos, pd.DataFrame) and not eventos.empty

    # --- Estilos ---
    styles = getSampleStyleSheet()
    h1 = styles['Title']; h2 = styles['Heading2']
    style_header = ParagraphStyle('header', parent=styles['Normal'], fontName="DejaVuSans", fontSize=8, leading=9, alignment=1, wordWrap='CJK')
    style_cell   = ParagraphStyle('cell', parent=styles['Normal'], fontName="DejaVuSans", fontSize=8, leading=9, wordWrap='CJK')
    style_small  = ParagraphStyle('small', parent=styles['Normal'], fontName="DejaVuSans", fontSize=9, leading=11)

    def P(x): return Paragraph("" if x is None else str(x), style_cell)

    # --- Documento con plantillas (para pie solo en Movimientos) ---
    doc = BaseDocTemplate(
        path, pagesize=landscape(A4),
        leftMargin=18, rightMargin=18, topMargin=18, bottomMargin=18
    )
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='F')
    def footer_mov(canvas, doc_):
        canvas.saveState()
        canvas.setFont("Helvetica-Oblique", 8)  # itálica 8 pt
        canvas.setFillGray(0.3)
        # Coloca en el margen inferior respetando bottomMargin
        x = doc_.leftMargin
        y = doc_.bottomMargin - 10  # 10 puntos por debajo del área útil
        canvas.drawString(x, max(8, y), legend_text)  # evita irse por debajo del borde
        canvas.restoreState()
    tpl_default = PageTemplate(id='default', frames=[frame])                     # sin pie
    tpl_moves   = PageTemplate(id='moves',   frames=[frame], onPage=footer_mov)  # con pie
    doc.addPageTemplates([tpl_default, tpl_moves])

    story = []
    usable_w = doc.width

    # ========= Portada info =========
    story.append(Paragraph("<b>Libro Registro de Socios (Sociedad Limitada)</b>", h1))
    story.append(Spacer(1, 8))
    portada = [
        ["Sociedad", nombre],
        ["CIF", cif],
        ["Domicilio", dom or ""],
        ["Fecha constitución", str(fconst or "")],
        ["Valor nominal (€)", f"{valor_nominal}"],
        ["Participaciones totales", f"{part_tot}"],
        ["Fecha de corte", str(fecha_corte)],
        ["Generado el", datetime.now().strftime("%Y-%m-%d %H:%M")],
    ]
    t = Table(portada, colWidths=[0.20*usable_w, 0.80*usable_w])
    t.setStyle(TableStyle([
        ('BACKGROUND',(0,0),(0,-1),colors.whitesmoke),
        ('BOX',(0,0),(-1,-1),0.5,colors.black),
        ('INNERGRID',(0,0),(-1,-1),0.25,colors.grey),
        ('FONTSIZE',(0,0),(-1,-1),9),
        ('VALIGN',(0,0),(-1,-1),'TOP'),
    ]))
    story.append(t)
    story.append(PageBreak())

    # ========= Socios actuales (vigentes) =========
    # Traemos socios vigentes (plena, estado vigente) y calculamos % con 4 decimales
    with conn:  # usa la misma conn ya abierta arriba
        df_snap = pd.read_sql_query("""
            SELECT p.id AS socio_id, p.nombre, SUM(h.participaciones) AS participaciones
            FROM holdings h
            JOIN partners p
                ON p.id = h.socio_id AND p.company_id = h.company_id
            WHERE h.company_id = ?
            AND h.right_type = 'plena'
            AND h.estado = 'vigente'
            GROUP BY p.id, p.nombre
            HAVING SUM(h.participaciones) > 0
            ORDER BY p.nombre
        """, conn, params=(company_id,))

        df_meta = pd.read_sql_query("""
            SELECT id, nombre, nif, nacionalidad, domicilio
            FROM partners
            WHERE company_id = ?
        """, conn, params=(company_id,))

    df_snap = df_snap[["socio_id", "participaciones"]]

    df = df_meta.merge(df_snap, left_on="id", right_on="socio_id", how="inner")
    df["Participaciones"] = df["participaciones"].fillna(0).astype(int)
    total_part = int(df["Participaciones"].sum())
    df["Cuota (%)"] = (df["Participaciones"] / total_part * 100).round(4) if total_part > 0 else 0.0

    # Orden/renombre columnas
    df = df[["nombre","nif","nacionalidad","domicilio","Participaciones","Cuota (%)"]].rename(columns={
        "nombre":"Nombre o razón social",
        "nif":"NIF",
        "nacionalidad":"Nacionalidad",
        "domicilio":"Domicilio"
    })

    # Fila TOTAL
    fila_total = {
        "Nombre o razón social":"TOTAL",
        "NIF":"",
        "Nacionalidad":"",
        "Domicilio":"",
        "Participaciones": total_part,
        "Cuota (%)": 100.0 if total_part>0 else 0.0
    }
    df = pd.concat([df, pd.DataFrame([fila_total])], ignore_index=True)

    # Formato visual
    def miles_es(x):
        try: return f"{int(x):,}".replace(",", ".")
        except: return x
    df["Participaciones"] = df["Participaciones"].map(miles_es)
    df["Cuota (%)"] = df["Cuota (%)"].map(lambda x: f"{x:.4f}%" if isinstance(x,(int,float)) else x)

    # Construcción tabla PDF
    story.append(Paragraph("<b>Socios actuales (plena propiedad)</b>", h2))
    headers = ["Nombre o razón social","NIF","Nacionalidad","Domicilio","Participaciones","Cuota (%)"]
    socios_data = [headers] + df[headers].values.tolist()

    soc_tbl = Table(socios_data, colWidths=[
        0.28*usable_w, 0.12*usable_w, 0.10*usable_w, 0.25*usable_w, 0.12*usable_w, 0.13*usable_w
    ], repeatRows=1)
    soc_tbl.setStyle(TableStyle([
        ('BACKGROUND',(0,0),(-1,0),colors.lightgrey),
        ('BOX',(0,0),(-1,-1),0.5,colors.black),
        ('INNERGRID',(0,0),(-1,-1),0.25,colors.grey),
        ('VALIGN',(0,0),(-1,-1),'TOP'),
        ('ALIGN',(-2,1),(-1,-1),'RIGHT'),
        ('FONTSIZE',(0,0),(-1,-1),9),
    ]))
    story.append(soc_tbl)
    story.append(PageBreak())

    # ========= Inventario =========
    story.append(Paragraph("<b>Inventario actual por rangos</b>", h2))
    inv_data = [["ID socio","Nombre","Derecho","Desde","Hasta","Participaciones"]]
    if isinstance(bloques, pd.DataFrame) and not bloques.empty:
        for _, r in bloques.reset_index(drop=True).iterrows():
            inv_data.append([
                str(r['socio_id']), r['nombre'] or "", r['right_type'],
                str(int(r['rango_desde'])), str(int(r['rango_hasta'])), str(int(r['participaciones']))
            ])
    inv_tbl = Table(inv_data,
        colWidths=[0.08*usable_w, 0.42*usable_w, 0.15*usable_w, 0.10*usable_w, 0.10*usable_w, 0.15*usable_w],
        repeatRows=1)
    inv_tbl.setStyle(TableStyle([
        ('BACKGROUND',(0,0),(-1,0),colors.lightgrey),
        ('BOX',(0,0),(-1,-1),0.5,colors.black),
        ('INNERGRID',(0,0),(-1,-1),0.25,colors.grey),
        ('VALIGN',(0,0),(-1,-1),'TOP'),
        ('ALIGN',(3,1),(5,-1),'RIGHT'),
        ('FONTSIZE',(0,0),(-1,-1),9),
    ]))
    story.append(inv_tbl)

    # ========= Movimientos =========
    # Cambiamos la plantilla de las SIGUIENTES páginas a 'moves' (con pie)
    if has_moves:
        story.append(NextPageTemplate('moves'))
        story.append(PageBreak())
    
    story.append(Paragraph("<b>Movimientos (hasta la fecha de corte)</b>", h2))

    # Cabecera con índice
    headers = [
        Paragraph("Nº", style_header),
        Paragraph("Fecha", style_header),
        Paragraph("Tipo", style_header),
        Paragraph("Socio transmite", style_header),
        Paragraph("Socio adquiere", style_header),
        Paragraph("Desde", style_header),
        Paragraph("Hasta", style_header),
        Paragraph("Participaciones", style_header),
        Paragraph("Nuevo valor nominal", style_header),
        Paragraph("Documento", style_header),
        Paragraph("Observaciones", style_header),
    ]
    mov_data = [headers]

    if isinstance(eventos, pd.DataFrame) and not eventos.empty:
        for i, (_, r) in enumerate(eventos.iterrows(), start=1):
            mov_data.append([
                str(i),
                "" if pd.isna(r["Fecha"]) else str(r["Fecha"]),
                Paragraph(TIPO_MAP.get(str(r["Tipo"]), str(r["Tipo"])), style_cell),
                P(r["Socio transmite"]),
                P(r["Socio adquiere"]),
                "" if pd.isna(r["Desde"]) else str(int(r["Desde"])),
                "" if pd.isna(r["Hasta"]) else str(int(r["Hasta"])),
                "" if pd.isna(r["Participaciones"]) else str(int(r["Participaciones"])),
                "" if pd.isna(r["Nuevo valor nominal"]) else str(r["Nuevo valor nominal"]),
                P(r["Documento"]),
                P(r["Observaciones"]),
            ])
    else:
        mov_data.append(["", "No hay movimientos hasta la fecha de corte","","","","","","","","",""])

    # Ajusta anchos (añadimos una col. pequeña para Nº)
    # Ajusta anchos (prioriza Documento/Observaciones, compacta Tipo)
    # Orden de columnas: Nº, Fecha, Tipo, Transmite, Adquiere, Desde, Hasta, Particip., Nuevo VN, Documento, Observaciones
    base_cm = [
        1.0,  # Nº
        2.0,  # Fecha
        1.4,  # Tipo (abreviado => más estrecho)
        4.2,  # Socio transmite
        4.2,  # Socio adquiere
        2.0,  # Desde
        2.0,  # Hasta
        2.6,  # Participaciones
        2.4,  # Nuevo valor nominal
        5.0,  # Documento (más ancho)
        6.0,  # Observaciones (más ancho)
    ]
    colWidths = [w*cm for w in base_cm]
    total = sum(colWidths)
    if total > 0:
        scale = usable_w / total
        colWidths = [w*scale for w in colWidths]

    mov_tbl = Table(mov_data, colWidths=colWidths, repeatRows=1, splitByRow=1, hAlign='LEFT')
    mov_tbl.setStyle(TableStyle([
        ('BACKGROUND',(0,0),(-1,0),colors.lightgrey),
        ('BOX',(0,0),(-1,-1),0.5,colors.black),
        ('INNERGRID',(0,0),(-1,-1),0.25,colors.grey),
        ('VALIGN',(0,0),(-1,-1),'TOP'),
        ('ALIGN',(5,1),(8,-1),'RIGHT'),   # numéricos a la derecha
        ('FONTNAME', (0,0), (-1,-1), 'DejaVuSans'),
        ('FONTSIZE',(0,0),(-1,-1),8),
        ('LEFTPADDING',(0,0),(-1,-1),3),
        ('RIGHTPADDING',(0,0),(-1,-1),3),
        ('TOPPADDING',(0,0),(-1,-1),2),
        ('BOTTOMPADDING',(0,0),(-1,-1),2),
    ]))
    story.append(mov_tbl)
    story.append(Spacer(1, 10))

    # Volvemos a plantilla sin pie para lo que venga después
    if has_moves:
        story.append(NextPageTemplate('default'))

    # ========= Firmas según órgano de gobierno =========
    gov = get_governance(conn, company_id)
    organo = gov["organo"]
    firmantes = gov["firmantes"]  # lista de dicts: {"nombre","rol"}

    def pick_signers(organo:str, firmantes:list[dict]):
        # Utilidades por rol
        by = {}
        for f in firmantes:
            by.setdefault(f["rol"], []).append(f["nombre"])

        lines = []  # cada línea: (cargo, nombre, nota_opcional)
        if organo == "admin_unico":
            nombre = (by.get("administrador_unico") or by.get("administrador único") or [""])[0]
            lines.append(("El Administrador Único", nombre, ""))

        elif organo == "admins_solidarios":
            admins = by.get("administrador_solidario") or by.get("administradores_solidarios") or []
            if not admins:  # fallback: por si no han marcado el rol exacto
                admins = [f["nombre"] for f in firmantes]
            # una línea por cada solidario, con nota
            for n in admins:
                lines.append(("Administrador Solidario", n, "(firma de uno de ellos)"))

        else:  # consejo
            pres = (by.get("presidente") or [""])[0]
            sec  = (by.get("secretario") or [])
            cd   = (by.get("consejero_delegado") or [])
            cons = (by.get("consejero") or [])
            vp   = (by.get("vicepresidente") or [])

            # Preferimos Presidente + Secretario
            if pres:
                lines.append(("Presidente del Consejo", pres, ""))
            if vp:
                lines.append(("Vicepresidente del Consejo", vp[0], ""))
            if sec:
                lines.append(("Secretario del Consejo", sec[0], ""))
            elif cd:
                lines.append(("Consejero Delegado", cd[0], ""))
            else:
                # si no hay secretario ni CD, usamos cualquier consejero disponible
                if cons:
                    lines.append(("Consejero", cons[0], ""))

            # Aseguramos al menos dos líneas en consejo
            if len(lines) == 1 and cons[1:]:
                lines.append(("Consejero", cons[1], ""))

            if not lines:  # fallback total
                lines = [("Presidente del Consejo", "", ""), ("Secretario del Consejo", "", "")]

        return lines

    sig_lines = pick_signers(organo, firmantes)

    story.append(Paragraph("<b>Firmas</b>", h2))
    sig_data = [["Cargo", "Nombre", ""]]
    for cargo, nombre, nota in sig_lines:
        sig_data.append([cargo, nombre, "_______________________________"])

    sig_tbl = Table(sig_data, colWidths=[0.28*usable_w, 0.42*usable_w, 0.30*usable_w])
    sig_tbl.setStyle(TableStyle([
        ('BACKGROUND',(0,0),(-1,0),colors.whitesmoke),
        ('BOX',(0,0),(-1,-1),0.5,colors.black),
        ('INNERGRID',(0,0),(-1,-1),0.25,colors.grey),
        ('VALIGN',(0,0),(-1,-1),'MIDDLE'),
        ('FONTSIZE',(0,0),(-1,-1),9),
    ]))
    story.append(sig_tbl)

    # Nota legal breve
    nota = "Las firmas anteriores se adecúan al órgano de administración configurado para la sociedad."
    story.append(Spacer(1, 6))
    story.append(Paragraph(nota, style_small))

    # Construcción principal
    doc.build(story)

    # Portada con hash (primera página)
    try:
        try:
            from pypdf import PdfReader, PdfWriter
        except Exception:
            from PyPDF2 import PdfReader, PdfWriter

        h = _sha256_file(path)
        tmp = str(Path(path).with_suffix(".portada.pdf"))
        c = _canvas.Canvas(tmp, pagesize=landscape(A4))
        c.setFont("Helvetica-Bold", 16); c.drawString(24, 560, "Libro Registro de Socios – Portada técnica")
        c.setFont("Helvetica", 11)
        y = 532
        for label, val in [
            ("Sociedad", nombre),
            ("CIF", cif),
            ("Fecha de corte", str(fecha_corte)),
            ("Generado el", datetime.now().strftime("%Y-%m-%d %H:%M")),
            ("Hash SHA-256", h),
        ]:
            c.drawString(24, y, f"{label}: {val}"); y -= 18
        c.showPage(); c.save()

        rd_doc  = PdfReader(path); rd_port = PdfReader(tmp)
        wr = PdfWriter()
        for p in rd_port.pages: wr.add_page(p)
        for p in rd_doc.pages:  wr.add_page(p)
        with open(path, "wb") as out: wr.write(out)
        try: Path(tmp).unlink(missing_ok=True)
        except Exception: pass
    except Exception:
        pass

# >>>>>>>>>>>>> _review_correlativos/_archive/tools/recompute_correlativo.py <<<<<<<<<<<<<

import sqlite3
from pathlib import Path

DB_PATH = Path(__file__).resolve().parents[1] / "data" / "libro_socios.db"

def recompute():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row

    company_ids = [r["id"] for r in conn.execute("SELECT id FROM companies").fetchall()]

    for cid in company_ids:
        cur = conn.execute("""
            SELECT id, fecha
            FROM events
            WHERE company_id=?
            ORDER BY fecha, id
        """, (cid,))
        rows = cur.fetchall()
        for idx, row in enumerate(rows, start=1):
            conn.execute("UPDATE events SET correlativo=? WHERE id=?", (idx, row["id"]))
        print(f"✔ Recomputado correlativo para company_id={cid} ({len(rows)} eventos)")
    conn.commit()
    conn.close()

if __name__ == "__main__":
    recompute()

# >>>>>>>>>>>>> _review_correlativos/_archive/tools/recompute_correlativos_all.py <<<<<<<<<<<<<

# tools/recompute_correlativos_all.py

from pathlib import Path
import sqlite3

DB_PATH = Path(__file__).resolve().parents[1] / "data" / "libro_socios.db"

def main():
    with sqlite3.connect(DB_PATH) as conn:
        conn.row_factory = sqlite3.Row
        # Asegura columna
        cols = [r[1] for r in conn.execute("PRAGMA table_info(events)").fetchall()]
        if "correlativo" not in cols:
            conn.execute("ALTER TABLE events ADD COLUMN correlativo INTEGER")

        company_ids = [r["id"] for r in conn.execute("SELECT id FROM companies").fetchall()]
        for cid in company_ids:
            conn.execute("DROP TABLE IF EXISTS _tmp_corr")
            conn.execute(f"""
                CREATE TEMP TABLE _tmp_corr AS
                SELECT id, ROW_NUMBER() OVER (PARTITION BY company_id ORDER BY fecha, id) AS rn
                FROM events WHERE company_id={cid}
            """)
            conn.execute("""
                UPDATE events
                   SET correlativo = (SELECT rn FROM _tmp_corr WHERE _tmp_corr.id = events.id)
                 WHERE company_id=?
            """, (cid,))
            conn.execute("DROP TABLE IF EXISTS _tmp_corr")
            print(f"✓ correlativos recalculados para company_id={cid}")
        print("✅ Listo")

if __name__ == "__main__":
    main()

# >>>>>>>>>>>>> _review_correlativos/app/core/enums.py <<<<<<<<<<<<<

# app/core/enums.py

# Lista “canónica” de cargos que aparecerán en el desplegable
GOVERNANCE_ROLES: list[str] = [
    "Administrador Único",
    "Presidente",
    "Vicepresidente",
    "Secretario",
    "Vicesecretario",
    "Secretario - Consejero",
    "Consejero Delegado",
    "Consejero",
    "Apoderado",
]

# Aliases heredados (v1) -> nombre canónico
GOVERNANCE_ROLE_ALIASES: dict[str, str] = {
    "admin_unico": "Administrador Único",
    "administrador_unico": "Administrador Único",
    "consejero_delegado": "Consejero Delegado",
    "vicepresidente": "Vicepresidente",
    "presidente": "Presidente",
    "secretario": "Secretario",
    "vicesecretario": "Vicesecretario",
    "secretario_consejero": "Secretario - Consejero",
    "sec_consejero": "Secretario - Consejero",
    "consejero": "Consejero",
    "apoderado": "Apoderado",
}

# Tipos canónicos (v1 + v2)
EVENT_TYPES: list[str] = [
    "ALTA",
    "AMPL_EMISION",
    "AMPL_VALOR",
    "TRANSMISION",
    "BAJA",
    "RED_AMORT",
    "RED_VALOR",
    "PIGNORACION",
    "EMBARGO",
    "CANCELA_PIGNORACION",  # ← nuevo
    "CANCELA_EMBARGO",      # ← nuevo
    "LEV_GRAVAMEN",         # opcional genérico
    "ALZAMIENTO",           # opcional genérico
    "USUFRUCTO",
    "REDENOMINACION",
    "SUCESION",
]

# Aliases (normalizamos varios literales a los canónicos)
EVENT_TYPE_ALIASES: dict[str, str] = {
    "TRASMISION": "TRANSMISION",
    "REDENOMINACIÓN": "REDENOMINACION",
    "REDENOM": "REDENOMINACION",
    "REDEN": "REDENOMINACION",
    # Sinónimos de cancelaciones:
    "LEVANTAMIENTO": "LEV_GRAVAMEN",
    "LEVANTAMIENTO_DE_GRAVAMEN": "LEV_GRAVAMEN",
    "ALZAR_EMBARGO": "ALZAMIENTO",
    "ALZAMIENTO_DE_EMBARGO": "ALZAMIENTO",
}

# Etiquetas legibles (por si quieres usarlas en UI/reportes)
EVENT_LABELS: dict[str, str] = {
    "ALTA": "Alta",
    "AMPL_EMISION": "Ampliación (emisión)",
    "AMPL_VALOR": "Aumento de VN",
    "TRANSMISION": "Transmisión",
    "BAJA": "Baja",
    "RED_AMORT": "Reducción (amortización)",
    "RED_VALOR": "Reducción de VN",
    "PIGNORACION": "Pignoración",
    "EMBARGO": "Embargo",
    "CANCELA_PIGNORACION": "Cancelación de pignoración",
    "CANCELA_EMBARGO": "Cancelación de embargo",
    "LEV_GRAVAMEN": "Levantamiento de gravamen",
    "ALZAMIENTO": "Alzamiento",
    "USUFRUCTO": "Usufructo",
    "REDENOMINACION": "Redenominación",
    "SUCESION": "Sucesión",
}

def normalize_event_type(t: str | None) -> str | None:
    if not t:
        return t
    t_up = t.strip().upper()
    if t_up in EVENT_TYPE_ALIASES:
        return EVENT_TYPE_ALIASES[t_up]
    return t_up

# >>>>>>>>>>>>> _review_correlativos/app/core/models.py <<<<<<<<<<<<<

#app/core/models.py

from dataclasses import dataclass
from typing import Optional

@dataclass
class Partner:
    id: int
    company_id: int
    nombre: str
    nif: str
    domicilio: Optional[str] = None
    nacionalidad: Optional[str] = None
    fecha_nacimiento_constitucion: Optional[str] = None

@dataclass
class BoardMember:
    id: int
    company_id: int
    nombre: str
    cargo: str
    nif: str
    direccion: Optional[str] = None
    telefono: Optional[str] = None
    email: Optional[str] = None

# >>>>>>>>>>>>> _review_correlativos/app/core/repositories/base.py <<<<<<<<<<<<<

from typing import Iterable
def rows_to_dicts(rows: Iterable) -> list[dict]:
    return [dict(r) for r in rows]

# >>>>>>>>>>>>> _review_correlativos/app/core/repositories/companies_repo.py <<<<<<<<<<<<<

# app/core/repositories/companies_repo.py
from __future__ import annotations
from typing import Optional
from ...infra.db import get_connection

def _dict_row_factory(cursor, row):
    return {cursor.description[i][0]: row[i] for i in range(len(row))}

def list_companies() -> list[dict]:
    with get_connection() as conn:
        conn.row_factory = _dict_row_factory
        cur = conn.execute("""
            SELECT id, name, cif, domicilio, fecha_constitucion
            FROM companies
            ORDER BY id
        """)
        return cur.fetchall()

def get_company(company_id: int) -> Optional[dict]:
    with get_connection() as conn:
        conn.row_factory = _dict_row_factory
        cur = conn.execute("""
            SELECT id, name, cif, domicilio, fecha_constitucion
            FROM companies
            WHERE id = ?
        """, (company_id,))
        row = cur.fetchone()
        return row if row else None

def insert_company(*, name: str, cif: str,
                   domicilio: Optional[str], fecha_constitucion: Optional[str]) -> int:
    with get_connection() as conn:
        cur = conn.execute("""
            INSERT INTO companies(name, cif, domicilio, fecha_constitucion)
            VALUES (?, ?, ?, ?)
        """, (name.strip(), cif.strip(), domicilio, fecha_constitucion))
        return cur.lastrowid

def update_company(*, id: int, name: str, cif: str,
                   domicilio: Optional[str], fecha_constitucion: Optional[str]) -> None:
    with get_connection() as conn:
        conn.execute("""
            UPDATE companies
               SET name = ?, cif = ?, domicilio = ?, fecha_constitucion = ?
             WHERE id = ?
        """, (name.strip(), cif.strip(), domicilio, fecha_constitucion, id))

def delete_company(company_id: int) -> None:
    with get_connection() as conn:
        conn.execute("DELETE FROM companies WHERE id = ?", (company_id,))

# >>>>>>>>>>>>> _review_correlativos/app/core/repositories/events_repo.py <<<<<<<<<<<<<

# app/core/repositories/events_repo.py

import sqlite3
from typing import Optional
from ...infra.db import get_connection

import logging
log = logging.getLogger(__name__)

BASE_EVENT_COLS = [
    "id","company_id","correlativo","fecha","tipo",
    "socio_transmite","socio_adquiere",
    "rango_desde","rango_hasta",
    "nuevo_valor_nominal",
    "documento","observaciones",
    "hora","orden_del_dia","created_at","updated_at",
]

def _cols(conn, table: str) -> set[str]:
    cur = conn.execute(f"PRAGMA table_info({table})")
    rows = cur.fetchall()
    if not rows:
        return set()
    first = rows[0]
    if isinstance(first, dict):
        return {r.get("name") for r in rows if "name" in r}
    try:
        return {r[1] for r in rows}
    except Exception:
        try:
            return {r["name"] for r in rows}
        except Exception:
            return set()

def list_events_upto(company_id: int, fecha_max: Optional[str]) -> list[dict]:
    with get_connection() as conn:
        have = _cols(conn, "events")
        cols = [c for c in BASE_EVENT_COLS if c in have]
        where = "AND fecha<=?" if fecha_max else ""
        sql = f"SELECT {', '.join(cols)} FROM events WHERE company_id=? {where} ORDER BY fecha, id"
        conn.row_factory = sqlite3.Row
        cur = conn.execute(sql, (company_id, fecha_max) if fecha_max else (company_id,))
        rows = [dict(r) for r in cur.fetchall()]
        # normaliza claves faltantes
        out = []
        for r in rows:
            d = {k: r.get(k) for k in cols}
            for k in BASE_EVENT_COLS:
                d.setdefault(k, None)
            out.append(d)
        return out

# Compat:
def list_events(company_id: int) -> list[dict]:
    return list_events_upto(company_id, None)

def _supports_row_number(conn: sqlite3.Connection) -> bool:
    """Devuelve True si la BD soporta ROW_NUMBER() OVER ..."""
    try:
        conn.execute("DROP TABLE IF EXISTS _tmp_probe;")
        conn.execute("""
            CREATE TEMP TABLE _tmp_probe AS
            SELECT id, ROW_NUMBER() OVER (PARTITION BY company_id ORDER BY fecha, id) AS rn
            FROM events
            LIMIT 1;
        """)
        conn.execute("DROP TABLE IF EXISTS _tmp_probe;")
        return True
    except Exception:
        return False

def recompute_correlativo(company_id: Optional[int] = None) -> int:
    """
    Recalcula y persiste el correlativo por compañía en la tabla events.
    Si 'company_id' es None, lo hace para todas.
    Devuelve el número de filas actualizadas.
    """
    updated = 0
    with get_connection() as conn:
        have = _cols(conn, "events")
        if "correlativo" not in have:
            # la columna no existe; no hacemos nada
            return 0

        conn.row_factory = sqlite3.Row

        if company_id is None:
            companies = [r["id"] for r in conn.execute("SELECT id FROM companies").fetchall()]
        else:
            companies = [company_id]

        if _supports_row_number(conn):
            for cid in companies:
                conn.execute("""
                    WITH ordered AS (
                        SELECT id,
                               ROW_NUMBER() OVER (PARTITION BY company_id ORDER BY fecha, id) AS rn
                        FROM events
                        WHERE company_id=?
                    )
                    UPDATE events
                       SET correlativo = (SELECT rn FROM ordered WHERE ordered.id = events.id)
                     WHERE company_id=?;
                """, (cid, cid))
                updated += conn.total_changes
        else:
            # Fallback sin funciones ventana
            for cid in companies:
                cur = conn.execute("""
                    SELECT id
                    FROM events
                    WHERE company_id=?
                    ORDER BY fecha, id
                """, (cid,))
                rows = [r["id"] for r in cur.fetchall()]
                for i, eid in enumerate(rows, start=1):
                    conn.execute("UPDATE events SET correlativo=? WHERE id=?", (i, eid))
                    updated += 1

        conn.commit()
        
    log.info("Recompute correlativo company_id=%s updated_rows=%s",
         company_id if company_id is not None else "ALL", updated)
    
    return updated

def ensure_redenominacion_triggers() -> None:
    """
    Replica las validaciones SQL de V1 para REDENOMINACION, nominal y partes requeridas.
    Idempotente.
    """
    sql = r"""
    -- 1) Reglas de presencia mínima (similar a V1)
    CREATE TRIGGER IF NOT EXISTS trg_events_required_parties_ins
    BEFORE INSERT ON events
    BEGIN
        -- tipos que requieren adquirente/acreedor
        SELECT CASE
          WHEN NEW.tipo IN ('ALTA','AMPL_EMISION','TRANSMISION','PIGNORACION','EMBARGO','USUFRUCTO')
           AND NEW.socio_adquiere IS NULL
          THEN RAISE(ABORT, 'Falta socio adquirente/acreedor') END;

        -- tipos que requieren transmitente/titular
        SELECT CASE
          WHEN NEW.tipo IN ('TRANSMISION','BAJA','RED_AMORT','USUFRUCTO')
           AND NEW.socio_transmite IS NULL
          THEN RAISE(ABORT, 'Falta socio transmitente/titular') END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_required_parties_upd
    BEFORE UPDATE ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('ALTA','AMPL_EMISION','TRANSMISION','PIGNORACION','EMBARGO','USUFRUCTO')
           AND NEW.socio_adquiere IS NULL
          THEN RAISE(ABORT, 'Falta socio adquirente/acreedor') END;

        SELECT CASE
          WHEN NEW.tipo IN ('TRANSMISION','BAJA','RED_AMORT','USUFRUCTO')
           AND NEW.socio_transmite IS NULL
          THEN RAISE(ABORT, 'Falta socio transmitente/titular') END;
    END;

    -- 2) Modo REDENOMINACION: o GLOBAL (sin rangos y sin socios) o POR BLOQUE (con rangos y con socio).
    CREATE TRIGGER IF NOT EXISTS trg_events_reden_mode_ins
    BEFORE INSERT ON events
    WHEN NEW.tipo='REDENOMINACION'
    BEGIN
        SELECT CASE
          WHEN
            ((NEW.rango_desde IS NULL AND NEW.rango_hasta IS NULL AND NEW.socio_transmite IS NULL AND NEW.socio_adquiere IS NULL) OR
             (NEW.rango_desde IS NOT NULL AND NEW.rango_hasta IS NOT NULL AND (NEW.socio_transmite IS NOT NULL OR NEW.socio_adquiere IS NOT NULL)))
          THEN NULL
          ELSE RAISE(ABORT, 'REDENOMINACION: usa modo global (sin rangos y sin socios) o modo por bloque (con rangos y socio).')
        END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_reden_mode_upd
    BEFORE UPDATE ON events
    WHEN NEW.tipo='REDENOMINACION'
    BEGIN
        SELECT CASE
          WHEN
            ((NEW.rango_desde IS NULL AND NEW.rango_hasta IS NULL AND NEW.socio_transmite IS NULL AND NEW.socio_adquiere IS NULL) OR
             (NEW.rango_desde IS NOT NULL AND NEW.rango_hasta IS NOT NULL AND (NEW.socio_transmite IS NOT NULL OR NEW.socio_adquiere IS NOT NULL)))
          THEN NULL
          ELSE RAISE(ABORT, 'REDENOMINACION: usa modo global (sin rangos y sin socios) o modo por bloque (con rangos y socio).')
        END;
    END;

    -- 3) Nominal obligatorio para AMPL_VALOR/RED_VALOR; en REDENOMINACION es opcional pero si se informa debe ser > 0
    CREATE TRIGGER IF NOT EXISTS trg_events_check_nominal_ins
    BEFORE INSERT ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('AMPL_VALOR','RED_VALOR')
           AND (NEW.nuevo_valor_nominal IS NULL OR NEW.nuevo_valor_nominal <= 0)
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;

        SELECT CASE
          WHEN NEW.tipo='REDENOMINACION'
           AND NEW.nuevo_valor_nominal IS NOT NULL
           AND NEW.nuevo_valor_nominal <= 0
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;
    END;

    CREATE TRIGGER IF NOT EXISTS trg_events_check_nominal_upd
    BEFORE UPDATE ON events
    BEGIN
        SELECT CASE
          WHEN NEW.tipo IN ('AMPL_VALOR','RED_VALOR')
           AND (NEW.nuevo_valor_nominal IS NULL OR NEW.nuevo_valor_nominal <= 0)
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;

        SELECT CASE
          WHEN NEW.tipo='REDENOMINACION'
           AND NEW.nuevo_valor_nominal IS NOT NULL
           AND NEW.nuevo_valor_nominal <= 0
          THEN RAISE(ABORT, 'Nuevo valor nominal debe ser > 0') END;
    END;
    """
    with get_connection() as conn:
        conn.executescript(sql)

# >>>>>>>>>>>>> _review_correlativos/app/core/repositories/governance_repo.py <<<<<<<<<<<<<

from typing import Optional
from ...infra.db import get_connection
from .base import rows_to_dicts

def list_board(company_id: int) -> list[dict]:
    with get_connection() as conn:
        cur = conn.execute("""
            SELECT id, company_id, nombre, cargo, nif, direccion, telefono, email
            FROM board_members WHERE company_id=? ORDER BY id
        """, (company_id,))
        return rows_to_dicts(cur.fetchall())

def upsert_board_member(*, id: Optional[int], company_id: int, nombre: str, cargo: str, nif: str,
                        direccion: Optional[str], telefono: Optional[str], email: Optional[str]) -> int:
    with get_connection() as conn:
        if id:
            conn.execute(
                """UPDATE board_members
                   SET nombre=?, cargo=?, nif=?, direccion=?, telefono=?, email=?
                 WHERE id=? AND company_id=?""",
                (nombre, cargo, nif, direccion, telefono, email, id, company_id)
            )
            return id
        else:
            cur = conn.execute(
                """INSERT INTO board_members(company_id, nombre, cargo, nif, direccion, telefono, email)
                   VALUES(?,?,?,?,?,?,?)""",
                (company_id, nombre, cargo, nif, direccion, telefono, email)
            )
            return cur.lastrowid

def get_company_governance(company_id: int) -> dict | None:
    """Devuelve organo y firmantes_json desde companies."""
    with get_connection() as conn:
        cur = conn.execute(
            "SELECT organo, firmantes_json FROM companies WHERE id=?",
            (company_id,)
        )
        row = cur.fetchone()
        return dict(row) if row else None

# >>>>>>>>>>>>> _review_correlativos/app/core/repositories/partners_repo.py <<<<<<<<<<<<<

#app/core/repositories/partners_repo.py

from typing import Optional
from ...infra.db import get_connection
from .base import rows_to_dicts

def list_by_company(company_id: int) -> list[dict]:
    with get_connection() as conn:
        conn.row_factory = lambda c, r: {c.description[i][0]: r[i] for i in range(len(r))}
        cur = conn.execute("""
            SELECT id, company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion
            FROM partners WHERE company_id=? ORDER BY nombre
        """, (company_id,))
        return cur.fetchall()

def upsert_partner(*, id: Optional[int], company_id: int, nombre: str, nif: str,
                   domicilio: Optional[str], nacionalidad: Optional[str],
                   fecha_nacimiento_constitucion: Optional[str]) -> int:
    with get_connection() as conn:
        if id:
            conn.execute(
                """UPDATE partners
                   SET nombre=?, nif=?, domicilio=?, nacionalidad=?, fecha_nacimiento_constitucion=?
                 WHERE id=? AND company_id=?""",
                (nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion, id, company_id)
            )
            return id
        else:
            cur = conn.execute(
                """INSERT INTO partners(company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion)
                   VALUES(?,?,?,?,?,?)""",
                (company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion)
            )
            return cur.lastrowid
        
def get_partner(company_id: int, partner_id: int) -> dict | None:
    from ...infra.db import get_connection
    with get_connection() as conn:
        cur = conn.execute("""
            SELECT id, company_id, nombre, nif, domicilio, nacionalidad, fecha_nacimiento_constitucion
            FROM partners WHERE id=? AND company_id=?
        """, (partner_id, company_id))
        row = cur.fetchone()
        return dict(row) if row else None

# >>>>>>>>>>>>> _review_correlativos/app/core/services/backup_service.py <<<<<<<<<<<<<

from __future__ import annotations
from pathlib import Path
from datetime import datetime
import shutil
import logging

log = logging.getLogger(__name__)

DATA_DIR = Path(__file__).resolve().parents[3] / "data"
DB_FILE  = DATA_DIR / "libro_socios.db"
BK_DIR   = DATA_DIR / "backups"
BK_DIR.mkdir(parents=True, exist_ok=True)

def _sidecar_files(base: Path) -> list[Path]:
    # Soporta journal WAL de SQLite
    return [base.with_suffix(base.suffix + sfx) for sfx in ("-wal", "-shm")]

def create_backup() -> list[Path]:
    """
    Crea un backup consistente del fichero principal y sus sidecars si existen.
    Devuelve la lista de rutas creadas.
    """
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    created: list[Path] = []
    if not DB_FILE.exists():
        raise FileNotFoundError(f"No existe la BD: {DB_FILE}")

    dst_main = BK_DIR / f"libro_socios_{ts}.db"
    shutil.copy2(DB_FILE, dst_main)
    created.append(dst_main)

    for s in _sidecar_files(DB_FILE):
        if s.exists():
            dst = BK_DIR / f"{s.stem}_{ts}{s.suffix}".replace("-wal_", "_").replace("-shm_", "_")
            shutil.copy2(s, dst)
            created.append(dst)

    log.info("Backup creado: %s", ", ".join(str(p.name) for p in created))
    return created

def list_backups() -> list[Path]:
    # Muestra .db y posibles wal/shm asociados
    files = sorted(BK_DIR.glob("libro_socios_*.db"))
    return files

def restore_backup(backup_db_path: Path) -> list[Path]:
    """
    Restaura desde un .db de backups. Hace copia de seguridad del actual como _pre_restore_*.db
    Retorna lista de archivos restaurados.
    """
    if not backup_db_path.exists():
        raise FileNotFoundError(str(backup_db_path))

    restored: list[Path] = []

    # Copia de seguridad del actual
    safe = BK_DIR / f"_pre_restore_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
    shutil.copy2(DB_FILE, safe)
    log.warning("Backup previo (pre-restore) guardado como: %s", safe.name)

    # Restaurar principal
    shutil.copy2(backup_db_path, DB_FILE)
    restored.append(DB_FILE)

    # Limpiar/renombrar sidecars actuales si existen
    for s in _sidecar_files(DB_FILE):
        if s.exists():
            s.unlink(missing_ok=True)

    # Si existieran wal/shm con mismo timestamp, restáuralos
    stem = backup_db_path.stem.replace("libro_socios_", "")
    wal_src = BK_DIR / f"libro_socios_{stem}.db-wal"
    shm_src = BK_DIR / f"libro_socios_{stem}.db-shm"
    for src, dst in [(wal_src, DB_FILE.with_suffix(DB_FILE.suffix + "-wal")),
                     (shm_src, DB_FILE.with_suffix(DB_FILE.suffix + "-shm"))]:
        if src.exists():
            shutil.copy2(src, dst)
            restored.append(dst)

    log.warning("Restauración completada desde: %s", backup_db_path.name)
    return restored

# >>>>>>>>>>>>> _review_correlativos/app/core/services/compute_service.py <<<<<<<<<<<<<

#app/core/services/compute_service.py

from __future__ import annotations
from typing import Dict, List, Optional, Tuple
from decimal import Decimal, ROUND_FLOOR
from ..repositories import events_repo, partners_repo, companies_repo
from ..enums import normalize_event_type

# ---------- utilidades de bloques ----------
def _split_block(block: dict, d:int, h:int) -> list[dict]:
    res = []
    a, b = block['rango_desde'], block['rango_hasta']
    if d is None or h is None:
        return [block]
    if h < a or d > b:
        return [block]
    if d > a:
        res.append({**block, 'rango_desde': a, 'rango_hasta': d-1})
    if h < b:
        res.append({**block, 'rango_desde': h+1, 'rango_hasta': b})
    return res

def _len_block(b: dict) -> int:
    return (b['rango_hasta'] - b['rango_desde'] + 1)

def _consolidate(blocks: list[dict]) -> list[dict]:
    clean = [b for b in blocks if b.get('rango_desde') is not None and b.get('rango_hasta') is not None]
    if not clean:
        return []
    clean = sorted(clean, key=lambda x: (x['socio_id'], x['right_type'], x['rango_desde'], x['rango_hasta']))
    merged = [clean[0].copy()]
    merged[0]["participaciones"] = _len_block(merged[0])
    for b in clean[1:]:
        last = merged[-1]
        if (
            b['socio_id']==last['socio_id']
            and b['right_type']==last['right_type']
            and b['rango_desde']==last['rango_hasta']+1
        ):
            last['rango_hasta'] = b['rango_hasta']
            last['participaciones'] = _len_block(last)
        else:
            nb = b.copy()
            nb["participaciones"] = _len_block(nb)
            merged.append(nb)
    return merged

# ---------- motor de aplicación (port v1, con tipos normalizados) ----------
def _apply_events(events: list[dict], valor_nominal_inicial: float = 5.0, part_tot_inicial: int = 0):
    from collections import defaultdict
    from datetime import date

    blocks: list[dict] = []
    valor_nominal = valor_nominal_inicial
    total_part = part_tot_inicial
    last_fecha = str(date.today())

    # agrupar por fecha
    by_date = defaultdict(list)
    for ev in events:
        ev = ev.copy()
        ev["tipo"] = normalize_event_type(ev.get("tipo"))
        by_date[str(ev["fecha"])] .append(ev)

    for f in sorted(by_date.keys()):
        day = by_date[f]
        last_fecha = f

        def _get_range(e):
            return (e.get('rango_desde') or 0, e.get('rango_hasta') or 0)

        # 1) BAJA / RED_AMORT (quitan)
        for ev in sorted([e for e in day if e.get('tipo') in ('BAJA','RED_AMORT')], key=_get_range):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            new_blocks = []
            for b in blocks:
                if b['right_type']=='plena' and b['socio_id']==ev.get('socio_transmite'):
                    new_blocks.extend(_split_block(b, d, h))
                else:
                    new_blocks.append(b)
            blocks = _consolidate(new_blocks)

        # 2) TRANSMISION / SUCESION (mueven)
        for ev in sorted([e for e in day if e.get('tipo') in ('TRANSMISION','SUCESION')], key=_get_range):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            new_blocks = []
            for b in blocks:
                if b['right_type']=='plena' and b['socio_id']==ev.get('socio_transmite'):
                    new_blocks.extend(_split_block(b, d, h))
                else:
                    new_blocks.append(b)
            blocks = _consolidate(new_blocks)
            blocks.append(dict(socio_id=ev.get('socio_adquiere'), right_type='plena', rango_desde=d, rango_hasta=h))
            blocks = _consolidate(blocks)

        # 3) ALTA / AMPL_EMISION (añaden)
        for ev in sorted([e for e in day if e.get('tipo') in ('ALTA','AMPL_EMISION')], key=_get_range):
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            blocks.append(dict(socio_id=ev.get('socio_adquiere'), right_type='plena', rango_desde=d, rango_hasta=h))
            if h:
                total_part = max(total_part, h)
            blocks = _consolidate(blocks)

        # 4) USUFRUCTO / PIGNORACION / EMBARGO y AMPL_VALOR / RED_VALOR
        for ev in [e for e in day if e.get('tipo') in ('USUFRUCTO','PIGNORACION','EMBARGO')]:
            d, h = ev.get('rango_desde'), ev.get('rango_hasta')
            if ev.get('tipo') == 'USUFRUCTO':
                new_blocks = []
                for b in blocks:
                    if b['right_type']=='plena' and b['socio_id']==ev.get('socio_transmite'):
                        new_blocks.extend(_split_block(b, d, h))
                    else:
                        new_blocks.append(b)
                new_blocks.append(dict(socio_id=ev.get('socio_transmite'), right_type='nuda', rango_desde=d, rango_hasta=h))
                new_blocks.append(dict(socio_id=ev.get('socio_adquiere'),  right_type='usufructo', rango_desde=d, rango_hasta=h))
                blocks = _consolidate(new_blocks)
            else:
                holder = ev.get('socio_adquiere') or ev.get('socio_transmite')
                blocks.append(dict(socio_id=holder, right_type=('prenda' if ev.get('tipo')=='PIGNORACION' else 'embargo'),
                                   rango_desde=d, rango_hasta=h))
                blocks = _consolidate(blocks)

        for ev in [e for e in day if e.get('tipo') in ('AMPL_VALOR','RED_VALOR')]:
            nv = ev.get('nuevo_valor_nominal')
            if nv is not None:
                valor_nominal = float(nv)

        # 5) REDENOMINACION (al cierre del día)
        if any(e.get('tipo') == 'REDENOMINACION' for e in day):
            # suma por socio ('plena' vigente)
            current: Dict[int, int] = {}
            for b in blocks:
                if b['right_type'] != 'plena':
                    continue
                n = _len_block(b)
                current[b['socio_id']] = current.get(b['socio_id'], 0) + n

            old_total = sum(current.values())
            old_vn = Decimal(str(valor_nominal))
            old_capital = old_vn * Decimal(old_total)

            # VN nuevo (opcional, pero si viene debe ser único y > 0)
            vn_candidates = [e.get('nuevo_valor_nominal') for e in day if e.get('tipo') == 'REDENOMINACION' and e.get('nuevo_valor_nominal') not in (None, "")]
            new_vn = None
            if vn_candidates:
                vals = [float(v) for v in vn_candidates]
                if len({round(v, 6) for v in vals}) > 1:
                    raise ValueError(f"Valores nominales distintos en REDENOMINACION del día {f}: {vals}")
                new_vn = Decimal(str(vals[-1]))
                if new_vn <= 0:
                    raise ValueError(f"Nuevo valor nominal inválido en REDENOMINACION del día {f}: {new_vn}")

            if new_vn is None:
                new_total = old_total
            else:
                ratio = (old_capital / new_vn)
                if ratio != ratio.to_integral_value():
                    raise ValueError(f"El capital {old_capital} no es múltiplo del nuevo VN {new_vn} en REDENOMINACION del día {f}.")
                new_total = int(ratio)
                valor_nominal = float(new_vn)

            # Reasignación proporcional por restos (enteros, suma exacta)
            if old_total == 0:
                blocks = _consolidate(blocks)
                total_part = 0
            else:
                socios = sorted(current.keys())
                exact = {sid: (Decimal(current[sid]) * Decimal(str(new_total)) / Decimal(old_total)) for sid in socios}
                base  = {sid: int(exact[sid].to_integral_value(rounding=ROUND_FLOOR)) for sid in socios}
                asignadas = sum(base.values())
                resto = new_total - asignadas
                fracs = sorted([(sid, (exact[sid] - Decimal(base[sid]))) for sid in socios], key=lambda x: (x[1], -x[0]), reverse=True)
                for i in range(resto):
                    base[fracs[i][0]] += 1

                cursor = 1
                new_blocks = []
                for sid in socios:
                    n = base[sid]
                    if n <= 0:
                        continue
                    new_blocks.append(dict(socio_id=sid, right_type='plena', rango_desde=cursor, rango_hasta=cursor+n-1))
                    cursor += n
                blocks = _consolidate(new_blocks)
                total_part = new_total

        # ajuste fin día: recalcula total por bloques 'plena'
        total_part = sum(_len_block(b) for b in blocks if b['right_type'] == 'plena')

    return blocks, valor_nominal, total_part, last_fecha

# ---------- interfaz alto nivel ----------
def compute_snapshot(company_id: int, hasta_fecha: Optional[str] = None) -> dict:
    partners = {p["id"]: p for p in partners_repo.list_by_company(company_id)}
    events = events_repo.list_events_upto(company_id, hasta_fecha)
    company = companies_repo.get_company(company_id) or {}

    vn_ini = company.get("valor_nominal") or 5.0
    part_tot_ini = company.get("participaciones_totales") or 0

    blocks, valor_nominal, total_part, _ = _apply_events(events, float(vn_ini), int(part_tot_ini))

    # holdings (vigentes)
    holdings_rows = []
    for b in blocks:
        if b["right_type"] != "plena":
            continue
        pid = b["socio_id"]
        p = partners.get(pid) or {}
        holdings_rows.append({
            "partner_id": pid,
            "nombre": p.get("nombre") or f"Socio {pid}",
            "right_type": "plena",
            "rango_desde": b["rango_desde"],
            "rango_hasta": b["rango_hasta"],
            "participaciones": _len_block(b),
        })

    # agregados por socio vigente
    agreg: Dict[int, int] = {}
    for r in holdings_rows:
        agreg[r["partner_id"]] = agreg.get(r["partner_id"], 0) + int(r["participaciones"])

    socios_vigentes = []
    for pid, qty in sorted(agreg.items(), key=lambda t: (-t[1], partners.get(t[0], {}).get("nombre",""))):
        if qty <= 0: 
            continue
        p = partners.get(pid) or {}
        pct = (qty / total_part * 100.0) if total_part else 0.0
        capital_socio = float(valor_nominal) * float(qty) if valor_nominal is not None else None
        socios_vigentes.append({
            "partner_id": pid,
            "nombre": p.get("nombre"),
            "nif": p.get("nif"),
            "participaciones": qty,
            "porcentaje": round(pct, 6),
            "capital_socio": capital_socio,
        })

    # todos los socios (presentes y pasados, sin histórico de movimientos)
    todos_socios = []
    for p in partners.values():
        todos_socios.append({
            "partner_id": p["id"],
            "nombre": p.get("nombre"),
            "nif": p.get("nif"),
            "domicilio": p.get("domicilio"),
            "nacionalidad": p.get("nacionalidad"),
        })

    return {
        "socios_vigentes": socios_vigentes,
        "holdings_vigentes": holdings_rows,
        "todos_socios": sorted(todos_socios, key=lambda x: x["nombre"] or ""),
        "meta": {
            "a_fecha": hasta_fecha,
            "total_participaciones": total_part,
            "valor_nominal": valor_nominal,
            "capital_social": (float(valor_nominal) * float(total_part)) if valor_nominal is not None else None,
        },
    }

# >>>>>>>>>>>>> _review_correlativos/app/core/services/events_service.py <<<<<<<<<<<<<

# app/core/services/events_service.py

from __future__ import annotations
from typing import Optional, Any
from datetime import datetime
import sqlite3

from ..repositories import events_repo, partners_repo
from ...infra.db import get_connection

# === Asegura triggers tipo V1 al cargar el servicio (idempotente) ===
try:
    from ..repositories.events_repo import ensure_redenominacion_triggers
    ensure_redenominacion_triggers()
except Exception:
    # No bloquear la app si falla en caliente; puedes exponer un botón de "Autochequeo" para relanzarlo.
    pass


# ---------- LISTADOS ----------

def list_events(company_id: int) -> list[dict]:
    """Listado raw (con IDs) para edición."""
    return events_repo.list_events_upto(company_id, None)


def list_events_for_ui(company_id: int) -> list[dict]:
    """Listado preparado para UI (mapea IDs de socios a nombres)."""
    rows = events_repo.list_events_upto(company_id, None)
    partners = {p["id"]: p.get("nombre") for p in partners_repo.list_by_company(company_id)}
    out = []
    for r in rows:
        out.append({
            "id": r.get("id"),
            "correlativo": r.get("correlativo"),
            "fecha": r.get("fecha"),
            "tipo": r.get("tipo"),
            "socio_transmite": partners.get(r.get("socio_transmite")) if r.get("socio_transmite") else None,
            "socio_adquiere": partners.get(r.get("socio_adquiere")) if r.get("socio_adquiere") else None,
            "rango_desde": r.get("rango_desde"),
            "rango_hasta": r.get("rango_hasta"),
            "nuevo_valor_nominal": r.get("nuevo_valor_nominal"),
            "documento": r.get("documento"),
            "observaciones": r.get("observaciones"),
        })
    return out


# ---------- CRUD ----------

_ALLOWED_FIELDS = {
    "company_id", "fecha", "tipo",
    "socio_transmite", "socio_adquiere",
    "rango_desde", "rango_hasta",
    "nuevo_valor_nominal",
    "documento", "observaciones",
    "hora", "orden_del_dia",
    # Columna física para la cantidad:
    "n_participaciones",
    # Si tu tabla tiene timestamps, puedes añadir:
    # "created_at", "updated_at",
}


def _now_iso() -> str:
    return datetime.now().isoformat(timespec="seconds")


def create_event_generic(
    *,
    company_id: int,
    tipo: str,
    fecha: str,
    socio_transmite: Optional[int] = None,
    socio_adquiere: Optional[int] = None,
    rango_desde: Optional[int] = None,
    rango_hasta: Optional[int] = None,
    # Alias admitidos (cualquiera puede venir o ninguno):
    n_participaciones: Optional[int] = None,
    num_participaciones: Optional[int] = None,
    participaciones: Optional[int] = None,
    cantidad: Optional[int] = None,
    nuevo_valor_nominal: Optional[float] = None,
    documento: Optional[str] = None,
    observaciones: Optional[str] = None,
    **kwargs: Any,
) -> int:
    """
    Inserta un evento en la tabla 'events' aceptando alias de cantidad y normalizando a 'n_participaciones'.
    Evita depender de events_repo.create_event (no existe en V2).
    """
    # 1) Normalización de tipo/fecha
    tipo = (tipo or "").upper().strip()
    fecha = str(fecha)

    # 2) Resolver número de participaciones a partir de los alias recibidos
    canon_num = None
    for candidate in (n_participaciones, num_participaciones, participaciones, cantidad):
        if candidate is not None:
            canon_num = int(candidate)
            break

    # (Opcional) endurecer validación por tipo:
    # requires_qty = tipo in {"ALTA", "BAJA", "AMPL_EMISION", "RED_AMORT", "TRANSMISION"}
    # if requires_qty and canon_num is None:
    #     raise ValueError(f"El tipo {tipo} requiere indicar el número de participaciones.")
    # if canon_num is not None and canon_num <= 0:
    #     raise ValueError("El número de participaciones debe ser un entero positivo.")

    # 3) Construir el diccionario de campos a insertar (sólo los permitidos)
    fields: dict[str, Any] = {
        "company_id": company_id,
        "tipo": tipo,
        "fecha": fecha,
        "socio_transmite": socio_transmite,
        "socio_adquiere": socio_adquiere,
        "rango_desde": rango_desde,
        "rango_hasta": rango_hasta,
        "nuevo_valor_nominal": float(nuevo_valor_nominal) if nuevo_valor_nominal is not None else None,
        "documento": documento,
        "observaciones": observaciones,
        # Si usas timestamps:
        # "created_at": _now_iso(),
        # "updated_at": _now_iso(),
    }

    # Si hay número (canon_num), lo volcamos a la columna física n_participaciones
    if canon_num is not None:
        fields["n_participaciones"] = int(canon_num)

    # 4) Filtrar sólo columnas permitidas y no-None para la INSERT
    cols = []
    vals = []
    for k, v in fields.items():
        if k in _ALLOWED_FIELDS and v is not None:
            cols.append(k)
            vals.append(v)

    if not cols:
        raise ValueError("No hay campos válidos para insertar el evento.")

    placeholders = ", ".join(["?"] * len(cols))
    colnames = ", ".join(cols)

    # 5) Ejecutar la INSERT y devolver el id
    with get_connection() as conn:
        cur = conn.execute(f"INSERT INTO events ({colnames}) VALUES ({placeholders})", vals)
        conn.commit()
        return cur.lastrowid


def get_event(company_id: int, event_id_or_corr: int) -> Optional[dict]:
    """
    Busca primero por ID; si no existe, intenta por correlativo.
    Devuelve el evento como dict o None si no lo encuentra.
    """
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row

        # 1) Buscar por ID
        row = conn.execute(
            "SELECT * FROM events WHERE company_id=? AND id=? LIMIT 1",
            (company_id, int(event_id_or_corr)),
        ).fetchone()

        # 2) Si no hay, buscar por correlativo
        if not row:
            row = conn.execute(
                "SELECT * FROM events WHERE company_id=? AND correlativo=? LIMIT 1",
                (company_id, int(event_id_or_corr)),
            ).fetchone()

    return dict(row) if row else None


def update_event(
    *,
    event_id: int,
    company_id: int,
    tipo: Optional[str] = None,
    fecha: Optional[str] = None,
    socio_transmite: Optional[int] = None,
    socio_adquiere: Optional[int] = None,
    rango_desde: Optional[int] = None,
    rango_hasta: Optional[int] = None,
    n_participaciones: Optional[int] = None,
    nuevo_valor_nominal: Optional[float] = None,
    documento: Optional[str] = None,
    observaciones: Optional[str] = None,
    hora: Optional[str] = None,
    orden_del_dia: Optional[int] = None,
) -> int:
    # (Opcional) Validación suave del número de participaciones
    if n_participaciones is not None:
        try:
            n_participaciones = int(n_participaciones)
        except Exception as _e:
            raise ValueError("n_participaciones debe ser un entero.")
        if n_participaciones < 0:
            raise ValueError("n_participaciones debe ser un entero ≥ 0.")

    fields = {
        "tipo": (tipo or "").upper().strip() if tipo is not None else None,
        "fecha": fecha,
        "socio_transmite": socio_transmite,
        "socio_adquiere": socio_adquiere,
        "rango_desde": rango_desde,
        "rango_hasta": rango_hasta,
        "n_participaciones": n_participaciones,
        "nuevo_valor_nominal": nuevo_valor_nominal,
        "documento": documento,
        "observaciones": observaciones,
        "hora": hora,
        "orden_del_dia": orden_del_dia,
        # "updated_at": _now_iso(),
    }
    sets = []
    vals = []
    for k, v in fields.items():
        if v is not None:
            sets.append(f"{k}=?")
            vals.append(v)
    if not sets:
        return 0
    vals.extend([event_id, company_id])

    with get_connection() as conn:
        cur = conn.execute(f"UPDATE events SET {', '.join(sets)} WHERE id=? AND company_id=?", vals)
        conn.commit()
        return cur.rowcount


def delete_event(*, event_id: int, company_id: int) -> int:
    with get_connection() as conn:
        cur = conn.execute("DELETE FROM events WHERE id=? AND company_id=?", (event_id, company_id))
        conn.commit()
        return cur.rowcount


# ---------- Atajos específicos de negocio (si los usas) ----------

def apply_sucesion(
    *,
    company_id: int,
    fecha: str,
    socio_causante_id: int,
    socio_heredero_id: int,
    n_participaciones: int,
    referencia: Optional[str] = None
) -> int:
    """
    Sucesión: transmisión. Si trabajas por rangos, la UI debería aportar RD–RH concretos;
    aquí dejamos None (depende de tu editor por rangos).
    """
    return create_event_generic(
        company_id=company_id,
        tipo="SUCESION",
        fecha=fecha,
        socio_transmite=socio_causante_id,
        socio_adquiere=socio_heredero_id,
        rango_desde=None,
        rango_hasta=None,
        n_participaciones=n_participaciones,
        observaciones=referencia,
    )


def apply_reduccion_amortizacion(
    *,
    company_id: int,
    fecha: str,
    modalidad: str,
    n_participaciones: int,
    referencia: Optional[str] = None,
    socio_afectado_id: Optional[int] = None
) -> int:
    """
    Reducción por amortización. Si operas por rangos, aporta RD–RH desde la UI.
    """
    return create_event_generic(
        company_id=company_id,
        tipo="RED_AMORT",
        fecha=fecha,
        socio_transmite=socio_afectado_id,
        socio_adquiere=None,
        rango_desde=None,
        rango_hasta=None,
        n_participaciones=n_participaciones,
        observaciones=referencia,
    )


# ---------- CREACIÓN ESPECÍFICA: REDENOMINACION ----------

def create_redenominacion(
    *,
    company_id: int,
    fecha: str,
    por_bloque: bool,
    socio_id: Optional[int] = None,
    rango_desde: Optional[int] = None,
    rango_hasta: Optional[int] = None,
    recalcular_numero: bool = False,
    nuevo_valor_nominal: Optional[float] = None,
    documento: Optional[str] = None,
    observaciones: Optional[str] = None,
) -> int:
    """
    Replica reglas de V1:
      - GLOBAL: sin socio/rangos. Si 'recalcular_numero' => VN obligatorio > 0 (capital debe ser múltiplo de VN).
      - POR BLOQUE: requiere socio y RD–RH; NO recalcula nº total; VN opcional (sólo constancia).
      - Validaciones legales previas (mensajes claros).
    """
    fecha = str(fecha)

    if recalcular_numero and (nuevo_valor_nominal is None or float(nuevo_valor_nominal) <= 0.0):
        raise ValueError("Para recalcular el número de participaciones debes indicar un VN > 0.")

    if por_bloque:
        if not socio_id:
            raise ValueError("En redenominación por bloque debes indicar el socio titular del bloque.")
        if not (rango_desde and rango_hasta and int(rango_hasta) >= int(rango_desde)):
            raise ValueError("En redenominación por bloque debes indicar un rango RD–RH válido.")
        if recalcular_numero:
            raise ValueError("El recálculo del número de participaciones sólo aplica en modo global.")

        socio_transmite = int(socio_id)
        socio_adquiere = None
        rd, rh = int(rango_desde), int(rango_hasta)
        nv = float(nuevo_valor_nominal) if nuevo_valor_nominal else None
    else:
        # GLOBAL: sin socios ni rangos
        socio_transmite = None
        socio_adquiere = None
        rd = rh = None
        # Sólo guardamos VN si estamos en recálculo; en constancia global VN es opcional y puede omitirse
        nv = float(nuevo_valor_nominal) if (recalcular_numero and nuevo_valor_nominal) else None

    # Inserta el evento; el compute_service aplicará la lógica y validará múltiplos/rounding como en V1.
    new_id = create_event_generic(
        company_id=company_id,
        tipo="REDENOMINACION",
        fecha=fecha,
        socio_transmite=socio_transmite,
        socio_adquiere=socio_adquiere,
        rango_desde=rd,
        rango_hasta=rh,
        # No indicamos n_participaciones en redenominación
        nuevo_valor_nominal=nv,
        documento=documento or None,
        observaciones=observaciones or None,
    )
    return new_id

# >>>>>>>>>>>>> _review_correlativos/app/core/services/export_service.py <<<<<<<<<<<<<

# app/core/services/export_service.py
from __future__ import annotations

import logging
import sqlite3
from typing import Optional, List, Iterable
from io import BytesIO
from datetime import datetime
from reportlab.pdfbase import pdfmetrics

import pandas as pd
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4, landscape
from reportlab.lib.units import mm
from reportlab.lib import colors

from app.infra.pdf_fonts import register_fonts as ensure_pdf_base_fonts
from app.infra.db import get_connection
from app.core.services.reporting_service import (
    cap_table, movements, partner_position, last_entries_for_partner,
    partner_holdings_ranges, active_encumbrances, active_encumbrances_affecting_partner,
)

log = logging.getLogger(__name__)

# ============================================================
#  Constantes visuales comunes (PDF)
# ============================================================
MARGIN_X = 18 * mm
LINE_GAP = 5 * mm
SECTION_GAP = 7 * mm
CONTENT_GAP = 6 * mm


# ============================================================
#  Utilidades PDF comunes
# ============================================================
def _hr(c: canvas.Canvas, y: float, x0: float = MARGIN_X, x1: float = A4[0] - MARGIN_X):
    c.setStrokeColor(colors.lightgrey)
    c.setLineWidth(0.7)
    c.line(x0, y, x1, y)


def _kv(c: canvas.Canvas, y: float, key: str, value: str) -> float:
    c.setFont("DejaVuSans", 9.5)
    c.drawString(MARGIN_X, y, f"{key}: ")
    c.setFont("DejaVuSans-Oblique", 9.5)
    c.drawString(MARGIN_X + 70 * mm, y, value or "—")
    return y - LINE_GAP


def _col(c: canvas.Canvas, x: float, y: float, text: str, size: float = 9.0, maxw: float | None = None):
    c.setFont("DejaVuSans", size)
    t = ("" if text is None else str(text))
    if maxw is None:
        c.drawString(x, y, t)
    else:
        while c.stringWidth(t, "DejaVuSans", size) > maxw and len(t) > 3:
            t = t[:-4] + "…"
        c.drawString(x, y, t)


def _section_title(c: canvas.Canvas, title: str, y: float) -> float:
    c.setFillColorRGB(0.95, 0.95, 0.95)
    c.rect(MARGIN_X, y - 6 * mm, (A4[0] - 2 * MARGIN_X), 8 * mm, stroke=0, fill=1)
    c.setFillColor(colors.black)
    c.setFont("DejaVuSans", 10)
    c.drawString(MARGIN_X + 2 * mm, y - 4 * mm, title.upper())
    return y - SECTION_GAP - 6 * mm

def _draw_paragraph(c, text: str, x: float, y: float, max_width: float, leading: float = 12.0, font="DejaVuSans", font_size=9):
    """
    Dibuja un párrafo con ajuste de línea al ancho disponible.
    Devuelve la nueva coordenada Y tras el párrafo (línea siguiente).
    """
    if not text:
        return y
    c.setFont(font, font_size)

    space_w = pdfmetrics.stringWidth(" ", font, font_size)
    line = ""
    line_w = 0.0

    def flush(curr_line, yy):
        if curr_line:
            c.drawString(x, yy, curr_line)
            yy -= leading
        return yy

    yy = y
    for word in text.split():
        w = pdfmetrics.stringWidth(word, font, font_size)
        if line and (line_w + space_w + w) > max_width:
            yy = flush(line, yy)
            line = word
            line_w = w
        else:
            if line:
                line += " " + word
                line_w += space_w + w
            else:
                line = word
                line_w = w
    yy = flush(line, yy)
    return yy

# ============================================================
#  Lookups / cabeceras reales (no inventamos columnas)
# ============================================================
def _partners_lookup(company_id: int) -> dict[int, dict]:
    """id -> {'nombre': ..., 'nif': ..., 'nacionalidad': ..., 'domicilio': ...}"""
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            "SELECT id, nombre, nif, nacionalidad, domicilio FROM partners WHERE company_id=? ORDER BY id",
            (company_id,)
        ).fetchall()
    return {
        int(r["id"]): {
            "nombre": r["nombre"] or "",
            "nif": r["nif"] or "",
            "nacionalidad": r["nacionalidad"] or "",
            "domicilio": r["domicilio"] or "",
        }
        for r in rows
    }


def _company_header(company_id: int) -> dict:
    """
    name, cif, domicilio, fecha_constitucion (coincide con tu companies_repo.py)
    """
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT name, cif, domicilio, fecha_constitucion FROM companies WHERE id=?",
            (company_id,)
        ).fetchone()

    if not row:
        return {"name": "", "cif": "", "domicilio": "", "fecha_constitucion": ""}

    return {
        "name": row["name"] or "",
        "cif": row["cif"] or "",
        "domicilio": row["domicilio"] or "",
        "fecha_constitucion": str(row["fecha_constitucion"] or "") or "",
    }


def _partner_id_by_nif_or_name(company_id: int, nombre: str | None, nif: str | None) -> int | None:
    if not nombre and not nif:
        return None
    with get_connection() as conn:
        if nif:
            r = conn.execute(
                "SELECT id FROM partners WHERE company_id=? AND nif=? LIMIT 1",
                (company_id, nif)
            ).fetchone()
            if r:
                return int(r[0])
        if nombre:
            r = conn.execute(
                "SELECT id FROM partners WHERE company_id=? AND nombre=? LIMIT 1",
                (company_id, nombre)
            ).fetchone()
            if r:
                return int(r[0])
    return None


# ============================================================
#  Construcción de filas del LIBRO (usando columnas reales)
# ============================================================
def _ledger_rows(company_id: int,
                 date_from: str | None,
                 date_to: str | None,
                 event_types: list[str] | None) -> pd.DataFrame:
    """
    DataFrame con: fecha, correlativo, tipo, documento, socio_transmite/adquiere,
    rango_desde/hasta, participaciones (derivadas), nuevo_valor_nominal, observaciones.
    """
    with get_connection() as conn:
        conn.row_factory = sqlite3.Row
        sql = """
        SELECT id, correlativo, fecha, tipo,
               socio_transmite, socio_adquiere,
               rango_desde, rango_hasta,
               nuevo_valor_nominal,
               documento, observaciones
        FROM events
        WHERE company_id=?
        """
        params: list = [company_id]
        if date_from:
            sql += " AND fecha>=?"
            params.append(date_from)
        if date_to:
            sql += " AND fecha<=?"
            params.append(date_to)
        if event_types:
            sql += f" AND tipo IN ({','.join(['?']*len(event_types))})"
            params.extend(event_types)
        sql += " ORDER BY fecha, id"

        rows = conn.execute(sql, params).fetchall()

    pmap = _partners_lookup(company_id)
    out = []
    for r in rows:
        st_id = r["socio_transmite"]
        sa_id = r["socio_adquiere"]
        rd = r["rango_desde"]
        rh = r["rango_hasta"]

        # nº participaciones como (hasta - desde + 1) cuando haya rangos
        n_parts = None
        if rd is not None and rh is not None:
            try:
                n_parts = int(rh) - int(rd) + 1
            except Exception:
                n_parts = None

        out.append({
            "correlativo": r["correlativo"],
            "fecha": r["fecha"],
            "tipo": r["tipo"],
            "documento": r["documento"] or "",
            "socio_transmite_id": st_id,
            "socio_transmite_nombre": pmap.get(int(st_id), {}).get("nombre", "") if st_id else "",
            "socio_transmite_nif":    pmap.get(int(st_id), {}).get("nif", "")    if st_id else "",
            "socio_adquiere_id": sa_id,
            "socio_adquiere_nombre": pmap.get(int(sa_id), {}).get("nombre", "") if sa_id else "",
            "socio_adquiere_nif":    pmap.get(int(sa_id), {}).get("nif", "")    if sa_id else "",
            "rango_desde": rd,
            "rango_hasta": rh,
            "participaciones": n_parts,
            "nuevo_valor_nominal": r["nuevo_valor_nominal"],
            "observaciones": r["observaciones"] or "",
        })
    return pd.DataFrame(out)


# ============================================================
#  EXCEL: Cap table & Movimientos (existentes)
# ============================================================
def export_cap_table_excel(company_id: int, as_of: str | None = None) -> BytesIO:
    """
    Genera un Excel con la cap table a fecha.
    """
    try:
        df = cap_table(company_id, as_of)
        output = BytesIO()
        with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
            df.to_excel(writer, index=False, sheet_name="CapTable")
            wb = writer.book
            ws = writer.sheets["CapTable"]
            fmt_int = wb.add_format({"num_format": "#,##0"})
            fmt_pct = wb.add_format({"num_format": "0.0000"})
            # Ajuste columnas
            for i, col in enumerate(df.columns):
                try:
                    width = max(12, min(40, int(df[col].astype(str).str.len().quantile(0.9)) + 2))
                except Exception:
                    width = 16
                ws.set_column(i, i, width)
            # Formatos
            if "shares" in df.columns:
                col_idx = df.columns.get_loc("shares")
                ws.set_column(col_idx, col_idx, 14, fmt_int)
            if "pct" in df.columns:
                col_idx = df.columns.get_loc("pct")
                ws.set_column(col_idx, col_idx, 10, fmt_pct)
        output.seek(0)
        log.info("Export CapTable.xlsx company_id=%s as_of=%s rows=%s",
                 company_id, as_of, len(df))
        return output
    except Exception as e:
        log.error("Error exportando CapTable.xlsx company_id=%s as_of=%s: %s",
                  company_id, as_of, e, exc_info=True)
        raise


def export_movements_excel(company_id: int,
                           date_from: Optional[str],
                           date_to: Optional[str],
                           event_types: Optional[List[str]]) -> BytesIO:
    """
    Genera un Excel con los movimientos filtrados (tal como los devuelve reporting_service.movements).
    """
    try:
        df = movements(company_id, date_from, date_to, event_types)
        output = BytesIO()
        with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
            df.to_excel(writer, index=False, sheet_name="Movimientos")
            wb = writer.book
            ws = writer.sheets["Movimientos"]
            fmt_int = wb.add_format({"num_format": "#,##0"})
            # Auto ancho básico
            for i, col in enumerate(df.columns):
                try:
                    width = max(12, min(40, int(df[col].astype(str).str.len().quantile(0.9)) + 2))
                except Exception:
                    width = 16
                ws.set_column(i, i, width)
            if "shares_delta" in df.columns:
                col_idx = df.columns.get_loc("shares_delta")
                ws.set_column(col_idx, col_idx, 14, fmt_int)
        output.seek(0)
        log.info("Export Movimientos.xlsx company_id=%s from=%s to=%s types=%s rows=%s",
                 company_id, date_from, date_to,
                 ",".join(event_types) if event_types else "", len(df))
        return output
    except Exception as e:
        log.error("Error exportando Movimientos.xlsx company_id=%s: %s",
                  company_id, e, exc_info=True)
        raise

def export_ledger_excel_legalizable(
    company_id: int,
    date_from: Optional[str],
    date_to: Optional[str],
    event_types: Optional[List[str]],
    diligencia_apertura: Optional[str] = None,
    diligencia_cierre: Optional[str] = None,
    as_of: Optional[str] = None,
) -> BytesIO:
    """
    Libro Registro – Excel legalizable.
    Todas las secciones que son “a fecha” usan as_of (si no viene, cae en date_to; si no, hoy).
    Pestañas:
      - Resumen (metadatos)
      - Socios a fecha (con #)
      - Cap table a fecha (con #, %, capital)
      - Rangos vigentes por socio a fecha (con #)
      - Gravámenes a fecha (incluye “A favor de” y tipo normalizado)
      - Movimientos del período (con tipo corto y VN vigente)
    """
    try:
        as_of_final = as_of or date_to or datetime.now().strftime("%Y-%m-%d")

        # --- Cap table / socios vigentes a fecha ---
        df_cap = _vigentes_cap_table(company_id, as_of_final)
        pmap   = _partners_lookup(company_id)
        vigentes_ids = _vigentes_ids_from_cap(df_cap, company_id)

        # -- Socios a fecha (con #, tomada de vigentes_ids + pmap)
        socios_rows = []
        for pid in vigentes_ids:
            info = pmap.get(int(pid), {})
            socios_rows.append({
                "#": int(pid),
                "Nombre / Razón social": info.get("nombre", ""),
                "NIF/CIF": info.get("nif", ""),
                "Nacionalidad": info.get("nacionalidad", ""),
                "Domicilio": info.get("domicilio", ""),
            })
        df_socios = pd.DataFrame(socios_rows)

        # -- Cap table a fecha (añadimos columna #)
        df_cap_x = df_cap.copy()
        # intenta asegurar partner_id (#)
        if "partner_id" not in df_cap_x.columns:
            df_cap_x["partner_id"] = None
        for i, r in df_cap_x.iterrows():
            pid = r.get("partner_id")
            if pd.isna(pid) or pid is None:
                pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
            df_cap_x.at[i, "partner_id"] = None if pid is None else int(pid)
        df_cap_x.rename(columns={
            "partner_id": "#",
            "partner_name": "Socio",
            "nif": "NIF/CIF",
            "shares": "Participaciones",
            "pct": "% (0–100)",
            "capital_socio": "Capital del socio (€)",
        }, inplace=True)
        # reordena si están todas
        cols_cap = ["#", "Socio", "NIF/CIF", "Participaciones", "% (0–100)", "Capital del socio (€)"]
        df_cap_x = df_cap_x[[c for c in cols_cap if c in df_cap_x.columns]]

        # -- Rangos vigentes por socio a fecha (con #)
        rows_ranges = []
        for _, r in df_cap.iterrows():
            pid = r.get("partner_id")
            if pd.isna(pid) or pid is None:
                pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
            if pid is None:
                continue
            rng = partner_holdings_ranges(company_id, int(pid), as_of_final)
            if rng is None or rng.empty:
                continue
            for _, rr in rng.iterrows():
                rows_ranges.append({
                    "#": int(pid),
                    "Socio": r.get("partner_name",""),
                    "NIF/CIF": r.get("nif",""),
                    "Desde": rr.get("rango_desde"),
                    "Hasta": rr.get("rango_hasta"),
                    "Participaciones": rr.get("participaciones"),
                })
        df_rng = pd.DataFrame(rows_ranges)

        # -- Gravámenes a fecha (usa el mismo “compose” que el PDF)
        df_grav = _encumbrances_all(company_id, as_of_final, vigentes_ids, pmap).copy()

        # normalización de tipo (Pignoración/Embargo/…)
        def _pick(row: dict, *keys: str) -> str:
            for k in keys:
                val = row.get(k)
                if val is not None and str(val).strip() != "":
                    return str(val).strip()
            return ""

        def _tipo_txt(row: dict) -> str:
            raw = _pick(row, "tipo_evento", "tipo_origen", "tipo_base", "tipo", "subtipo", "evento_tipo").upper()
            if "PIGNOR" in raw: return "Pignoración"
            if "EMBARGO" in raw: return "Embargo"
            return (raw.title() if raw else "—")

        # “A favor de”: Nombre (NIF)
        def _afavor_txt(row: dict) -> str:
            nom = _pick(row, "a_favor_de", "acreedor_nombre", "beneficiario_nombre", "tercero_nombre", "acreedor", "beneficiario")
            nif = _pick(row, "acreedor_nif", "beneficiario_nif", "tercero_nif")
            if nom and nif: return f"{nom} ({nif})"
            return nom or nif or ""

        if df_grav is None or df_grav.empty:
            df_grav_x = pd.DataFrame(columns=["Fecha","Socio titular","Tipo","A favor de","Desde","Hasta"])
        else:
            df_grav_x = df_grav.copy()
            df_grav_x["Tipo (normalizado)"] = df_grav_x.apply(lambda r: _tipo_txt(r.to_dict()), axis=1)
            df_grav_x["A favor de"]         = df_grav_x.apply(lambda r: _afavor_txt(r.to_dict()), axis=1)
            # ordena columnas agradables
            cols_g = ["fecha","socio_titular","Tipo (normalizado)","A favor de","rango_desde","rango_hasta","tipo"]
            df_grav_x = df_grav_x[[c for c in cols_g if c in df_grav_x.columns]].rename(columns={
                "fecha":"Fecha","socio_titular":"Socio titular","rango_desde":"Desde","rango_hasta":"Hasta","tipo":"Tipo (original)"
            })

        # -- Movimientos del período
        df_mov = _ledger_rows(company_id, date_from, date_to, event_types)
        vn_steps = _nominal_timeline(company_id)

        def _vn_row(r):
            try:
                nv = r.get("nuevo_valor_nominal")
                if pd.notna(nv) and float(nv or 0) > 0:
                    return float(nv)
            except Exception:
                pass
            return _vn_on_date(vn_steps, str(r.get("fecha") or ""))

        TYPE_SHORT = {
            "ALTA": "ALTA",
            "TRANSMISION": "TRANS",
            "AMPL_EMISION": "AMPL_EMI",
            "AMPL_VALOR": "AMPL_VAL",
            "REDENOMINACION": "REDENOM",
            "PIGNORACION": "PIGNOR",
            "CANCELA_PIGNORACION": "CANC_PIG",
        }
        def _short(t):
            t0 = (str(t) or "").upper().strip()
            return TYPE_SHORT.get(t0, (t0[:10] if t0 else ""))

        if df_mov is None or df_mov.empty:
            df_mov_x = pd.DataFrame(columns=[
                "correlativo","fecha","tipo","tipo_corto",
                "socio_transmite_nombre","socio_transmite_nif",
                "socio_adquiere_nombre","socio_adquiere_nif",
                "rango_desde","rango_hasta","participaciones","nuevo_valor_nominal","vn_vigente"
            ])
        else:
            df_mov_x = df_mov.copy()
            df_mov_x["tipo_corto"] = df_mov_x["tipo"].map(_short)
            df_mov_x["vn_vigente"] = df_mov_x.apply(_vn_row, axis=1)

        # --------- Escribir Excel ----------
        output = BytesIO()
        with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
            # Resumen (metadatos coherentes con el PDF)
            meta = {
                "Sociedad": _company_header(company_id).get("name",""),
                "A fecha": as_of_final,
                "Periodo (desde)": date_from or "inicio",
                "Periodo (hasta)": date_to or "hoy",
                "Tipos de evento (filtro)": ", ".join(event_types or []) or "—",
                "Diligencia apertura": diligencia_apertura or "—",
                "Diligencia cierre": diligencia_cierre or "—",
            }
            df_meta = pd.DataFrame(list(meta.items()), columns=["Campo","Valor"])
            df_meta.to_excel(writer, index=False, sheet_name="Resumen")

            # Socios
            df_socios.to_excel(writer, index=False, sheet_name="Socios a fecha")
            # Cap table
            df_cap_x.to_excel(writer, index=False, sheet_name="Cap table a fecha")
            # Rangos
            df_rng.to_excel(writer, index=False, sheet_name="Rangos a fecha")
            # Gravámenes
            df_grav_x.to_excel(writer, index=False, sheet_name="Gravámenes a fecha")
            # Movimientos
            df_mov_x.to_excel(writer, index=False, sheet_name="Movimientos")

            # Formatos y auto-ancho
            wb = writer.book
            fmt_int = wb.add_format({"num_format": "#,##0"})
            fmt_pct = wb.add_format({"num_format": "0.0000"})
            fmt_money = wb.add_format({"num_format": "#,##0.00"})

            def _autowidth(ws_name: str, df_: pd.DataFrame):
                ws = writer.sheets[ws_name]
                for i, col in enumerate(df_.columns):
                    try:
                        max_len = int(df_[col].astype(str).str.len().quantile(0.9))
                    except Exception:
                        max_len = 16
                    width = max(12, min(50, max_len + 2))
                    ws.set_column(i, i, width)
                return ws

            _autowidth("Resumen", df_meta)
            _autowidth("Socios a fecha", df_socios)
            ws_cap = _autowidth("Cap table a fecha", df_cap_x)
            if "Participaciones" in df_cap_x.columns:
                idx = df_cap_x.columns.get_loc("Participaciones")
                ws_cap.set_column(idx, idx, 14, fmt_int)
            if "% (0–100)" in df_cap_x.columns:
                idx = df_cap_x.columns.get_loc("% (0–100)")
                ws_cap.set_column(idx, idx, 12, fmt_pct)
            if "Capital del socio (€)" in df_cap_x.columns:
                idx = df_cap_x.columns.get_loc("Capital del socio (€)")
                ws_cap.set_column(idx, idx, 16, fmt_money)

            _autowidth("Rangos a fecha", df_rng)
            _autowidth("Gravámenes a fecha", df_grav_x)
            ws_mov = _autowidth("Movimientos", df_mov_x)
            if "participaciones" in df_mov_x.columns:
                idx = df_mov_x.columns.get_loc("participaciones")
                ws_mov.set_column(idx, idx, 14, fmt_int)
            if "vn_vigente" in df_mov_x.columns:
                idx = df_mov_x.columns.get_loc("vn_vigente")
                ws_mov.set_column(idx, idx, 12, fmt_money)

        output.seek(0)
        log.info(
            "Export LibroRegistro.xlsx company_id=%s as_of=%s from=%s to=%s types=%s",
            company_id, as_of_final, date_from, date_to, ",".join(event_types or [])
        )
        return output

    except Exception as e:
        log.error("Error exportando LibroRegistro.xlsx company_id=%s: %s", company_id, e, exc_info=True)
        raise

# ============================================================
#  PDF: Certificado de titularidad (socio) (sin cambios sustanciales)
# ============================================================
def export_partner_certificate_pdf(company_id: int, partner_id: int, as_of: Optional[str] = None) -> BytesIO:
    try:
        ensure_pdf_base_fonts()
        ref_date = as_of or datetime.now().strftime("%Y-%m-%d")

        data    = partner_position(company_id, partner_id, ref_date)
        rangos  = partner_holdings_ranges(company_id, partner_id, ref_date)
        enc     = active_encumbrances_affecting_partner(company_id, partner_id, ref_date)
        _ = last_entries_for_partner(company_id, partner_id, limit=10, as_of=ref_date)  # no usado, pero conservamos la llamada

        # Orden estable para la tabla
        if enc is not None and not enc.empty:
            enc = enc.sort_values(by=["fecha", "rango_desde", "rango_hasta"], na_position="last").reset_index(drop=True)

        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        W, H = A4
        y = H - 20 * mm
        content_width = W - 2 * MARGIN_X  # ancho útil entre márgenes

        # ---------------- Cabecera ----------------
        comp_corte = datetime.strptime(ref_date, "%Y-%m-%d").strftime("%d/%m/%Y")

        c.setTitle("Certificado de titularidad")
        c.setFont("DejaVuSans", 14)
        c.drawString(MARGIN_X, y, "Certificado de titularidad"); y -= 6 * mm

        c.setFont("DejaVuSans", 9)
        c.drawString(MARGIN_X, y, f"A fecha de certificación: {comp_corte}")
        y -= 8 * mm

        _hr(c, y); y -= SECTION_GAP

        # ---------------- Resumen del socio ----------------
        y = _section_title(c, "Resumen del socio", y)
        y = _kv(c, y, "Socio", data.get("partner_name", ""))
        y = _kv(c, y, "NIF", data.get("nif", "") or "—")
        y = _kv(c, y, "Participaciones", f"{int(data.get('shares', 0)):,}".replace(",", "."))
        y = _kv(c, y, "Porcentaje", f"{float(data.get('pct', 0.0)):.4f} %")
        y = _kv(c, y, "Clases/Series", data.get("classes") or "—")
        y -= 2 * mm

        # ---------------- Detalle de participaciones ----------------
        y = _section_title(c, "Detalle de participaciones a la fecha", y)
        c.setFont("DejaVuSans", 9.5)
        _col(c, MARGIN_X, y, "Desde")
        _col(c, MARGIN_X + 35 * mm, y, "Hasta")
        _col(c, MARGIN_X + 70 * mm, y, "Participaciones")
        y -= 4 * mm
        _hr(c, y); y -= 3 * mm
        c.setFont("DejaVuSans", 9)

        total_bloques = 0
        if rangos is None or rangos.empty:
            _col(c, MARGIN_X, y, "(Sin bloques vigentes)"); y -= CONTENT_GAP
        else:
            for _, r in rangos.iterrows():
                rd = r.get("rango_desde"); rh = r.get("rango_hasta"); part = int(r.get("participaciones") or 0)
                total_bloques += part
                _col(c, MARGIN_X, y, "" if pd.isna(rd) else str(int(rd)))
                _col(c, MARGIN_X + 35 * mm, y, "" if pd.isna(rh) else str(int(rh)))
                _col(c, MARGIN_X + 70 * mm, y, f"{part:,}".replace(",", "."))
                y -= CONTENT_GAP
                if y < 30 * mm:
                    c.showPage(); y = H - 20 * mm

        c.setFont("DejaVuSans-Oblique", 9)
        check = f"Suma de bloques: {total_bloques:,}".replace(",", ".") + \
                f"   •   Total socio: {int(data.get('shares', 0)):,}".replace(",", ".")
        _col(c, MARGIN_X, y, check); y -= CONTENT_GAP

        # ---------------- Gravámenes a la fecha ----------------
        y = _section_title(c, "Gravámenes a la fecha (pignoraciones/embargos)", y)

        c.setFont("DejaVuSans", 9)
        if enc is None or enc.empty:
            para = (
                "A la fecha de esta certificación no constan gravámenes vigentes "
                "(pignoraciones ni embargos) sobre las participaciones titularidad del socio, "
                "según el Libro Registro."
            )
            y = _draw_paragraph(c, para, MARGIN_X, y, content_width, leading=12.0)
            y -= 2 * mm
        else:
            para = (
                "A la fecha de esta certificación, constan sobre las participaciones titularidad "
                "del socio uno o varios gravámenes (pignoraciones y/o embargos) vigentes conforme a los "
                "asientos del Libro Registro, según se detalla en la tabla a continuación:"
            )
            y = _draw_paragraph(c, para, MARGIN_X, y, content_width, leading=12.0)
            y -= 2 * mm

            # Posiciones de columnas
            x_fecha = MARGIN_X
            x_tipo  = MARGIN_X + 28 * mm
            x_afav  = MARGIN_X + 60 * mm   
            x_desde = MARGIN_X + 135 * mm
            x_hasta = MARGIN_X + 155 * mm

            def draw_enc_header(y0: float) -> float:
                c.setFont("DejaVuSans", 9.5)
                _col(c, x_fecha, y0, "Fecha")
                _col(c, x_tipo,  y0, "Tipo")
                _col(c, x_afav,  y0, "A favor de")
                _col(c, x_desde, y0, "Desde")
                _col(c, x_hasta, y0, "Hasta")
                y1 = y0 - 4 * mm
                _hr(c, y1)
                c.setFont("DejaVuSans", 9)
                return y1 - 3 * mm

            y = draw_enc_header(y)

            # Filas de la tabla de gravámenes
            for _, r in enc.iterrows():
                fecha = str(r.get("fecha") or "")
                tipo  = str(r.get("tipo") or "")
                nom   = (r.get("acreedor_nombre") or "").strip()
                nif   = (r.get("acreedor_nif") or "").strip()
                acre  = f"{nom} ({nif})" if nif else nom  # ← AQUÍ componemos Nombre (NIF)

                rd    = r.get("rango_desde"); rh = r.get("rango_hasta")
                d_txt = "" if pd.isna(rd) else str(int(rd))
                h_txt = "" if pd.isna(rh) else str(int(rh))

                _col(c, x_fecha, y, fecha)
                _col(c, x_tipo,  y, tipo)
                _col(c, x_afav,  y, acre, maxw=(x_desde - x_afav - 3 * mm))  # ← aquí
                _col(c, x_desde, y, d_txt)
                _col(c, x_hasta, y, h_txt)
                y -= CONTENT_GAP

                if y < 30 * mm:
                    c.showPage(); y = H - 20 * mm
                    y = _section_title(c, "Gravámenes a la fecha (pignoraciones/embargos)", y)
                    y = _draw_paragraph(c, para, MARGIN_X, y, content_width, leading=12.0)
                    y -= 2 * mm
                    y = draw_enc_header(y)

        # Cierre
        c.showPage()
        c.save()
        buffer.seek(0)

        log.info("Export Certificado.pdf company_id=%s partner_id=%s as_of=%s partner='%s' shares=%s",
                 company_id, partner_id, as_of, data.get("partner_name", ""),
                 int(data.get("shares", 0)))

        return buffer

    except Exception as e:
        log.error("Error exportando Certificado.pdf company_id=%s partner_id=%s as_of=%s: %s",
                  company_id, partner_id, as_of, e, exc_info=True)
        raise


# ============================================================
#  LIBRO REGISTRO – LEGALIZABLE (PDF & Excel)
# ============================================================
def _nominal_timeline(company_id: int) -> list[tuple[str, float]]:
    """
    [(fecha ISO, nuevo_valor_nominal>0)] de events.nuevo_valor_nominal para saber VN vigente.
    """
    with get_connection() as conn:
        df = pd.read_sql_query(
            """
            SELECT fecha, nuevo_valor_nominal
            FROM events
            WHERE company_id=?
              AND nuevo_valor_nominal IS NOT NULL
              AND nuevo_valor_nominal > 0
            ORDER BY fecha, id
            """,
            conn, params=(company_id,)
        )
    if df.empty:
        return []
    out: list[tuple[str, float]] = []
    for _, r in df.iterrows():
        out.append((str(r["fecha"]), float(r["nuevo_valor_nominal"])))
    return out


def _vn_on_date(vn_steps: list[tuple[str, float]], fecha_iso: str) -> float | None:
    """Devuelve VN vigente a una fecha (lista ordenada ascendente)."""
    if not vn_steps:
        return None
    last = None
    for f, vn in vn_steps:
        if f <= fecha_iso:
            last = vn
        else:
            break
    return last


def _normalize_pct(p):
    try:
        v = float(p)
    except Exception:
        return None
    # En tu cap_table ya viene 0..100; si viniera 0..1, normalizamos.
    return v * 100.0 if v <= 1.000001 else v


def _vigentes_cap_table(company_id: int, as_of: str) -> pd.DataFrame:
    df = cap_table(company_id, as_of).copy()
    if df is None or df.empty:
        return pd.DataFrame(columns=["partner_id", "partner_name", "nif", "shares", "pct", "capital_socio"])
    if "pct" in df.columns:
        df["pct"] = df["pct"].map(_normalize_pct)
    # Filtra solo socios con saldo
    if "shares" in df.columns:
        df = df[df["shares"].fillna(0) > 0]
    # Asegura columnas esperadas
    for col in ("partner_id", "partner_name", "nif", "shares", "pct"):
        if col not in df.columns:
            df[col] = None
    if "capital_socio" not in df.columns:
        # si no viene, intenta derivarlo con VN vigente (opcional)
        vn = _vn_on_date(_nominal_timeline(company_id), as_of) or 0.0
        try:
            df["capital_socio"] = (df["shares"].fillna(0).astype(float) * float(vn)).round(2)
        except Exception:
            df["capital_socio"] = None
    return df


def _vigentes_ids_from_cap(df_cap: pd.DataFrame, company_id: int) -> list[int]:
    ids: list[int] = []
    for _, r in df_cap.iterrows():
        pid = r.get("partner_id")
        if pd.isna(pid) or pid is None:
            pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
        if pid is not None:
            ids.append(int(pid))
    # únicos y ordenados
    return sorted(list(dict.fromkeys(ids)))


def _encumbrances_all(company_id: int, as_of: str, ids: Iterable[int], pmap: dict[int, dict]) -> pd.DataFrame:
    """
    Devuelve un DF unificado con columnas al menos:
    ['fecha','socio_titular','tipo','a_favor_de','rango_desde','rango_hasta', (extras de tipo...)]
    Usamos active_encumbrances_affecting_partner para traer también beneficiario/subtipo.
    """
    def _pick(row: pd.Series, *keys: str) -> str:
        for k in keys:
            if k in row and pd.notna(row[k]):
                v = str(row[k]).strip()
                if v:
                    return v
        return ""

    def _compose_benef_row(r: pd.Series) -> str:
        # 1) claves “canónicas”
        nom = _pick(r, "a_favor_de", "acreedor_nombre", "beneficiario_nombre", "tercero_nombre", "acreedor", "beneficiario")
        nif = _pick(r, "acreedor_nif", "beneficiario_nif", "tercero_nif")
        if nom or nif:
            return f"{nom} ({nif})" if (nom and nif) else (nom or nif or "")

        # 2) sniff: busca columnas que contengan palabras clave
        cols = {c.lower(): c for c in r.index}
        # nombre
        name_col = next((cols[c] for c in cols if any(k in c for k in ("acreedor", "benef", "tercero")) and "nif" not in c), None)
        # nif
        nif_col  = next((cols[c] for c in cols if "nif" in c and any(k in c for k in ("acreedor", "benef", "tercero"))), None)
        nom2 = str(r[name_col]).strip() if name_col and pd.notna(r.get(name_col)) else ""
        nif2 = str(r[nif_col]).strip()  if nif_col and pd.notna(r.get(nif_col))  else ""
        if nom2 or nif2:
            return f"{nom2} ({nif2})" if (nom2 and nif2) else (nom2 or nif2)
        return ""

    frames: list[pd.DataFrame] = []

    for pid in ids:
        # IMPORTANTE: esta trae más detalle que active_encumbrances
        df = active_encumbrances_affecting_partner(company_id, pid, as_of)
        if df is None or df.empty:
            continue

        # debug de columnas (1 vez por socio)
        try:
            log.debug("encumbrances cols pid=%s -> %s", pid, list(df.columns))
        except Exception:
            pass

        info = pmap.get(int(pid), {})
        socio_tit = f"{info.get('nombre','')} ({info.get('nif','')})".strip()

        dfx = df.copy()
        dfx["socio_titular"] = socio_tit
        dfx["a_favor_de"]    = dfx.apply(_compose_benef_row, axis=1)

        # columnas extra de tipología para normalizar “Tipo”
        extra_tipo_cols = [c for c in ["tipo_evento","subtipo","evento_tipo","tipo_base","tipo_origen"] if c in dfx.columns]

        base_cols = ["fecha", "socio_titular", "tipo", "a_favor_de", "rango_desde", "rango_hasta"]
        keep_cols = base_cols + extra_tipo_cols
        keep_cols = [c for c in keep_cols if c in dfx.columns]  # por si faltan algunas
        frames.append(dfx[keep_cols])

    if not frames:
        return pd.DataFrame(columns=["fecha","socio_titular","tipo","a_favor_de","rango_desde","rango_hasta"])

    out = pd.concat(frames, ignore_index=True)
    out.sort_values(by=["fecha", "socio_titular", "a_favor_de"], inplace=True, na_position="last")
    return out.reset_index(drop=True)


def export_ledger_pdf_legalizable(
    company_id: int,
    date_from: str | None,
    date_to: str | None,
    event_types: list[str] | None,
    as_of: str | None = None,                       # 👈 NUEVO parámetro (opcional)
    diligencia_apertura: str | None = None,
    diligencia_cierre: str | None = None,
) -> BytesIO:
    """
    PDF legalizable (apaisado) con 4 secciones:
      1) Relación de socios con participaciones a la fecha
      2) Relación de participaciones a la fecha (incluye capital del socio)
      3) Rangos vigentes por socio a la fecha (solo socios con saldo)
      4) Gravámenes a la fecha
      5) Movimientos del período (leyenda continua)
    """
    ensure_pdf_base_fonts()

    comp = _company_header(company_id)
    # “A fecha” para cómputos: usa la que venga de la UI; si no, date_to; si no, hoy.
    as_of_final = as_of or date_to or datetime.now().strftime("%Y-%m-%d")

    df_cap = _vigentes_cap_table(company_id, as_of_final)
    vigentes_ids = _vigentes_ids_from_cap(df_cap, company_id)
    pmap = _partners_lookup(company_id)

    # ========= Canvas
    buf = BytesIO()
    c = canvas.Canvas(buf, pagesize=landscape(A4))
    W, H = landscape(A4)
    left = 15 * mm
    right = W - 15 * mm

    def _header_block(title: str, meta_lines: list[str] | None = None) -> float:
        y = H - 12 * mm
        c.setFont("DejaVuSans-Bold", 12)
        c.drawString(left, y, title); y -= 5.5 * mm

        c.setFont("DejaVuSans", 9.5)
        c.drawString(left, y, f"Sociedad: {comp['name']}    •    CIF: {comp['cif']}"); y -= 4.2 * mm
        c.drawString(left, y, f"Domicilio: {comp['domicilio']}"); y -= 4.2 * mm
        if comp.get("fecha_constitucion"):
            c.drawString(left, y, f"Fecha constitución: {comp['fecha_constitucion']}"); y -= 4.2 * mm

        if meta_lines:
            for line in meta_lines:
                if line:
                    c.drawString(left, y, line); y -= 4.2 * mm

        c.setFont("DejaVuSans", 8.5); c.setFillColor(colors.grey)
        c.drawString(left, y, f"Emitido: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        c.setFillColor(colors.black); y -= 4.2 * mm
        c.setStrokeColor(colors.lightgrey); c.setLineWidth(0.6); c.line(left, y, right, y)
        return y - 6 * mm

    # ========= 1) Relación de socios (con #) =========
    y = _header_block(
        "Libro registro de socios – Relación de socios",
        [f"A fecha: {as_of_final}", f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
    )
    c.setFont("DejaVuSans-Bold", 9)
    cols_soc = [("#", 12*mm), ("Nombre / Razón social", 85*mm), ("NIF/CIF", 35*mm),
                ("Nacionalidad", 35*mm), ("Domicilio", right - left - (12+85+35+35)*mm)]
    x = left
    for t, w in cols_soc: c.drawString(x, y, t); x += w
    y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm

    c.setFont("DejaVuSans", 8.6)
    for pid in vigentes_ids:
        info = pmap.get(int(pid), {})
        if y < 18 * mm:
            c.showPage()
            y = _header_block(
                "Libro registro de socios – Relación de socios",
                [f"A fecha: {as_of_final}", f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
            )
            c.setFont("DejaVuSans-Bold", 9); x = left
            for t, w in cols_soc: c.drawString(x, y, t); x += w
            y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
            c.setFont("DejaVuSans", 8.6)

        x = left
        _col(c, x, y, str(pid), maxw=12*mm); x += 12*mm
        _col(c, x, y, info.get("nombre",""), maxw=85*mm); x += 85*mm
        _col(c, x, y, info.get("nif",""), maxw=35*mm); x += 35*mm
        _col(c, x, y, info.get("nacionalidad",""), maxw=35*mm); x += 35*mm
        _col(c, x, y, info.get("domicilio",""), maxw=(right-left - (12+85+35+35)*mm))
        y -= 5.2 * mm

    c.showPage()

    # ========= 2) Relación de participaciones a fecha (con #) =========
    y = _header_block(
        "Libro registro de socios – Relación de participaciones a fecha",
        [f"A fecha: {as_of_final}", f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
    )
    c.setFont("DejaVuSans-Bold", 9)
    cols_cap = [
        ("#", 12*mm), ("Socio", 88*mm), ("NIF/CIF", 35*mm),
        ("Participaciones", 35*mm), ("% (0–100)", 25*mm), ("Capital del socio (€)", 40*mm),
    ]
    x = left
    for title, width in cols_cap: c.drawString(x, y, title); x += width
    y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm

    c.setFont("DejaVuSans", 8.7)
    for _, r in df_cap.iterrows():
        if y < 18 * mm:
            c.showPage()
            y = _header_block(
                "Libro registro de socios – Relación de participaciones a fecha",
                [f"A fecha: {as_of_final}", f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
            )
            c.setFont("DejaVuSans-Bold", 9); x = left
            for title, width in cols_cap: c.drawString(x, y, title); x += width
            y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
            c.setFont("DejaVuSans", 8.7)

        pid = r.get("partner_id")
        if pd.isna(pid) or pid is None:
            pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
        x = left
        _col(c, x, y, "" if pid is None else str(int(pid)), maxw=12*mm); x += 12*mm
        _col(c, x, y, r.get("partner_name",""), maxw=88*mm); x += 88*mm
        _col(c, x, y, r.get("nif",""), maxw=35*mm); x += 35*mm
        c.drawRightString(x + 35*mm - 1.5*mm, y, f"{int(r.get('shares',0)):,}".replace(",", ".")); x += 35*mm
        pct = r.get("pct"); pct = ("" if pd.isna(pct) else f"{float(pct):.4f}")
        c.drawRightString(x + 25*mm - 1.5*mm, y, pct); x += 25*mm
        cap = r.get("capital_socio")
        cap_txt = "" if pd.isna(cap) or cap is None else f"{float(cap):,.2f}".replace(",", ".")
        c.drawRightString(x + 40*mm - 1.5*mm, y, cap_txt)
        y -= 5.3 * mm

    c.showPage()

    # ========= 3) Rangos vigentes por socio (con #) =========
    y = _header_block(
        "Libro registro de socios – Rangos vigentes por socio a la fecha",
        [f"A fecha: {as_of_final}"]
    )
    rows_ranges = []
    for _, r in df_cap.iterrows():
        pid = r.get("partner_id")
        if pd.isna(pid) or pid is None:
            pid = _partner_id_by_nif_or_name(company_id, r.get("partner_name"), r.get("nif"))
        if pid is None:
            continue
        rng = partner_holdings_ranges(company_id, int(pid), as_of_final)
        if rng is None or rng.empty:
            continue
        for _, rr in rng.iterrows():
            rows_ranges.append({
                "pid": int(pid),
                "socio": r.get("partner_name",""),
                "nif": r.get("nif",""),
                "desde": rr.get("rango_desde"),
                "hasta": rr.get("rango_hasta"),
                "participaciones": rr.get("participaciones"),
            })
    df_rng = pd.DataFrame(rows_ranges)

    c.setFont("DejaVuSans-Bold", 9)
    cols_rng = [("#", 12*mm), ("Socio", 88*mm), ("NIF/CIF", 35*mm),
                ("Desde", 25*mm), ("Hasta", 25*mm), ("Participaciones", 35*mm)]
    x = left
    for t, w in cols_rng: c.drawString(x, y, t); x += w
    y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
    c.setFont("DejaVuSans", 8.6)

    if df_rng.empty:
        _col(c, left, y, "(Sin rangos vigentes a la fecha)")
        y -= 6 * mm
    else:
        for _, r in df_rng.iterrows():
            if y < 18 * mm:
                c.showPage()
                y = _header_block(
                    "Libro registro de socios – Rangos vigentes por socio a la fecha",
                    [f"A fecha: {as_of_final}"]
                )
                c.setFont("DejaVuSans-Bold", 9); x = left
                for t, w in cols_rng: c.drawString(x, y, t); x += w
                y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
                c.setFont("DejaVuSans", 8.6)

            x = left
            _col(c, x, y, "" if pd.isna(r.get("pid")) else str(int(r.get("pid"))), maxw=12*mm); x += 12*mm
            _col(c, x, y, r.get("socio",""), maxw=88*mm); x += 88*mm
            _col(c, x, y, r.get("nif",""), maxw=35*mm); x += 35*mm
            c.drawRightString(x + 25*mm - 1.5*mm, y, "" if pd.isna(r.get("desde")) else str(int(r.get("desde")))); x += 25*mm
            c.drawRightString(x + 25*mm - 1.5*mm, y, "" if pd.isna(r.get("hasta")) else str(int(r.get("hasta")))); x += 25*mm
            c.drawRightString(x + 35*mm - 1.5*mm, y,
                "" if pd.isna(r.get("participaciones")) else f"{int(r.get('participaciones')):,}".replace(",", "."))
            y -= 5.2 * mm

    c.showPage()

    # ========= 4) Gravámenes a la fecha =========
    y = _header_block(
        "Libro registro de socios – Gravámenes sobre participaciones sociales",
        [f"A fecha: {as_of_final}"]
    )

    df_grav = _encumbrances_all(company_id, as_of_final, vigentes_ids, pmap)

    c.setFont("DejaVuSans-Bold", 9)
    cols_g = [
        ("Fecha", 24*mm),
        ("Socio titular", 70*mm),
        ("Tipo", 24*mm),
        ("A favor de", 80*mm),
        ("Desde", 18*mm),
        ("Hasta", 18*mm),
    ]
    x = left
    for title, width in cols_g: c.drawString(x, y, title); x += width
    y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
    c.setFont("DejaVuSans", 8.6)

    def _ensure_page_grav(y0: float) -> float:
        if y0 < 18 * mm:
            c.showPage()
            return _header_block(
                "Libro registro de socios – Gravámenes sobre participaciones sociales",
                [f"A fecha: {as_of_final}"]
            )
        return y0

    def _pick(row: dict, *keys: str) -> str:
        for k in keys:
            val = row.get(k)
            if val is not None and str(val).strip() != "":
                return str(val).strip()
        return ""

    def _tipo_txt(row: dict) -> str:
        raw = _pick(row, "tipo_evento", "tipo_origen", "tipo_base", "tipo", "subtipo", "evento_tipo").upper()
        if "PIGNOR" in raw: return "Pignoración"
        if "EMBARGO" in raw: return "Embargo"
        return (raw.title() if raw else "—")

    def _afavor_txt(row: dict) -> str:
        nom = _pick(row, "a_favor_de", "acreedor_nombre", "beneficiario_nombre", "tercero_nombre", "acreedor", "beneficiario")
        nif = _pick(row, "acreedor_nif", "beneficiario_nif", "tercero_nif")
        if nom and nif: return f"{nom} ({nif})"
        return nom or nif or ""

    def _draw_row_grav(y0: float, fila: dict) -> float:
        x = left
        _col(c, x, y0, str(fila.get("fecha","")), maxw=24*mm); x += 24*mm
        _col(c, x, y0, fila.get("socio_titular",""), maxw=70*mm); x += 70*mm
        _col(c, x, y0, _tipo_txt(fila), maxw=24*mm); x += 24*mm
        _col(c, x, y0, _afavor_txt(fila), maxw=80*mm); x += 80*mm
        dsd = "" if pd.isna(fila.get("rango_desde")) else str(int(fila.get("rango_desde")))
        hst = "" if pd.isna(fila.get("rango_hasta")) else str(int(fila.get("rango_hasta")))
        c.drawRightString(x + 18*mm - 1.5*mm, y0, dsd); x += 18*mm
        c.drawRightString(x + 18*mm - 1.5*mm, y0, hst)
        return y0 - 5.2 * mm

    if df_grav is None or df_grav.empty:
        _col(c, left, y, "(Sin gravámenes vigentes a la fecha)")
        y -= 6 * mm
    else:
        for _, row in df_grav.iterrows():
            if y < 18 * mm:
                y = _ensure_page_grav(y)
                c.setFont("DejaVuSans-Bold", 9); x = left
                for title, width in cols_g: c.drawString(x, y, title); x += width
                y -= 3.6 * mm; _hr(c, y, left, right); y -= 2.8 * mm
                c.setFont("DejaVuSans", 8.6)
            y = _draw_row_grav(y, row.to_dict())

    c.showPage()

    # ========= 5) Movimientos del período =========
    y = _header_block(
        "Libro registro de socios – Movimientos del período",
        [f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
    )

    df_mov = _ledger_rows(company_id, date_from, date_to, event_types)

    # VN vigente por fila (si no viene explícito)
    vn_steps = _nominal_timeline(company_id)
    def _vn_row(r):
        if pd.notna(r.get("nuevo_valor_nominal")) and float(r["nuevo_valor_nominal"] or 0) > 0:
            return float(r["nuevo_valor_nominal"])
        return _vn_on_date(vn_steps, str(r.get("fecha") or ""))

    if df_mov is None or df_mov.empty:
        df_mov = pd.DataFrame(columns=[
            "correlativo","fecha","tipo",
            "socio_transmite_nombre","socio_transmite_nif",
            "socio_adquiere_nombre","socio_adquiere_nif",
            "rango_desde","rango_hasta","participaciones","nuevo_valor_nominal"
        ])
    df_mov = df_mov.copy()
    df_mov["vn_vigente"] = df_mov.apply(_vn_row, axis=1)

    TYPE_SHORT = {
        "ALTA": "ALTA",
        "TRANSMISION": "TRANS",
        "AMPL_EMISION": "AMPL_EMI",
        "AMPL_VALOR": "AMPL_VAL",
        "REDENOMINACION": "REDENOM",
        "PIGNORACION": "PIGNOR",
        "CANCELA_PIGNORACION": "CANC_PIG",
    }
    TYPE_DESC = {
        "ALTA": "Alta de socio / primera anotación",
        "TRANSMISION": "Transmisión de participaciones entre socios/terceros",
        "AMPL_EMISION": "Ampliación de capital por emisión de nuevas participaciones",
        "AMPL_VALOR": "Ampliación mediante aumento del valor nominal",
        "REDENOMINACION": "Cambio del valor nominal",
        "PIGNORACION": "Constitución de gravamen (pignoración/embargo)",
        "CANCELA_PIGNORACION": "Cancelación total o parcial de pignoración/embargo",
    }
    def _short(t):
        t0 = (str(t) or "").upper().strip()
        return TYPE_SHORT.get(t0, (t0[:10] if t0 else ""))

    df_mov["tipo_corto"] = df_mov["tipo"].map(_short)

    # ---- Config tabla
    FONT        = "DejaVuSans"
    FONT_BOLD   = "DejaVuSans-Bold"
    SIZE_HDR    = 8.9
    SIZE_TXT    = 8.4
    LINE_H      = 4.8 * mm
    PAD_Y       = 1.2 * mm
    GUT         = 2.2 * mm

    COLS = [
        ("Orden",   12),
        ("Fecha",   20),
        ("Tipo",    30),   # ensanchada
        ("Transmite (Nombre / NIF)", 60),
        ("Adquiere (Nombre / NIF)",  60),
        ("Desde",   16),
        ("Hasta",   16),
        ("# Parts.",18),
        ("VN (€)",  18),
    ]

    x = left
    COL_X, COL_W = [], []
    for _, w in COLS:
        COL_X.append(x)
        COL_W.append(w * mm)
        x += w * mm + GUT

    def draw_mov_header(y0: float) -> float:
        c.setFont(FONT_BOLD, SIZE_HDR)
        for (title, _), x0 in zip(COLS, COL_X):
            c.drawString(x0, y0, title)
        y1 = y0 - 3.6 * mm
        _hr(c, y1, left, right)
        return y1 - 2.8 * mm

    def wrap(txt: str, max_w_px: float, max_lines: int = 3) -> list[str]:
        c.setFont(FONT, SIZE_TXT)
        t = ("" if txt is None else str(txt)).strip()
        if not t: return [""]
        words, lines, cur = t.split(), [], ""
        for w in words:
            trial = (cur + " " + w).strip()
            if c.stringWidth(trial, FONT, SIZE_TXT) <= max_w_px:
                cur = trial
            else:
                if cur: lines.append(cur)
                cur = w
            if len(lines) >= max_lines: break
        if len(lines) >= max_lines:
            last = (cur if cur else "").strip()
            while c.stringWidth(last + " …", FONT, SIZE_TXT) > max_w_px and len(last) > 3:
                last = last[:-1]
            if lines: lines[-1] = lines[-1] + " …"
            else: lines = [last + " …"]
            return lines
        if cur: lines.append(cur)
        return lines or [""]

    def ensure_page(y0: float) -> float:
        if y0 < (18 * mm + LINE_H + 2 * PAD_Y):
            c.showPage()
            y1 = _header_block(
                "Libro registro de socios – Movimientos del período",
                [f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
            )
            return draw_mov_header(y1)
        return y0

    y = draw_mov_header(y)
    c.setFont(FONT, SIZE_TXT)

    for _, r in df_mov.iterrows():
        orden = "" if pd.isna(r.get("correlativo")) else str(int(r.get("correlativo")))
        fecha = str(r.get("fecha") or "")
        tipo  = str(r.get("tipo_corto") or "")

        st_txt = " / ".join([s for s in [r.get("socio_transmite_nombre",""), r.get("socio_transmite_nif","")] if s])
        sa_txt = " / ".join([s for s in [r.get("socio_adquiere_nombre",""), r.get("socio_adquiere_nif","")] if s])

        dsd = "" if pd.isna(r.get("rango_desde")) else str(int(r.get("rango_desde")))
        hst = "" if pd.isna(r.get("rango_hasta")) else str(int(r.get("rango_hasta")))
        npp = "" if pd.isna(r.get("participaciones")) else f"{int(r.get('participaciones')):,}".replace(",", ".")
        vn  = r.get("vn_vigente")
        vn_txt = None if (vn in (None, float("nan"))) else f"{float(vn):,.2f}".replace(",", ".")

        w_tipo = wrap(tipo, COL_W[2] - 2.5 * mm)
        w_st   = wrap(st_txt, COL_W[3] - 2.5 * mm)
        w_sa   = wrap(sa_txt, COL_W[4] - 2.5 * mm)
        lines  = max(len(w_tipo), len(w_st), len(w_sa), 1)
        row_h  = lines * LINE_H + 2 * PAD_Y

        if y - row_h < 18 * mm:
            y = ensure_page(y)

        y_top = y
        c.drawRightString(COL_X[0] + COL_W[0] - 1.5 * mm, y_top, orden)
        c.drawString(COL_X[1], y_top, fecha)

        for i in range(lines):
            yy = y_top - PAD_Y - i * LINE_H
            _col(c, COL_X[2], yy, w_tipo[i] if i < len(w_tipo) else "", SIZE_TXT, maxw=COL_W[2] - 2.5 * mm)
            _col(c, COL_X[3], yy, w_st[i]   if i < len(w_st)   else "", SIZE_TXT, maxw=COL_W[3] - 2.5 * mm)
            _col(c, COL_X[4], yy, w_sa[i]   if i < len(w_sa)   else "", SIZE_TXT, maxw=COL_W[4] - 2.5 * mm)

        yy0 = y_top - PAD_Y
        c.drawRightString(COL_X[5] + COL_W[5] - 1.5 * mm, yy0, dsd)
        c.drawRightString(COL_X[6] + COL_W[6] - 1.5 * mm, yy0, hst)
        c.drawRightString(COL_X[7] + COL_W[7] - 1.5 * mm, yy0, npp)
        if vn_txt is None or vn_txt.strip() == "":
            c.drawCentredString(COL_X[8] + COL_W[8] / 2.0, yy0, "–")
        else:
            c.drawRightString(COL_X[8] + COL_W[8] - 1.5 * mm, yy0, vn_txt)

        y = y - row_h
        c.setStrokeColor(colors.whitesmoke); c.setLineWidth(0.4)
        c.line(left, y + 0.9 * mm, right, y + 0.9 * mm)
        c.setStrokeColor(colors.black)

    # ======= Leyenda (párrafo continuo) =======
    try:
        tipos_presentes = sorted([str(x) for x in df_mov["tipo"].dropna().unique().tolist()])
    except Exception:
        tipos_presentes = []

    def _legend_header(y0: float) -> float:
        c.setFont("DejaVuSans-Bold", 9)
        c.drawString(left, y0, "Leyenda")
        y0 -= 3.0 * mm
        _hr(c, y0, left, right)
        return y0 - 2.4 * mm

    need = 30 * mm
    if y < (18 * mm + need):
        c.showPage()
        y = _header_block(
            "Libro registro de socios – Movimientos del período",
            [f"Periodo: {date_from or 'inicio'} → {date_to or 'hoy'}"]
        )

    y = _legend_header(y)
    c.setFont("DejaVuSans", 8)
    c.drawString(left, y, "VN (€): 'nan' indica que en ese asiento no hubo cambio de valor nominal (se mantiene el vigente).")
    y -= 4.2 * mm

    if tipos_presentes:
        pairs = []
        for t in tipos_presentes:
            t_up = (t or "").upper()
            short = TYPE_SHORT.get(t_up, t_up)
            desc  = TYPE_DESC.get(t_up, "Asiento según estatutos u operación registrada.")
            pairs.append(f"{short} = {desc}")
        texto = "Tipos de evento en el periodo: " + "; ".join(pairs) + "."
        y = _draw_paragraph(c, texto, left, y, max_width=(right - left), leading=11.0, font="DejaVuSans", font_size=8)

    c.showPage()
    c.save()
    buf.seek(0)

    log.info("Export Libro legalizable PDF company_id=%s from=%s to=%s as_of=%s types=%s",
             company_id, date_from, date_to, as_of_final, ",".join(event_types or []))
    return buf

# >>>>>>>>>>>>> _review_correlativos/app/core/services/maintenance_service.py <<<<<<<<<<<<<

# app/core/services/maintenance_service.py
from __future__ import annotations
from app.infra.db import get_connection
from app.infra.healthcheck import integrity_check, foreign_key_check, quick_summary

def run_analyze() -> None:
    with get_connection() as conn:
        conn.execute("ANALYZE;")

def run_reindex() -> None:
    with get_connection() as conn:
        conn.execute("REINDEX;")

def run_vacuum() -> None:
    with get_connection() as conn:
        conn.execute("VACUUM;")

# Re-export helpers de healthcheck (para importar todo desde un sitio)
def db_integrity_check(): return integrity_check()
def db_fk_check(): return foreign_key_check()
def db_quick_summary(): return quick_summary()

# >>>>>>>>>>>>> _review_correlativos/app/core/services/partners_service.py <<<<<<<<<<<<<

#app/core/services/partners_services.py

from typing import Optional
from ..repositories import partners_repo
from ..validators import normalize_nif_cif

def list_partners(company_id: int) -> list[dict]:
    rows = partners_repo.list_by_company(company_id)
    for r in rows:
        r["nif"] = normalize_nif_cif(r.get("nif"))
    return rows

def save_partner(*, id: Optional[int], company_id: int, nombre: str, nif: str,
                 domicilio: Optional[str], nacionalidad: Optional[str],
                 fecha_nacimiento_constitucion: Optional[str]) -> int:
    nif = normalize_nif_cif(nif)
    return partners_repo.upsert_partner(
        id=id, company_id=company_id, nombre=nombre, nif=nif,
        domicilio=domicilio, nacionalidad=nacionalidad,
        fecha_nacimiento_constitucion=fecha_nacimiento_constitucion
    )

# >>>>>>>>>>>>> _review_correlativos/app/core/validators.py <<<<<<<<<<<<<

#app/core/validators.py

import re
def normalize_nif_cif(value: str | None) -> str | None:
    if not value:
        return value
    v = value.upper().strip().replace("-", "").replace(" ", "")
    return v
def validate_email(value: str | None) -> bool:
    if not value: 
        return True
    return bool(re.match(r"^[^@\s]+@[^@\s]+\.[^@\s]+$", value))
def normalize_phone(value: str | None) -> str | None:
    if not value:
        return value
    return value.strip().replace(" ", "")

# >>>>>>>>>>>>> _review_correlativos/app/infra/constants.py <<<<<<<<<<<<<

from pathlib import Path
ROOT_DIR = Path(__file__).resolve().parents[2]
APP_DIR = ROOT_DIR / "app"
DATA_DIR = ROOT_DIR / "data"
LOGS_DIR = ROOT_DIR / "logs"
ASSETS_DIR = APP_DIR / "assets"
FONTS_DIR = ASSETS_DIR / "fonts"
DB_PATH = DATA_DIR / "libro_socios.db"

# >>>>>>>>>>>>> _review_correlativos/app/infra/db.py <<<<<<<<<<<<<

#app/infra/db.py

import sqlite3
from contextlib import contextmanager
from .constants import DB_PATH
@contextmanager
def get_connection():
    conn = sqlite3.connect(DB_PATH)
    try:
        conn.row_factory = sqlite3.Row
        yield conn
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        conn.close()

# >>>>>>>>>>>>> _review_correlativos/app/streamlit_app.py <<<<<<<<<<<<<

#app/streamlit_app.py

# --- bootstrap de rutas: asegura que la raíz del proyecto está en sys.path ---
import sys
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]  # .../libro_socios_v2
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))
# -----------------------------------------------------------------------------

import streamlit as st
from app.infra.logging import setup_logging
from app.ui.layout import sidebar_selector, sidebar_menu
from app.ui.routing import render_page

# Inicializar logging una sola vez
if "logging_setup" not in st.session_state:
    logger = setup_logging()
    st.session_state["logging_setup"] = True
else:
    import logging
    logger = logging.getLogger()

st.set_page_config(page_title="📘 Libro Registro de Socios – v2", layout="wide")
with st.sidebar:
    sidebar_selector()
    section = sidebar_menu()
render_page(section, st.session_state.get("company_id"))

# >>>>>>>>>>>>> _review_correlativos/app/ui/pages/events.py <<<<<<<<<<<<<

# app/ui/pages/events.py
from __future__ import annotations
import streamlit as st
import pandas as pd
from datetime import date, datetime
import logging

from app.core.enums import EVENT_TYPES  # <- solo usamos EVENT_TYPES
from app.core.services.events_service import (
    list_events_for_ui,
    create_event_generic,
    get_event,
    update_event,
    delete_event,
    create_redenominacion,
)
from app.core.services.partners_service import list_partners

log = logging.getLogger(__name__)

MIN_EVENT_DATE = date(1900, 1, 1)
MAX_EVENT_DATE = date.today()

# --------- Tipos de gravámenes (derivados de EVENT_TYPES) ----------
# Esto evita “duplicar” literales: si cambian en enums, la UI se adapta.
START_TYPES = tuple(t for t in EVENT_TYPES if t in ("PIGNORACION", "EMBARGO"))
CANCEL_TYPES = tuple(
    t for t in EVENT_TYPES
    if t in ("CANCELA_PIGNORACION", "CANCELA_EMBARGO", "LEV_GRAVAMEN", "ALZAMIENTO")
)

# -------------------------------
# Helpers
# -------------------------------
def _partners_maps(company_id: int):
    partners = list_partners(company_id)
    choices = [p["id"] for p in partners]
    labels = {p["id"]: f'{p["id"]} – {p["nombre"]} ({p.get("nif") or "-"})' for p in partners}
    names  = {p["id"]: p["nombre"] for p in partners}
    return choices, labels, names

def _to_date_or_none(s: str | None) -> date | None:
    if not s:
        return None
    try:
        return datetime.strptime(s, "%Y-%m-%d").date()
    except Exception:
        return None

def _reset_edit_state():
    st.session_state["ev_id"]   = 0
    st.session_state["ev_tipo"] = (EVENT_TYPES or ["OTRO"])[0]
    st.session_state["ev_fecha"] = None
    st.session_state["ev_st"] = None
    st.session_state["ev_sa"] = None
    st.session_state["ev_rd"] = 0
    st.session_state["ev_rh"] = 0
    st.session_state["ev_np"] = 0
    st.session_state["ev_nvn"] = 0.0
    st.session_state["ev_doc"] = ""
    st.session_state["ev_obs"] = ""

# -------------------------------
# Render
# -------------------------------
def render(company_id: int):
    st.subheader("Eventos")

    # resets antes de widgets
    if st.session_state.get("ev_form_reset", False):
        _reset_edit_state()
        st.session_state["ev_form_reset"] = False
    if "ev_id" not in st.session_state:
        _reset_edit_state()

    # --- Filtros listado ---
    with st.expander("🔎 Filtros"):
        colf1, colf2 = st.columns(2)
        with colf1:
            f_desde = st.date_input("Desde", value=None, format="YYYY-MM-DD",
                                    min_value=MIN_EVENT_DATE, max_value=MAX_EVENT_DATE, key="ev_filter_from")
        with colf2:
            f_hasta = st.date_input("Hasta", value=None, format="YYYY-MM-DD",
                                    min_value=MIN_EVENT_DATE, max_value=MAX_EVENT_DATE, key="ev_filter_to")

    # Listado superior
    data_ui = list_events_for_ui(company_id)
    if f_desde:
        data_ui = [e for e in data_ui if e["fecha"] and e["fecha"] >= f_desde.isoformat()]
    if f_hasta:
        data_ui = [e for e in data_ui if e["fecha"] and e["fecha"] <= f_hasta.isoformat()]

    cols_view = [
        "id","correlativo","fecha","tipo",
        "socio_transmite","socio_adquiere",
        "rango_desde","rango_hasta",
        "n_participaciones","nuevo_valor_nominal",
        "documento","observaciones",
    ]
    df_view = pd.DataFrame(data_ui)
    for c in cols_view:
        if c not in df_view.columns:
            df_view[c] = None
    st.dataframe(df_view[cols_view], width="stretch", hide_index=True)

    st.markdown("---")
    st.subheader("➕ Alta de evento")

    # Tipos desde enums (añadimos OTRO al final)
    tipo_opts = list(dict.fromkeys((EVENT_TYPES or []) + ["OTRO"]))
    tipo = st.selectbox("Tipo de evento", tipo_opts, index=0, key="ev_new_tipo")

    fecha = st.date_input(
        "Fecha del evento",
        value=date.today(), format="YYYY-MM-DD",
        min_value=MIN_EVENT_DATE, max_value=MAX_EVENT_DATE,
        key="ev_new_fecha"
    ).isoformat()
    observaciones = st.text_input("Observaciones (opcional)", value="", key="ev_new_obs")
    choices, labels, _names = _partners_maps(company_id)

    def _soc_select(label: str, default=None, key:str=""):
        opts = [None] + choices
        idx = 0
        if default in choices:
            idx = opts.index(default)
        return st.selectbox(
            label, opts, index=idx,
            format_func=lambda v: "—" if v is None else labels.get(v, str(v)),
            key=key or f"ev_new_sel_{label.replace(' ', '_')}"
        )

    socio_transmite = None
    socio_adquiere = None
    rango_desde = None
    rango_hasta = None
    n_participaciones = None
    nuevo_valor_nominal = None
    documento = st.text_input("Documento (opcional)", value="", key="ev_new_doc")

    # ------------------- Tipos habituales -------------------
    if tipo in ("TRANSMISION", "SUCESION"):
        st.info("Mueve un rango de participaciones de un socio a otro.")
        socio_transmite = _soc_select("Socio transmite (origen)", key="ev_new_tran_st")
        socio_adquiere  = _soc_select("Socio adquiere (destino)", key="ev_new_tran_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="ev_new_tran_rd")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="ev_new_tran_rh")
        if st.button("Guardar evento", key="ev_new_tran_save"):
            new_id = create_event_generic(
                company_id=company_id, tipo=tipo, fecha=fecha,
                socio_transmite=int(socio_transmite) if socio_transmite else None,
                socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                rango_desde=int(rango_desde) if rango_desde else None,
                rango_hasta=int(rango_hasta) if rango_hasta else None,
                n_participaciones=None, nuevo_valor_nominal=None,
                documento=documento or None, observaciones=observaciones or None,
            )
            st.success(f"{tipo} registrada (evento ID {new_id}).")
            st.rerun()

    elif tipo in ("ALTA", "AMPL_EMISION"):
        st.info("Añade participaciones nuevas a un socio (por rangos).")
        socio_adquiere = _soc_select("Socio adquiere", key="ev_new_alta_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="alta_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="alta_hasta")
        if st.button("Guardar alta/ampliación", key="ev_new_alta_save"):
            new_id = create_event_generic(
                company_id=company_id, tipo=tipo, fecha=fecha,
                socio_transmite=None,
                socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                rango_desde=int(rango_desde) if rango_desde else None,
                rango_hasta=int(rango_hasta) if rango_hasta else None,
                n_participaciones=None, nuevo_valor_nominal=None,
                documento=documento or None, observaciones=observaciones or None,
            )
            st.success(f"{tipo} registrada (evento ID {new_id}).")
            st.rerun()

    elif tipo in ("BAJA", "RED_AMORT"):
        st.info("Reduce participaciones de un socio (por rangos).")
        socio_transmite = _soc_select("Socio transmite (titular)", key="ev_new_baja_st")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="baja_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="baja_hasta")
        if st.button("Guardar baja/reducción", key="ev_new_baja_save"):
            new_id = create_event_generic(
                company_id=company_id, tipo=tipo, fecha=fecha,
                socio_transmite=int(socio_transmite) if socio_transmite else None,
                socio_adquiere=None,
                rango_desde=int(rango_desde) if rango_desde else None,
                rango_hasta=int(rango_hasta) if rango_hasta else None,
                n_participaciones=None, nuevo_valor_nominal=None,
                documento=documento or None, observaciones=observaciones or None,
            )
            st.success(f"{tipo} registrada (evento ID {new_id}).")
            st.rerun()

    elif tipo in ("USUFRUCTO",):
        st.info("Desdobla plena propiedad en nuda propiedad (transmite) y usufructo (adquiere) para un rango.")
        socio_transmite = _soc_select("Socio titular (nuda)", key="ev_new_usuf_st")
        socio_adquiere  = _soc_select("Socio usufructuario", key="ev_new_usuf_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="usuf_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="usuf_hasta")
        if st.button("Guardar usufructo", key="ev_new_usuf_save"):
            new_id = create_event_generic(
                company_id=company_id, tipo=tipo, fecha=fecha,
                socio_transmite=int(socio_transmite) if socio_transmite else None,
                socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                rango_desde=int(rango_desde) if rango_desde else None,
                rango_hasta=int(rango_hasta) if rango_hasta else None,
                n_participaciones=None, nuevo_valor_nominal=None,
                documento=documento or None, observaciones=observaciones or None,
            )
            st.success(f"{tipo} registrado (evento ID {new_id}).")
            st.rerun()

    # --------- Gravámenes (ALTA y CANCELACIÓN) ----------
    elif tipo in START_TYPES:
        st.info("Grava un rango a favor de un acreedor. El **titular** va en 'Socio transmite' y el **acreedor** en 'Socio adquiere'.")
        socio_transmite = _soc_select("Socio transmite (titular afectado)", key="ev_new_grav_st")
        socio_adquiere  = _soc_select("Acreedor / beneficiario", key="ev_new_grav_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="grav_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="grav_hasta")

        if st.button("Guardar gravamen", key="ev_new_grav_save"):
            if not (socio_transmite and socio_adquiere and rango_desde and rango_hasta):
                st.error("Indica titular, acreedor y rango completo.")
            else:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=int(socio_transmite),
                    socio_adquiere=int(socio_adquiere),
                    rango_desde=int(rango_desde), rango_hasta=int(rango_hasta),
                    n_participaciones=None, nuevo_valor_nominal=None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrado (evento ID {new_id}).")
                st.rerun()

    elif tipo in CANCEL_TYPES:
        st.info("Cancela total o parcialmente un gravamen previo. Indica el **mismo acreedor** y el **rango** a levantar.")
        socio_transmite = _soc_select("Socio transmite (titular afectado)", key="ev_new_lev_st")
        socio_adquiere  = _soc_select("Acreedor / beneficiario", key="ev_new_lev_sa")
        c1, c2 = st.columns(2)
        with c1:
            rango_desde = st.number_input("Rango desde", min_value=1, step=1, value=1, key="lev_desde")
        with c2:
            rango_hasta = st.number_input("Rango hasta", min_value=int(rango_desde or 1), step=1, value=int(rango_desde or 1), key="lev_hasta")

        if st.button("Guardar cancelación", key="ev_new_lev_save"):
            if not (socio_transmite and socio_adquiere and rango_desde and rango_hasta):
                st.error("Para cancelar: titular, acreedor y rango son obligatorios.")
            else:
                new_id = create_event_generic(
                    company_id=company_id, tipo=tipo, fecha=fecha,
                    socio_transmite=int(socio_transmite),  # titular
                    socio_adquiere=int(socio_adquiere),    # acreedor
                    rango_desde=int(rango_desde), rango_hasta=int(rango_hasta),
                    n_participaciones=None, nuevo_valor_nominal=None,
                    documento=documento or None, observaciones=observaciones or None,
                )
                st.success(f"{tipo} registrado (evento ID {new_id}).")
                st.rerun()

    elif tipo in ("AMPL_VALOR", "RED_VALOR"):
        st.info("Ajusta el valor nominal (obligatorio en estos tipos).")
        nuevo_valor_nominal = st.number_input(
            "Nuevo valor nominal (€)",
            min_value=0.0, step=0.01, value=0.0, format="%.2f",
            key="ev_new_nvn_change"
        )
        if st.button("Guardar cambio de valor nominal", key="ev_new_nvn_save"):
            new_id = create_event_generic(
                company_id=company_id, tipo=tipo, fecha=fecha,
                socio_transmite=None, socio_adquiere=None,
                rango_desde=None, rango_hasta=None,
                n_participaciones=None,
                nuevo_valor_nominal=float(nuevo_valor_nominal) if nuevo_valor_nominal else None,
                documento=documento or None, observaciones=observaciones or None,
            )
            st.success(f"{tipo} registrado (evento ID {new_id}).")
            st.rerun()

    elif tipo == "REDENOMINACION":
        st.info(
            "La REDENOMINACIÓN se aplica al cierre del día y no altera el % por socio. "
            "Puedes: (a) Global (constancia), (b) Global con recálculo del nº (VN>0 y capital múltiplo), "
            "(c) Por bloque (RD–RH) para compactar/renumerar un bloque)."
        )
        por_bloque = st.toggle("Por bloque (usar RD–RH y socio titular)", value=False, key="ev_new_reden_block")
        recalcular_num = st.toggle("Recalcular nº de participaciones (modo global)", value=False, disabled=por_bloque, key="ev_new_reden_recalc_toggle")

        choices, labels, _ = _partners_maps(company_id)
        socio_bloque = None
        rd = rh = None
        if por_bloque:
            socio_bloque = st.selectbox(
                "Socio (titular del bloque)",
                [None] + choices, index=0,
                format_func=lambda v: "—" if v is None else labels.get(v, str(v)),
                key="ev_new_reden_soc"
            )
            c1, c2 = st.columns(2)
            with c1:
                rd = st.number_input("Rango desde (RD)", min_value=1, step=1, value=1, key="reden_rd")
            with c2:
                rh = st.number_input("Rango hasta (RH)", min_value=int(rd or 1), step=1, value=int(rd or 1), key="reden_rh")

        if st.button("Guardar redenominación", key="ev_new_reden_save"):
            try:
                new_id = create_redenominacion(
                    company_id=company_id,
                    fecha=fecha,
                    por_bloque=bool(por_bloque),
                    socio_id=int(socio_bloque) if (por_bloque and socio_bloque) else None,
                    rango_desde=int(rd) if (por_bloque and rd) else None,
                    rango_hasta=int(rh) if (por_bloque and rh) else None,
                    recalcular_numero=bool(recalcular_num),
                    nuevo_valor_nominal=None,
                    documento=documento or None,
                    observaciones=observaciones or None,
                )
                st.success(f"REDENOMINACION registrada (evento ID {new_id}).")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    else:  # OTRO
        st.info("Tipo libre: puedes informar cualquiera de los campos opcionalmente.")
        c1, c2 = st.columns(2)
        with c1:
            socio_transmite = _soc_select("Socio transmite (opcional)", key="ev_new_otro_st")
            rango_desde = st.number_input("Rango desde (opcional)", min_value=0, step=1, value=0, key="otro_desde")
        with c2:
            socio_adquiere = _soc_select("Socio adquiere (opcional)", key="ev_new_otro_sa")
            rango_hasta = st.number_input("Rango hasta (opcional)", min_value=0, step=1, value=0, key="otro_hasta")
        n_participaciones = st.number_input("Nº de participaciones (opcional)", min_value=0, step=1, value=0, key="ev_new_otro_np")
        if st.button("Guardar evento genérico", key="ev_new_otro_save"):
            new_id = create_event_generic(
                company_id=company_id, tipo="OTRO", fecha=fecha,
                socio_transmite=int(socio_transmite) if socio_transmite else None,
                socio_adquiere=int(socio_adquiere) if socio_adquiere else None,
                rango_desde=int(rango_desde) if rango_desde else None,
                rango_hasta=int(rango_hasta) if rango_hasta else None,
                n_participaciones=int(n_participaciones) if n_participaciones else None,
                nuevo_valor_nominal=None,
                documento=documento or None,
                observaciones=observaciones or None,
            )
            st.success(f"Evento registrado (ID {new_id}).")
            st.rerun()

    # ------------------- Edición / Borrado -------------------
    st.markdown("---")
    with st.expander("✏️ Editar / Eliminar evento", expanded=False):
        choices_full, labels_map, _ = _partners_maps(company_id)

        def safe_index(options, value, default=0):
            try:
                return options.index(value)
            except Exception:
                return default

        # --- fila: ID + cargar ---
        col_id, col_btn = st.columns([1, 1])
        with col_id:
            st.number_input("ID evento", min_value=0, step=1, key="ev_id")
        with col_btn:
            if st.button("🔎 Cargar evento"):
                eid = int(st.session_state.get("ev_id") or 0)
                if eid > 0:
                    ev = get_event(company_id, eid)
                    if ev:
                        st.session_state["ev_tipo"]  = ev.get("tipo") or (EVENT_TYPES[0] if EVENT_TYPES else "OTRO")
                        st.session_state["ev_fecha"] = _to_date_or_none(ev.get("fecha"))
                        st.session_state["ev_st"]    = int(ev["socio_transmite"]) if ev.get("socio_transmite") is not None else None
                        st.session_state["ev_sa"]    = int(ev["socio_adquiere"]) if ev.get("socio_adquiere") is not None else None
                        st.session_state["ev_rd"]    = int(ev["rango_desde"] or 0)
                        st.session_state["ev_rh"]    = int(ev["rango_hasta"] or 0)
                        st.session_state["ev_np"]    = int(ev.get("n_participaciones") or 0)
                        st.session_state["ev_nvn"]   = float(ev.get("nuevo_valor_nominal") or 0.0)
                        st.session_state["ev_doc"]   = ev.get("documento") or ""
                        st.session_state["ev_obs"]   = ev.get("observaciones") or ""
                        st.success(f"Cargado evento ID {eid}.")
                    else:
                        st.warning(f"No se encontró el evento ID {eid}.")
                else:
                    st.info("Introduce un ID > 0 para cargar.")
                st.rerun()

        # --- formulario de edición ---
        tipo_opts_full = list(dict.fromkeys((EVENT_TYPES or []) + ["OTRO"]))
        col1, col2 = st.columns(2)
        with col1:
            st.selectbox(
                "Tipo",
                tipo_opts_full,
                index=safe_index(
                    tipo_opts_full,
                    st.session_state.get("ev_tipo", "OTRO"),
                    default=safe_index(tipo_opts_full, "OTRO", 0)
                ),
                key="ev_tipo"
            )
            st.date_input(
                "Fecha",
                value=st.session_state.get("ev_fecha", None),
                min_value=MIN_EVENT_DATE, max_value=MAX_EVENT_DATE,
                format="YYYY-MM-DD",
                key="ev_fecha"
            )
            st.number_input("Rango desde", min_value=0, step=1,
                            value=int(st.session_state.get("ev_rd") or 0), key="ev_rd")
            st.number_input("Rango hasta", min_value=0, step=1,
                            value=int(st.session_state.get("ev_rh") or 0), key="ev_rh")
            st.number_input("Nº de participaciones (si aplica)", min_value=0, step=1,
                            value=int(st.session_state.get("ev_np") or 0), key="ev_np")

        with col2:
            opts_soc = [None] + choices_full
            st.selectbox(
                "Socio transmite",
                opts_soc,
                index=safe_index(opts_soc, st.session_state.get("ev_st")),
                format_func=lambda v: "—" if v is None else labels_map.get(v, str(v)),
                key="ev_st"
            )
            st.selectbox(
                "Socio adquiere",
                opts_soc,
                index=safe_index(opts_soc, st.session_state.get("ev_sa")),
                format_func=lambda v: "—" if v is None else labels_map.get(v, str(v)),
                key="ev_sa"
            )
            st.number_input(
                "Nuevo valor nominal (€)",
                min_value=0.0, step=0.01, format="%.2f",
                value=float(st.session_state.get("ev_nvn") or 0.0),
                key="ev_nvn"
            )
            st.text_input("Documento", value=st.session_state.get("ev_doc",""), key="ev_doc")
            st.text_input("Observaciones", value=st.session_state.get("ev_obs",""), key="ev_obs")

        b1, b2, b3 = st.columns(3)
        with b1:
            if st.button("💾 Guardar cambios"):
                eid = int(st.session_state.get("ev_id") or 0)
                if eid <= 0:
                    st.error("Indica un ID de evento válido.")
                else:
                    fecha_edit = (
                        st.session_state["ev_fecha"].isoformat()
                        if st.session_state.get("ev_fecha") else date.today().isoformat()
                    )
                    update_event(
                        event_id=eid,
                        company_id=company_id,
                        tipo=st.session_state.get("ev_tipo"),
                        fecha=fecha_edit,
                        socio_transmite=st.session_state.get("ev_st"),
                        socio_adquiere=st.session_state.get("ev_sa"),
                        rango_desde=(int(st.session_state.get("ev_rd") or 0) or None),
                        rango_hasta=(int(st.session_state.get("ev_rh") or 0) or None),
                        n_participaciones=(int(st.session_state.get("ev_np") or 0) or None),
                        nuevo_valor_nominal=(float(st.session_state.get("ev_nvn") or 0.0) or None),
                        documento=(st.session_state.get("ev_doc") or None),
                        observaciones=(st.session_state.get("ev_obs") or None),
                    )
                    log.info("Event updated id=%s company_id=%s", eid, company_id)
                    st.success("Evento actualizado.")
                    st.rerun()
        with b2:
            if st.button("🗑️ Eliminar evento", disabled=(int(st.session_state.get("ev_id") or 0) == 0)):
                eid = int(st.session_state["ev_id"])
                delete_event(event_id=eid, company_id=company_id)
                log.warning("Event deleted id=%s company_id=%s", eid, company_id)
                st.success("Evento eliminado.")
                st.session_state["ev_form_reset"] = True
                st.rerun()
        with b3:
            if st.button("🧹 Limpiar formulario"):
                st.session_state["ev_form_reset"] = True
                st.rerun()

# >>>>>>>>>>>>> _review_correlativos/app/ui/pages/partners.py <<<<<<<<<<<<<

# app/ui/partners.py
from __future__ import annotations
import streamlit as st
import pandas as pd
import logging
from datetime import date, datetime

from app.core.services.partners_service import list_partners, save_partner
from app.core.repositories.partners_repo import get_partner  # para cargar por ID
from app.core.services.reporting_service import active_encumbrances_affecting_partner as enc_aff
from app.infra.db import get_connection                     # delete simple

log = logging.getLogger(__name__)

MIN_PERSON_DATE = date(1900, 1, 1)
MAX_PERSON_DATE = date.today()

# ---------------- helpers ----------------
def _to_date_or_none(s: str | None) -> date | None:
    if not s:
        return None
    try:
        return datetime.strptime(s, "%Y-%m-%d").date()
    except Exception:
        return None

def _delete_partner(company_id: int, partner_id: int) -> None:
    """Elimina un socio por id/compañía. (Podemos moverlo a partners_service más adelante.)"""
    with get_connection() as conn:
        conn.execute("DELETE FROM partners WHERE id=? AND company_id=?", (partner_id, company_id))

def _reset_form_state():
    # Valores por defecto del formulario
    st.session_state["pa_id"] = 0
    st.session_state["pa_nombre"] = ""
    st.session_state["pa_nif"] = ""
    st.session_state["pa_dom"] = ""
    st.session_state["pa_nac"] = ""
    st.session_state["pa_fecha"] = None

# ---------------- UI ---------------------
def render(company_id: int):
    st.subheader("Socios")

    # ---- estado inicial y “pendientes” (ANTES de dibujar widgets) ----
    if "pa_id" not in st.session_state:
        _reset_form_state()
    if "pa_id_pending" not in st.session_state:
        st.session_state["pa_id_pending"] = None
    if "pa_form_reset" not in st.session_state:
        st.session_state["pa_form_reset"] = False

    # aplica pa_id_pending en el arranque del render y límpialo
    if st.session_state["pa_id_pending"] is not None:
        st.session_state["pa_id"] = int(st.session_state["pa_id_pending"])
        st.session_state["pa_id_pending"] = None

    # reset solicitado en el ciclo anterior
    if st.session_state.get("pa_form_reset", False):
        _reset_form_state()
        st.session_state["pa_form_reset"] = False

    # Listado
    data = list_partners(company_id)
    df = pd.DataFrame(data) if data else pd.DataFrame(columns=[
        "id","company_id","nombre","nif","domicilio","nacionalidad","fecha_nacimiento_constitucion"
    ])
    st.dataframe(df, use_container_width=True, hide_index=True)

    st.markdown("---")
    with st.expander("➕ Alta / edición de socio", expanded=True):
        # Fila ID + cargar
        col_id, col_btn = st.columns([1,1])
        with col_id:
            st.number_input("ID (0 para alta)", min_value=0, step=1, key="pa_id")
        with col_btn:
            if st.button("🔎 Cargar datos"):
                pid = int(st.session_state.get("pa_id") or 0)
                if pid > 0:
                    row = get_partner(company_id, pid)
                    if row:
                        st.session_state["pa_nombre"] = row.get("nombre") or ""
                        st.session_state["pa_nif"]    = row.get("nif") or ""
                        st.session_state["pa_dom"]    = row.get("domicilio") or ""
                        st.session_state["pa_nac"]    = row.get("nacionalidad") or ""
                        st.session_state["pa_fecha"]  = _to_date_or_none(row.get("fecha_nacimiento_constitucion"))
                        st.success(f"Cargado socio ID {pid}.")
                    else:
                        st.warning(f"No se encontró el socio ID {pid}.")
                else:
                    st.info("Introduce un ID > 0 para cargar.")
                st.rerun()

        # Campos (usan session_state como única fuente de verdad)
        col1, col2 = st.columns(2)
        with col1:
            st.text_input("Nombre", key="pa_nombre")
            st.text_input("NIF/NIE/CIF", key="pa_nif")
            st.text_input("Domicilio", key="pa_dom")
        with col2:
            st.text_input("Nacionalidad", key="pa_nac")
            st.date_input(
                "Fecha nacimiento / constitución",
                min_value=MIN_PERSON_DATE, max_value=MAX_PERSON_DATE,
                format="YYYY-MM-DD", key="pa_fecha"
            )

        # Botonera
        bA, bB, bC = st.columns([1,1,1])
        with bA:
            if st.button("💾 Guardar socio"):
                fid = int(st.session_state.get("pa_id") or 0) or None
                fecha_iso = st.session_state["pa_fecha"].isoformat() if st.session_state.get("pa_fecha") else None
                new_id = save_partner(
                    id=fid,
                    company_id=company_id,
                    nombre=st.session_state.get("pa_nombre","").strip(),
                    nif=st.session_state.get("pa_nif","").strip(),
                    domicilio=(st.session_state.get("pa_dom","").strip() or None),
                    nacionalidad=(st.session_state.get("pa_nac","").strip() or None),
                    fecha_nacimiento_constitucion=fecha_iso
                )
                log.info("Partner saved id=%s company_id=%s", new_id, company_id)
                st.success(f"Guardado socio ID {new_id}")
                # ⚠️ no tocar pa_id directamente; usa pending + rerun
                st.session_state["pa_id_pending"] = int(new_id)
                st.rerun()

        with bB:
            if st.button("🗑️ Eliminar socio", disabled=(int(st.session_state.get("pa_id") or 0) == 0)):
                pid = int(st.session_state["pa_id"])
                try:
                    _delete_partner(company_id, pid)
                    log.warning("Partner deleted id=%s company_id=%s", pid, company_id)
                    st.success(f"Socio {pid} eliminado.")
                    st.session_state["pa_form_reset"] = True
                except Exception as e:
                    st.error(f"No se pudo eliminar: {e}")
                st.rerun()

        with bC:
            if st.button("🧹 Limpiar formulario"):
                st.session_state["pa_form_reset"] = True
                st.rerun()


# >>>>>>>>>>>>> _review_correlativos/app/ui/pages/utilities.py <<<<<<<<<<<<<

# app/ui/pages/utilities.py
from __future__ import annotations
import logging
from pathlib import Path
from datetime import datetime
from io import BytesIO
import streamlit as st

from app.core.services.backup_service import (
    create_backup, list_backups, restore_backup, BK_DIR
)
from app.core.services.maintenance_service import (
    db_quick_summary, db_integrity_check, db_fk_check,
    run_analyze, run_reindex, run_vacuum
)
from app.infra.logging import LOG_FILE

log = logging.getLogger(__name__)

LEVELS = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]

def _read_tail(path: Path, max_lines: int) -> list[str]:
    if not path.exists():
        return []
    with path.open("r", encoding="utf-8") as f:
        lines = f.readlines()
    return lines[-max_lines:]

def render(company_id: int | None = None):
    st.subheader("🛠️ Utilidades")

    tabs = st.tabs(["💾 Backups", "🩺 Salud BD", "🧹 Mantenimiento", "📜 Logs"])

    # =========================
    # 1) BACKUPS
    # =========================
    with tabs[0]:
        st.markdown("### Copias de seguridad")
        colA, colB = st.columns([1, 2], gap="large")

        # Crear backup
        with colA:
            with st.form("form_create_backup", clear_on_submit=False):
                st.caption("Crea una copia de la base de datos actual en `data/backups/`.")
                submit = st.form_submit_button("🧩 Crear backup ahora", use_container_width=True)
                if submit:
                    try:
                        with st.status("Creando backup…", expanded=True) as status:
                            created = create_backup()
                            status.update(label="Backup creado ✅", state="complete")
                        st.success(f"Backup creado: {', '.join(p.name for p in created)}")
                        st.rerun()
                    except Exception as e:
                        log.error("Error creando backup: %s", e, exc_info=True)
                        st.error(f"Error creando backup: {e}")

        # Restaurar / descargar
        with colB:
            backups = list_backups()
            if not backups:
                st.info(f"No hay backups en `{BK_DIR}`.")
            else:
                names = [bk.name for bk in backups]
                idx_default = max(0, len(names) - 1)
                with st.form("form_restore_backup", clear_on_submit=False):
                    st.caption("Selecciona y restaura un backup existente. Se hará copia previa del actual.")
                    sel_name = st.selectbox("Backup (.db) disponible", names, index=idx_default, key="bk_pick")
                    cols = st.columns([1, 1, 2])
                    with cols[0]:
                        down = st.form_submit_button("⬇️ Descargar seleccionado")
                    with cols[1]:
                        confirm = st.text_input("Confirmación", value="", placeholder="Escribe RESTAURAR")
                    with cols[2]:
                        do_restore = st.form_submit_button(
                            "⚠️ Restaurar seleccionado",
                            disabled=(confirm != "RESTAURAR"),
                            use_container_width=True
                        )

                    # Descargar
                    if down:
                        picked = BK_DIR / sel_name
                        if picked.exists():
                            with picked.open("rb") as f:
                                st.download_button(
                                    "Descargar ahora",
                                    data=f.read(),
                                    file_name=picked.name,
                                    mime="application/octet-stream",
                                    use_container_width=True
                                )
                        else:
                            st.error("El backup seleccionado ya no existe.")

                    # Restaurar
                    if do_restore:
                        try:
                            with st.status("Restaurando backup…", expanded=True) as status:
                                restored = restore_backup(BK_DIR / sel_name)
                                status.update(label="Restauración completada ✅", state="complete")
                            st.success(f"Restaurado: {', '.join(p.name for p in restored)}. Reinicia la app si es necesario.")
                        except Exception as e:
                            log.error("Error restaurando backup: %s", e, exc_info=True)
                            st.error(f"Error restaurando backup: {e}")

        st.caption(f"BD activa: `{(BK_DIR.parent / 'libro_socios.db')}`  •  Carpeta de backups: `{BK_DIR}`")

    # =========================
    # 2) SALUD BD
    # =========================
    with tabs[1]:
        st.markdown("### Comprobaciones de integridad")
        c1, c2 = st.columns(2)
        with c1:
            if st.button("🔎 Comprobar integridad / FK", use_container_width=True, key="btn_check_both"):
                with st.status("Ejecutando PRAGMA integrity_check y foreign_key_check…", expanded=True) as status:
                    summary = db_quick_summary()
                    status.update(label="Comprobaciones finalizadas ✅", state="complete")
                _render_health_summary(summary)

        with c2:
            st.caption("Comprueba integridad de la BD y violaciones de claves foráneas.")

        st.divider()

        col3, col4, col5 = st.columns(3)
        with col3:
            if st.button("Solo integrity_check", use_container_width=True, key="btn_integrity"):
                msgs = db_integrity_check()
                if not msgs:
                    st.success("OK: integrity_check sin incidencias.")
                else:
                    st.error("PRAGMA integrity_check devolvió incidencias:")
                    st.code("\n".join(msgs) or "(sin detalles)")
        with col4:
            if st.button("Solo foreign_key_check", use_container_width=True, key="btn_fk"):
                fks = db_fk_check()
                if not fks:
                    st.success("OK: foreign_key_check sin incidencias.")
                else:
                    st.error("Violaciones FK:")
                    lines = [f"tabla={t} rowid={r} fk_tabla={p} fk_id={fk}" for (t, r, p, fk) in fks]
                    st.code("\n".join(lines) or "(sin detalles)")
        with col5:
            st.caption("Botones individuales por si necesitas aislar un problema.")

    # =========================
    # 3) MANTENIMIENTO
    # =========================
    with tabs[2]:
        st.markdown("### Operaciones periódicas")
        with st.form("form_maintenance"):
            st.caption("Selecciona las tareas a ejecutar:")
            colx, coly, colz = st.columns(3)
            with colx:
                do_analyze = st.checkbox("ANALYZE", value=True)
            with coly:
                do_reindex = st.checkbox("REINDEX", value=False)
            with colz:
                do_vacuum = st.checkbox("VACUUM", value=False)

            run = st.form_submit_button("▶️ Ejecutar selección", use_container_width=True)

            if run:
                with st.status("Ejecutando mantenimiento…", expanded=True) as status:
                    if do_analyze:
                        status.write("• ANALYZE…"); run_analyze()
                    if do_reindex:
                        status.write("• REINDEX…"); run_reindex()
                    if do_vacuum:
                        status.write("• VACUUM…"); run_vacuum()
                    status.update(label="Mantenimiento completado ✅", state="complete")
                st.success("Operación finalizada.")

        st.caption("Sugerencias: ANALYZE tras cargas grandes; REINDEX si sospechas corrupción de índices; VACUUM para compactar.")

    # =========================
    # 4) LOGS
    # =========================
    with tabs[3]:
        st.markdown("### Visor de logs")
        if LOG_FILE.exists():
            size_kb = LOG_FILE.stat().st_size / 1024
            ts = datetime.fromtimestamp(LOG_FILE.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')
            st.caption(f"Ruta: `{LOG_FILE}` • Tamaño: {size_kb:.1f} KB • Últ. modif: {ts}")
        else:
            st.info(f"No se encontró el log en: {LOG_FILE}")

        with st.form("form_logs"):
            colA, colB, colC, colD = st.columns([1, 1.2, 1, 2])
            with colA:
                max_lines = st.number_input("Líneas", min_value=50, max_value=10000, value=500, step=50, key="log_lines")
            with colB:
                levels = st.multiselect("Niveles", LEVELS, default=["INFO", "WARNING", "ERROR", "CRITICAL"], key="log_levels")
            with colC:
                regex_mode = st.toggle("Regex", value=False, key="log_regex")
            with colD:
                query = st.text_input("Buscar", value="", placeholder=("expresión regular" if regex_mode else "contiene…"), key="log_query")

            submitted = st.form_submit_button("🔄 Mostrar / refrescar", use_container_width=True)

        if submitted and LOG_FILE.exists():
            lines = _read_tail(LOG_FILE, max_lines)

            def _keep(line: str) -> bool:
                if levels and not any(f" {lvl} " in line for lvl in levels):
                    return False
                if query:
                    if regex_mode:
                        import re
                        try:
                            return re.search(query, line, flags=re.IGNORECASE) is not None
                        except re.error:
                            # patrón inválido: devolvemos nada y mostramos aviso
                            return False
                    else:
                        return query.lower() in line.lower()
                return True

            filtered = [ln for ln in lines if _keep(ln)]
            st.text("".join(filtered) if filtered else "(sin resultados)")

            # Descarga (solo lo que se muestra)
            if filtered:
                buf = BytesIO("".join(filtered).encode("utf-8"))
                st.download_button(
                    "⬇️ Descargar líneas mostradas",
                    data=buf.getvalue(),
                    file_name="app_log_filtrado.txt",
                    mime="text/plain",
                    use_container_width=True
                )
        elif submitted and not LOG_FILE.exists():
            st.warning("No hay archivo de log para mostrar.")

def _render_health_summary(summary: dict):
    ok_i = summary.get("integrity_ok", False)
    ok_f = summary.get("fk_ok", False)
    c1, c2 = st.columns(2)
    with c1:
        st.metric("Integrity check", "OK" if ok_i else "ERROR")
    with c2:
        st.metric("Foreign key check", "OK" if ok_f else "ERROR")

    if not ok_i:
        st.error("PRAGMA integrity_check devolvió incidencias:")
        st.code("\n".join(summary.get("integrity_messages", [])) or "(sin detalles)")

    if not ok_f:
        st.error("Violaciones FK:")
        lines = [
            f"tabla={t} rowid={r} fk_tabla={p} fk_id={fk}"
            for (t, r, p, fk) in summary.get("fk_violations", [])
        ]
        st.code("\n".join(lines) or "(sin detalles)")

# >>>>>>>>>>>>> _review_correlativos/migrations/V01_bootstrap.sql <<<<<<<<<<<<<



# >>>>>>>>>>>>> _review_correlativos/migrations/V02_add_partners_board_columns.sql <<<<<<<<<<<<<

-- V02_add_partners_board_columns.sql
-- Añade columnas nuevas (ajusta nombres si difieren de tu esquema).
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;

-- partners: fecha de nacimiento / constitución
ALTER TABLE partners ADD COLUMN fecha_nacimiento_constitucion TEXT;

-- board_members: datos de contacto
ALTER TABLE board_members ADD COLUMN direccion TEXT;
ALTER TABLE board_members ADD COLUMN telefono TEXT;
ALTER TABLE board_members ADD COLUMN email TEXT;

COMMIT;
PRAGMA foreign_keys=ON;

# >>>>>>>>>>>>> _review_correlativos/migrations/V03_event_types_seed.sql <<<<<<<<<<<<<

-- V03_event_types_seed.sql
-- Si tienes tabla de catálogo de tipos de evento, inserta los nuevos.
-- Si no la tienes, ignora este script (o crea la tabla si te interesa).
-- Ajusta nombres de columnas/tabla si son distintos.

-- CREATE TABLE IF NOT EXISTS event_types(id INTEGER PRIMARY KEY, code TEXT UNIQUE, name TEXT);
INSERT OR IGNORE INTO event_types(code, name) VALUES ('SUCESION', 'Sucesión (herencia)');
INSERT OR IGNORE INTO event_types(code, name) VALUES ('RED_AMORT', 'Reducción por amortización');

# >>>>>>>>>>>>> _review_correlativos/migrations/V04_add_companies_extras.sql <<<<<<<<<<<<<

-- V04_add_companies_extras.sql
-- Añade columnas opcionales a companies (ISO yyyy-mm-dd para fecha_constitucion)
ALTER TABLE companies ADD COLUMN domicilio TEXT;
ALTER TABLE companies ADD COLUMN fecha_constitucion TEXT;